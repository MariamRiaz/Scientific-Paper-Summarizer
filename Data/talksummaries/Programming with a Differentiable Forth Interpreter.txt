21	10	We show that given only input-output pairs, @4 can learn to fill the sketch and generalise well to problems of unseen size.
23	149	We show that when provided with basic algorithmic scaffolding and trained jointly with an upstream LSTM (Hochreiter & Schmidhuber, 1997), @4 is able to learn to read natural language narratives, extract important numerical quantities, and reason with these, ultimately answering corresponding mathematical questions without the need for explicit intermediate representations used in previous work.
24	203	The contributions of our work are as follows: i) We present a neural implementation of a dual stack machine underlying Forth, ii) we introduce Forth sketches for programming with partial procedural background knowledge, iii) we apply Forth sketches as a procedural prior on learning algorithms from data, iv) we introduce program code optimisations based on symbolic execution that can speed up neural execution, and v) using Forth sketches we obtain state-of-the-art for end-to-end reasoning about quantities expressed in natural language narratives.
25	57	Forth is a simple Turing-complete stack-based programming language (ANSI, 1994; Brodie, 1980).
26	122	We chose Forth as the host language of our work because i) it is an established, general-purpose high-level language relatively close to machine code, ii) it promotes highly modular programs through use of branching, loops and function calls, thus bringing out a good balance between assembly and higher level languages, and importantly iii) its abstract machine is simple enough for a straightforward creation of its continuous approximation.
27	115	Forth’s underlying abstract machine is represented by a state S = (D,R,H,c), which contains two stacks: a data evaluation pushdown stack D (data stack) holds values for manipulation, and a return address pushdown stackR (return stack) assists with return pointers and subroutine calls.
28	259	These are accompanied by a heap or random memory access buffer H , and a program counter c. A Forth program P is a sequence1 of Forth words (i.e. commands)P =w1...wn.
29	80	The role of a word varies, encompassing language keywords, primitives, and user-defined subroutines (e.g. DROP discards the top element of the data stack, or DUP duplicates the top element of the data stack).2 Each word wi defines a transition function between machine states wi : S !
32	43	An example of a Bubble sort algorithm implemented in Forth is shown in Listing 1 in everything except lines 3b-4c.
34	26	Line 10 executes the main loop over the sequence.
35	6	Lines 2-7 words, detailed in Appendix A.
36	170	1 : BUBBLE ( a1 ... an n-1 -- one pass ) 2 DUP IF >R 3a OVER OVER < IF SWAP THEN 4a R> SWAP >R 1- BUBBLE R> 3b { observe D0 D-1 -> permute D-1 D0 R0} 4b 1- BUBBLE R> 3c { observe D0 D-1 -> choose NOP SWAP } 4c R> SWAP >R 1- BUBBLE R> 5 ELSE 6 DROP 7 THEN 8 ; 9 : SORT ( a1 .. an n -- sorted ) 10 1- DUP 0 DO >R R@ BUBBLE R> LOOP DROP 11 ; 12 2 4 2 7 4 SORT \ Example call Listing 1: Three code alternatives (white lines are common to all, coloured/lettered lines are alternative-specific): i) Bubble sort in Forth (a lines – green), ii) PERMUTE sketch (b lines – blue), and iii) COMPARE sketch (c lines – yellow).
37	82	denote the BUBBLE procedure – comparison of top two stack numbers (line 3a), and the recursive call to itself (line 4a).
