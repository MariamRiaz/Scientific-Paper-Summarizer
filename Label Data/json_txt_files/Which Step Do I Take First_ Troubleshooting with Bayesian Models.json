{"sections": [{"text": "Online discussion forums and community question-answering websites provide one of the primary avenues for online users to share information. In this paper, we propose text mining techniques which aid users navigate troubleshooting-oriented data such as questions asked on forums and their suggested solutions. We introduce Bayesian generative models of the troubleshooting data and apply them to two interrelated tasks: (a) predicting the complexity of the solutions (e.g., plugging a keyboard in the computer is easier compared to installing a special driver) and (b) presenting them in a ranked order from least to most complex. Experimental results show that our models are on par with human performance on these tasks, while outperforming baselines based on solution length or readability."}, {"heading": "1 Introduction", "text": "Online forums and discussion boards have created novel ways for discovering, sharing, and distributing information. Users typically post their questions or problems and obtain possible solutions from other users. Through this simple mechanism of community-based question answering, it is possible to find answers to personal, open-ended, or highly specialized questions. However, navigating the information available in web-archived data can be challenging given the lack of appropriate search and browsing facilities.\nTable 1 shows examples typical of the problems and proposed solutions found in troubleshootingoriented online forums. The first problem concerns a shaky monitor and has three solutions with increasing degrees of complexity. Solution (1) is probably easiest to implement in terms of user time, effort, and expertise; solution (3) is most complex (i.e., the user should understand what signal timing is and\nthen try to establish whether it is within the specification of the monitor), whereas solution (2) is somewhere in between. In most cases, the solutions are not organized in any particular fashion, neither in terms of content nor complexity.\nIn this paper, we present models to automatically predict the complexity of troubleshooting solutions, which we argue could improve user experience, and potentially help solve the problem faster (e.g., by prioritizing easier solutions). Automatically structuring solutions according to complexity could also facilitate search through large archives of solutions or serve as a summarization tool. From a linguistic perspective, learning how complexity is verbalized can be viewed as an instance of grounded language acquisition. Solutions direct users to carry out certain actions (e.g., on their computers or devices) and complexity is an attribute of these actions. Information access systems incorporating a notion of complexity would allow to take user intentions into account and how these translate into natural language. Current summarization and information retrieval methods are agnostic of such types of text semantics. Moreover, the models presented here could be used for analyzing collaborative prob-\n73\nTransactions of the Association for Computational Linguistics, vol. 3, pp. 73\u201385, 2015. Action Editor: Eric Fosler-Lussier. Submission batch: 9/2014; Revision batch 1/2015; Published 2/2015. c\u00a92015 Association for Computational Linguistics.\nlem solving and its social networks. Characterizing the content of discussion forums by their complexity can provide additional cues for identifying user authority and if there is a need for expert intervention.\nWe begin by validating that the task is indeed meaningful and that humans perceive varying degrees of complexity when reading troubleshooting solutions. We also show experimentally that users agree in their intuitions about the relative complexity of different solutions to the same problem. We define \u201ccomplexity\u201d as an aggregate notion of the time, expertise, and money required to implement a solution. We next model the complexity prediction task, following a Bayesian approach. Specifically, we learn to assign complexity levels to solutions based on their linguistic makeup. We leverage weak supervision in the form of lists of solutions (to different problems) approximately ordered from low to high complexity (see Table 1). We assume that the data is generated from a fixed number of discrete complexity levels. Each level has a probability distribution over the vocabulary and there is a canonical ordering between levels indicating their relative complexity. During inference, we recover the vocabularies of the complexity levels and the ordering of levels that explains the solutions and their attested sequences in the training data.\nWe explore two Bayesian models differing in how they learn an ordering among complexity levels. The first model is local, it assigns an expected position (in any list of solutions) to each complexity level and orders the levels based on this expected position value. The second model is global, it defines probabilities over permutations of complexity levels and directly uncovers a consensus ordering from the training data. We evaluate our models on a solution ordering task, where the goal is to rank solutions from least to most complex. We show that a supervised ranking approach using features based on the predictions of our generative models is on par with human performance on this task while outperforming competitive baselines based on length and readability of the solution text."}, {"heading": "2 Related work", "text": "There is a long tradition of research on decisiontheoretic troubleshooting where the aim is to find a cost efficient repair strategy for a malfunctioning device (Heckerman et al., 1995). Typically, a\ndiagnostic procedure (i.e., a planner) is developed that determines the next best troubleshooting step by estimating the expected cost of repair for various plans. Costs are specified by domain experts and are usually defined in terms of time and/or money incurred by carrying out a particular repair action. Our notion of complexity is conceptually similar to the cost of an action, however we learn to predict complexity levels rather than calibrate them manually. Also note that our troubleshooting task is not device specific. Our models learn from troubleshootingoriented data without any restrictions on the problems being solved.\nPrevious work on web-based user support has mostly focused on thread analysis. The idea is to model the content structure of forum threads by analyzing the requests for information and suggested solutions in the thread data (Wang et al., 2011; Kim et al., 2010). Examples of such analysis include identifying which earlier post(s) a given post responds to and in what manner (e.g., is it a question, an answer or a confirmation). Other related work (Lui and Baldwin, 2009) identifies user characteristics in such data, i.e., whether users express themselves clearly, whether they are technically knowledgeable, and so on. Although our work does not address threaded discourse, we analyze the content of troubleshooting data and show that it is possible to predict the complexity levels for suggested solutions from surface lexical cues.\nOur work bears some relation to language grounding, the problem of extracting representations of the meaning of natural language tied to the physical world. Mapping instructions to executable actions is an instance of language grounding with applications to automated troubleshooting (Branavan et al., 2009; Eisenstein et al., 2009), navigation (Vogel and Jurafsky, 2010), and game-playing (Branavan et al., 2011). In our work, there is no direct attempt to model the environment or the troubleshooting steps. Rather, we study the language of instructions and how it correlates with the complexity of the implied actions. Our results show that it possible to predict complexity, while being agnostic about the semantics of the domain or the effect of the instructions in the corresponding environment.\nOur generative models are trained on existing archives of problems with corresponding solutions (approximately ordered from least to most complex)\nand learn to predict an ordering for new sets of solutions. This setup is related to previous studies on information ordering where the aim is to learn statistical patterns of document structure which can be then used to order new sentences or paragraphs in a coherent manner. Some approaches approximate the structure of a document via topic and entity sequences using local dependencies such as conditional probabilities (Lapata, 2003; Barzilay and Lapata, 2008) or Hidden Markov Models (Barzilay and Lee, 2004). More recently, global approaches which directly model the permutations of topics in the document have been proposed (Chen et al., 2009b). Following this line of work, one of our models uses the Generalized Mallows Model (Fligner and Verducci, 1986) in its generative process which allows to model permutations of complexity levels in the training data."}, {"heading": "3 Problem formulation", "text": "Our aim in this work is to learn models which can automatically reorder solutions to a problem from low to high complexity. Let G = (c1, c2, .. cN ) be a collection of solutions to a specific problem. We wish to output a list G\u2032 = (c\u20321, c \u2032 2, .. c \u2032 N ), such that D(c\u2032j) \u2264 D(c\u2032j+1), where D(x) refers to the complexity of solution x."}, {"heading": "3.1 Corpus Collection", "text": "As training data we are given problem-solution sets similar to the examples in Table 1 where the solutions are approximately ordered from low to high complexity. A solution set Si is specific to problem Pi, and contains an ordered list of NPi solutions Si = (x1, x2, . . . , xNPi ) such that D(xj) <D(xj+1). We refer to the number of solutions related to a problem, NPi , as its solution set size.\nFor our experiments, we collected 300 problems1 and their solutions from multiple web sites including the computing support pages of Microsoft, Apple, HP, as well as amateur computer help websites such as www.computerhope.com. The problems were mostly frequently asked questions (FAQs) referring to malfunctioning personal computers and smart phones. The solutions were provided by computer experts or experienced users in the absence\n1The corpus can be downloaded from http: //www.homepages.inf.ed.ac.uk/alouis/ solutionComplexity.html.\nof any interaction with other users or their devices and thus constitute a generic list of steps to try out. We assume that in such a situation, the solution providers are likely to suggest simpler solutions before other complex ones, leading to the solution lists being approximately ordered from low to high complexity. In the next section, we verify this assumption experimentally. In this dataset, the solution set size varies between 2 and 16 and the average number is 4.61. Figure 1 illustrates the histogram of solution set sizes found in our corpus. We only considered problems which have no less than two solutions. All words in the corpus were lemmatized and html links and numbers were replaced with placeholders. The resulting vocabulary was approximately 2,400 word types (62,152 tokens).\nNote that our dataset provides only weak supervision for learning. The relative complexity of solutions for the same problem is observed, however, the relative complexity of solutions across different problems is unknown. For example, a hardware issue may generally receive highly complex solutions whereas a microphone issue mostly simple ones."}, {"heading": "3.2 Task Validation", "text": "In this section, we detail an annotation experiment where we asked human judges to rank the randomly permuted contents of a solution set according to perceived complexity. We performed this study for two reasons. Firstly, to ascertain that participants are able to distinguish degrees of complexity and agree on the complexity level of a solution. Secondly, to examine whether the ordering produced by participants corresponds to the (gold-standard) FAQ order of the solutions. If true, this would support our hy-"}, {"heading": "A 0.421 0.525 0.625 0.465", "text": ""}, {"heading": "B 0.436 0.434 0.252", "text": ""}, {"heading": "C 0.584 0.303", "text": ""}, {"heading": "D 0.402", "text": "pothesis that the solutions in our FAQ corpus are frequently presented according to complexity and that this ordering is reasonable supervision for our models.\nMethod We randomly sampled 100 solution sets (their sizes vary between 2 and 16) from the FAQ corpus described in the previous section and randomly permuted the contents of each set. Four annotators, one an author of this paper, and three graduate and undergraduate students in Computer Science were asked to order the solutions in each set from easy to most complex. An easier solution was defined as one \u201cwhich takes less time or effort to carry out by a user\u201d. The annotators saw a list of solutions for the same problem on a web interface and assigned a rank to each solution to create an order. No ties were allowed and a complete ordering was required to keep the annotation simple. The annotators were fluent English speakers and had some knowledge of computer hardware and software. We refrained from including novice users in our study as they are likely to have very different personal preferences resulting in more divergent rankings.\nResults We measured inter-annotator agreement using Kendall\u2019s \u03c4 , a metric of rank correlation which has been reliably used in information ordering evaluations (Lapata, 2006; Bollegala et al., 2006; Madnani et al., 2007). \u03c4 ranges between \u22121 and +1, where +1 indicates equivalent rankings, \u22121 completely reverse rankings, and 0 independent rankings. Table 2 shows the pairwise inter-annotator agreement as well as the agreement between each annotator and the original FAQ order. The table shows fair agreement between the annotators confirming that this is a reasonable task for humans to do. As can be seen, there are some individual differences, with the inter-annotator agreement varying from 0.421 (for A,B) to 0.625 (for A,D).\nThe last column in Table 2 reports the agreement\nbetween our annotator rankings and the original ordering of solutions in the FAQ data. Although there is fair agreement with the FAQ providing support for its use as a gold-standard, the overall \u03c4 values are lower compared to inter-annotator agreement. This implies that the ordering may not be strictly increasing in complexity in our dataset and that our models should allow for some flexibility during learning.\nSeveral reasons contributed to disagreements between annotators and with the FAQ ordering, such as the users\u2019 expertise, personal preferences, or the nature of the solutions. For instance, annotators disagreed when multiple solutions were of similar complexity. For the first example in Table 1, all annotators agreed perfectly and also matched the FAQ order. For the second example, the annotators disagreed with each other and the FAQ."}, {"heading": "4 Generative Models", "text": "In the following we introduce two Bayesian topic models for the complexity prediction (and ranking) task. In these models, complexity is captured through a discrete set D of L levels and a total ordering between the levels reflects their relative complexity. In other words, D = (d1, d2, ...dL), where d1 is easiest level and D(dm) < D(dm+1) . Each complexity level is parametrized by a unigram language model which captures words likely to occur in solutions with that level.\nOur two models are broadly similar. Their generative process assigns a complexity level from D to each solution such that it explains the words in the solution and also the ordering of solutions within each solution set. Words are generated for each solution by mixing problem-specific words with solution-specific (and hence complexityrelated) ones. Also, each problem has its own distribution over complexity levels which allows for some problems to have more complex solutions on average, some a mix of high and low complexity solutions, or otherwise predominantly easier solutions.\nThe main difference between the two models is in the way they capture the ordering between levels. Our first model infers a distribution for each level over the positions at which a solution with that complexity can occur and uses this distribution to order the levels. Levels which on average occur at greater positions have higher complexity. The second model defines probabilities over orderings of levels in the\ngenerative process itself. The inference process of this model allows to directly uncover a canonical ordering of the levels which explains the training data."}, {"heading": "4.1 Expected Position model", "text": "This model infers the vocabulary associated with a complexity level and a distribution over the numerical positions in a solution set where such a complexity level is likely to occur. After inference, the model uses the position distribution to compute the expected position of each complexity level. The levels are ordered from low to high expected position and taken as the order of increasing complexity.\nThe generative process for our model is described in Figure 2. A first phase generates the latent variables which are drawn once for the entire corpus. Then, variables are drawn for a solution set, next for each solution in the set, and finally for the words in the solutions. The number of complexity levels L is a parameter in the model, while the vocabulary\nsize V is fixed. For each complexity level dm, we draw one multinomial distribution \u03c6 over the vocabulary V , and another multinomial \u03b3 over the possible positions. These two distributions are drawn from symmetric Dirichlet priors with hyperparameters \u03b1 and \u03c1. Solutions will not only contain words relating to their complexity but also to the problem or malfunctioning component at hand. We assume these words play a minor role in determining complexity and thus draw a binomial distribution \u03c8 that balances the amount of problem-specific versus complexity-specific vocabulary. This distribution has a Beta prior with hyperparameters \u03b40 and \u03b41.\nFor each solution set, we draw a distribution over the complexity levels \u03b8 from another Dirichlet prior with concentration \u03b2. This distribution allows each problem to take a different preference and mix of complexity levels for its solutions. Another multinomial \u03bb over the vocabulary is drawn for the problemspecific content of each solution set. \u03bb is given a symmetric Dirichlet prior with concentration \u03c9.\nFor each individual solution in a set, we draw a complexity level z from \u03b8, i.e., the complexity level proportions for that problem. A position for the solution is then drawn from the position distribution for that level, i.e., \u03b3z . The words in the solution are generated by first drawing a switch value for each word indicating if the word came from the problem\u2019s technical or complexity vocabulary. Accordingly, the word is drawn from \u03bb or \u03c6z .\nDuring inference, we are interested in the posterior of the model given the FAQ training data. Based on the conditional independencies of the model, the posterior is proportional to:\nP (\u03c8|\u03b40, \u03b41)\u00d7 L\u220f\nm=1 [P (\u03c6m|\u03b1)]\u00d7 L\u220f m=1 [P (\u03b3m|\u03c1)]\n\u00d7 N\u220f i=1 [P (\u03b8i|\u03b2)]\u00d7 N\u220f i=1 [P (\u03bbi|\u03c9)] \u00d7 N\u220f i=1 NPi\u220f j=1 [P (zij |\u03b8i)P (rij |\u03b3zij )] \u00d7 N\u220f i=1 NPi\u220f j=1 |xij |\u220f k=1 [P (sijk|\u03c8)P (wijk|sijk, \u03c6zij , \u03bbi)]\nwhere L is the number of complexity levels, N the number of problems in the training corpus, NPi the size of solution set for problem Pi, and |xij | the number of words in solution xij .\nThe use of conjugate priors for the multinomial\nand binomial distributions allows us to integrate out the \u03c8, \u03c6, \u03b3, \u03bb and \u03b8 distributions. The simplified posterior is proportional to:\nN\u220f i=1\nL\u220f m=1 \u0393(Rmi +\u03b2m)\n\u0393\n( L\u2211\nm=1 Rmi +\u03b2m\n) \u00d7 L\u220f\nm=1\nG\u220f r=1 \u0393(Qrm+\u03c1r)\n\u0393\n( G\u2211\nr=1 Qrm+\u03c1r\n)\n\u00d7 1\u220f u=0 \u0393(Tu+\u03b4u)\n\u0393\n( 1\u2211\nu=0 Tu+\u03b4u\n) \u00d7 L\u220f\nm=1\nV\u220f v=1 \u0393(T 0m(v)+\u03b1v)\n\u0393\n( V\u2211\nv=1 T 0m(v)+\u03b1v\n)\n\u00d7 N\u220f i=1\nV\u220f v=1 \u0393(T 1i (v)+\u03c9v)\n\u0393\n( V\u2211\nv=1 T 1i (v)+\u03c9v\n)\nwhere Rmi is the number of times level m is assigned to a solution in problem i. Qrm is the number of times a solution with position r is given complexity m over the full corpus. Positions are integer values between 1 and G. T 0 and T 1 count the number of switch assignments of value 0 (complexityrelated word) and 1 (technical word) respectively in the corpus. T 0m(v) is a refined count of the number of times word type v is assigned switch value 0 in a solution of complexity m. T 1i (v) counts the number of times switch value 1 is given to word type v in a solution set for problem i.\nWe sample from this posterior using a collapsed Gibbs sampling algorithm. The sampling sequence starts with a random initialization to the hidden variables. During each iteration, the sampler chooses a complexity level for each solution based on the current assignments to all other variables. Then the switch values for the words in each solution are sampled one by one. The hyperparameters are tuned using grid search on development data. The language model concentrations \u03b1, \u03c1 and \u03c9 are given values less than 1 to obtain sparse distributions. The prior on \u03b8, the topic proportions, is chosen to be greater than 1 to encourage different complexity levels to be used within the same problem rather than assigning all solutions to the same one or two levels. Similarly, \u03b40 and \u03b41 are > 1. We run 5,000 sampling iterations and use the last sample as a draw from the posterior. Using these assignments, we also compute an estimate for the parameters \u03c6m, \u03bbi and \u03b3m. For example, the probability of a word v in \u03c6m is computed as T 0 m(v)+\u03b1v\u2211\nv(T 0 m(v)+\u03b1v) . After inference, we obtain probability distribu-\ntions for each complexity level dm over the vocabulary \u03c6m and positions \u03b3m. We compute the expected position Ep of dm as:\nEp(dm) = G\u2211\npos=1\npos \u2217 \u03b3m(pos) (1)\nwhere pos indicates position values. Then, we rank the levels in increasing order of Ep."}, {"heading": "4.2 Permutations-based model", "text": "In our second model we incorporate the ordering of complexity levels in the generative process itself. This is achieved by using the Generalized Mallows Model (GMM; Fligner and Verducci (1986)) within our hierarchical generative process. The GMM is a probabilistic model over permutations of items and is frequently used to learn a consensus ordering given a set of different rankings. It assumes there is an underlying canonical order of items and concentrates probability mass on those permutations that differ from the canonical order by a small amount, while assigning lesser probability to very divergent permutations. Probabilistic inference in this model uncovers the canonical ordering.\nThe standard Mallows model (Mallows, 1957) has two parameters, a canonical ordering \u03c3 and a dispersion penalty \u03c1 > 0. The probability of an observed ordering \u03c0 is defined as:\nP (\u03c0|\u03c1,\u03c3) = e \u2212\u03c1d(\u03c0,\u03c3)\n\u03be(\u03c1) ,\nwhere d(\u03c0,\u03c3) is a distance measure such as Kendall\u2019s \u03c4 , between the canonical ordering \u03c3 and an observed ordering \u03c0. The GMM decomposes d(\u03c0,\u03c3) in a way that captures item-specific distance. This is done by computing an inversion vector representation of d(\u03c0,\u03c3). A permutation \u03c0 of n items can be equivalently represented by a vector of inversion counts v of length n\u22121, where each component vi equals the number of items j > i that occur before item i in \u03c0. The dimension of v is n\u2212 1 since there can be no items greater than the highest value element. A unique inversion vector can be computed for any permutation and vice versa, and the sum of the inversion vector elements is equal to d(\u03c0,\u03c3). Each vi is also given a separate dispersion penalty \u03c1i. Then, the GMM is defined as:\nGMM(v|\u03c1) \u221d \u220f\ni\ne\u2212\u03c1ivi (2)\nAnd can be further factorized into item-specific components:\nGMMi(vi|\u03c1i) \u221d e\u2212\u03c1ivi (3)\nSince the GMM is a member of the exponential family, a conjugate prior can be defined for each dispersion parameter \u03c1i which allows for efficient inference. We refer the interested reader to Chen et al. (2009a) for details on the prior distribution and normalization factor for the GMM distribution.\nFigure 3 formalizes the generative story of our own model which uses the GMM as a component. We assume the canonical order is the strictly increasing (1, 2, .., L) order. For each complexity level dm, we draw a distribution \u03c6 over the vocabulary. We also drawL\u2212 1 dispersion parameters from the conjugate prior GMM0 density. Hyperparameters for this prior are set in a similar fashion to Chen et al. (2009a). As in the position model, we draw\na binomial distribution, \u03c8 (with a beta prior) over complexity- versus problem-specific vocabulary. At the solution set level, we draw a multinomial distribution \u03bb over the vocabulary and a multinomial distribution \u03b8 for the proportion of L levels for this problem. Both these distributions have Dirichlet priors. Next, we generate an ordering for the complexity levels. We draw NPi complexity levels from \u03b8, one for each solution in the set. Let b denote this bag of levels (e.g., b = (1, 1, 2, 3, 4, 4, 4) assuming 4 complexity levels and 7 solutions for a particular problem). We also draw an inversion vector v from the GMM distribution which advantageously allows for small differences from the canonical order. The z assignments are deterministically computed by ordering the elements of b according to the permutation defined by v.\nGiven the conditional independencies of our model, the posterior is proportional to:\nL\u220f m=1 [P (\u03c6m|\u03b1)]\u00d7 L\u22121\u220f r=1 [P (\u03c1r|\u00b50, v0r)]\u00d7 P (\u03c8|\u03b40, \u03b41) \u00d7 N\u220f i=1 [P (\u03b8i|\u03b2)\u00d7 P (\u03bbi|\u03c9)\u00d7 P (vi|\u03c1)\u00d7 P (bi|\u03b8i)] \u00d7 N\u220f i=1 NPi\u220f j=1 |xij |\u220f k=1 [P (sijk|\u03c8)P (wijk|sijk, \u03c6zij , \u03bbi)]\nwhere L is the number of complexity levels, N the total problems in the training corpus, NPi the size of solution set for problem Pi, and |xij | the number of words in solution xij . A simplified posterior can be obtained by integrating out the \u03c8, \u03c6, \u03bb, and \u03b8 distributions which is proportional to:\nN\u220f i=1\nL\u220f m=1 \u0393(Rmi +\u03b2m)\n\u0393\n( L\u2211\nm=1 Rmi +\u03b2m\n) \u00d7 L\u22121\u220f r=1 GMM0(\u03c1r|\u00b50, v0r)\n\u00d7 N\u220f i=1 L\u22121\u220f r=1\nGMMr(vir|\u03c1r)\u00d7 1\u220f u=0 \u0393(Tu+\u03b4u)\n\u0393\n( 1\u2211\nu=0 Tu+\u03b4u\n)\n\u00d7 L\u220f\nm=1\nV\u220f v=1 \u0393(T 0m(v)+\u03b1v)\n\u0393\n( V\u2211\nv=1 T 0m(v)+\u03b1v\n) \u00d7 N\u220f i=1\nV\u220f v=1 \u0393(T 1i (v)+\u03c9v)\n\u0393\n( V\u2211\nv=1 T 1i (v)+\u03c9v\n)\nwhere theR and T counts are defined similarly as in the Expected Position model.\nWe use collapsed Gibbs sampling to compute samples from this posterior. The sampling sequence\nrandomly initializes the hidden variables. For a chosen solution set Si, the sampler draws NPi levels (bi), one at a time conditioned on the assignments to all other hidden variables of the model. Then the inversion vector vi is created by sampling each vij in turn. At this point, the complexity level assignments zi can be done deterministically given bi and vi. Then the words in each solution set are sampled one at a time. For the dispersion parameters, \u03c1, the normalization constant of the conjugate prior is not known. We sample from the unnormalized GMM0 distribution using slice sampling.\nOther hyperparameters of the model are tuned using development data. The language model Dirichlet concentrations (\u03b1, \u03c9) are chosen to encourage sparsity and \u03b2 > 1 as in the position model. We run the Gibbs sampler for 5,000 iterations; the dispersion parameters are resampled every 10 iterations. The last sample is used as a draw from the posterior."}, {"heading": "4.3 Model Output", "text": "In this section we present examples of the complexity assignments created by our models. Table 3 shows the output of the permutations-based model with 20 levels. Each row contains the highest probability words in a single level (from the distribution \u03c6m). For the sake of brevity, we only show the two least and most complex levels. In general, we observe more specialized, technical terms in higher levels (e.g., restore, scanreg, registry) which one would expect to correlate with complex solutions. Also note that higher levels contain uncertainty denoting words (e.g., can, find, may) which again are indicative of increasing complexity.\nUsing these complexity vocabularies, our models\ncan compute the expected complexity for any solution text, x. This value is given by [ \u2211L m=1m \u2217 p(m|x)]. We estimate the second term, p(m|x), using a) the complexity level language models \u03c6m and b) a prior over levels given by the overall frequency of different levels on the training data. Table 4 presents examples of solution texts from our training data and their expected complexity under the position-model. We find that the model is able to distinguish intuitively complex solutions from simpler ones. Aside from measuring expected complexity in absolute terms, our models can also also order solutions in terms of relative complexity (see the evaluation in Section 5) and assign a complexity value to a problem as a whole.\nAs mentioned earlier, our models only observe the relative ordering of solutions to individual problems; the relative complexity of two solutions from different problems is not known. Nevertheless, the models are able to rate solutions on a global scale while accommodating problem-specific ordering sequences. Specifically, we can compute the expected complexity of the solution set for problem i, using the inferred distribution over levels \u03b8i: \u2211L m=1m \u00d7 \u03b8im. Table 5 shows the complexity of different problems as predicted by the position model (with 10 levels). As can be seen, easy problems are associated with accessory components (e.g., mouse or keyboard), whereas complex problems are related to core hardware and operating system errors."}, {"heading": "5 Evaluation Experiments", "text": "In the previous section, we showed how our models can assign an expected complexity value to a solution text or an entire problem. Now, we present evaluations based on model ability to order solutions according to relative complexity."}, {"heading": "5.1 Solution Ordering Task", "text": "We evaluated our models by presenting them with a randomly permuted set of solutions to a problem and examining the accuracy with which they reorder them from least to most complex. At first instance, it would be relatively straightforward to search for the sequence of solutions which has high likelihood under the models. Unfortunately, there are two problems with this approach. Firstly, the likelihood under our models is intractable to compute, so we\nwould need to adopt a simpler and less precise approximation (such as the Hidden Markov Model discussed below). Secondly, when the solution set size is large, we cannot enumerate all permutations and need to adopt an approximate search procedure.\nWe opted for a discriminative ranking approach instead which uses the generative models to compute a rich set of features. This choice allows us to simultaneously obtain features tapping on to different aspects learned by the models and to use well-defined objective functions. Below, we briefly describe the features based on our generative models. We also present additional features used to create baselines for system comparison.\nLikelihood We created a Hidden Markov Model based on the sample from the posterior of our models (for a similar HMM approximation of a Bayesian model see Elsner et al. (2007)). For our model, the HMM has L states, and each state sm corresponds to a complexity level dm. We used the complexity language models \u03c6m estimated from the posterior as the emission probability distribution for the corresponding states. The transition probabilities of the HMM were computed based on the complexity level assignments for the training solution sequences in our posterior sample. The probability of transitioning to state sj from state si, p(sj |si), is the conditional probability p(dj |di) computed as c(di,dj)c(di) , where c(di, dj) is the number of times the complexity level dj is assigned to a solution immediately following a solution which was given complexity di. c(di) is the number of times complexity level di is assigned overall in the training corpus. We perform Laplace smoothing to avoid zero probability transitions between states:\np(sj |si) = c(di, dj) + 1\nc(di) + L (4)\nThis HMM formulation allows us to use efficient dynamic programming to compute the likelihood of a sequence of solutions.\nGiven a solution set, we compute an ordering as follows. We enumerate all orderings for sets with size less than 6, and select the sequence with the highest likelihood. For larger sizes, we use a simulated annealing search procedure which swaps two adjacent solutions in each step. The temperature was set to 50 initially and gradually reduced to 1. These\nvalues were set using minimal tuning on the development data. After estimating the most likely sequence for a solution set, we used the predicted rank of each solution as a feature in our discriminative model.\nExpected Complexity As mentioned earlier, we computed the expected complexity of a solution x as [ \u2211L m=1m \u2217 p(m|x)], where the second term was estimated using a complexity level specific language model \u03c6m and a uniform prior over levels on the test set. As additional features, we used the solution\u2019s perplexity under each \u03c6m, and under each of the technical topics \u03bbi, and also the most likely level for the text argmaxm p(m|x). Finally, we included features for each word in the training data. The feature value is the word\u2019s expected level multiplied by the probability of the word in the solution text.\nLength We also investigated whether solution length is a predictor of complexity (e.g., simple solutions may vary in length and amount of detail from complex ones). We devised three features based on the number of sentences (within a solution), words, and average sentence length.\nSyntax/Semantics Another related class of features estimates solution complexity based on sentence structure and meaning. We obtained eight syntactic features based on the number of nouns, verbs, adjectives and adverbs, prepositions, pronouns, wh-adverbs, modals, and punctuation. Other features compute the average and maximum depth of constituent parse trees. The part-of-speech tags and parse trees were obtained using the Stanford CoreNLP toolkit (Manning et al., 2014). In addition, we computed 10 semantic features using WordNet (Miller, 1995). They are the average number of senses for each category (noun, verb, adjective/adverb), and the maximum number of senses for the same three classes. We also include the average and maximum lengths of the path to the root of the hypernym tree for nouns and verbs. This class of features roughly approximates the indicators typically used in predicting text readability (Schwarm and Ostendorf, 2005; McNamara et al., 2014)."}, {"heading": "5.2 Experimental Setup", "text": "We performed 10-fold cross-validation. We trained the ranking model on 240 problem-solution sets; 30 sets were reserved for development and 30 for\ntesting (in each fold). The most frequent 20 words in each training set were filtered as stopwords. The development data was used to tune the parameters and hyperparameters of the models and the number of complexity levels. We experimented with ranges [5\u2013 20] and found that the best number of levels was 10 for the position model and 20 for the permutationbased model, respectively. For the expected position model, positions were normalized before training. Let solution xir denote the rth solution in the solution set for problem Pi, where 1 \u2264 r \u2264 NPi . We normalize r to a value between 0 and 1 using a min-max method: r\u2032 = r\u22121NPi\u22121\n. Then the [0\u20131] range is divided into k bins. The identity of the bin containing r\u2032 is taken as the normalized position, r. We tuned k experimentally during development and found that k = 3 performed best.\nFor our ordering experiments we used Joachims\u2019 (2006) SVMRank package for training and testing. During training, the classifier learns to minimize the number of swapped pairs of solutions over the training data. We used a linear kernel and the regularization parameter was tuned using grid search on the development data of each fold. We evaluate how well the model\u2019s output agrees with gold-standard ordering using Kendall\u2019s \u03c4 ."}, {"heading": "5.3 Results", "text": "Table 6 summarizes our results (average Kendall\u2019s \u03c4 across folds). We present the results of the discriminative ranker when using a single feature class based on likelihood and expected complexity (Position, Permutation), length, and syntactico-semantic features (SynSem), and their combinations (denoted via +). We also report the performance of a baseline which computes a random permutation for each solution set (Random; results are averaged over five runs). We show results for all solution sets (All) and broken down into different set sizes (e.g., 2\u20133, 4\u20135).\nAs can be seen, the expected position model obtains an overall \u03c4 of 0.30 and the permutation model of 0.26. These values lie in the range of human annotator agreement with the FAQ order (see Section 3.2). In addition, we find that the models perform consistently across solution set sizes, with even higher correlations on longer sequences where our methods are likely to be more useful. Position and Permutation outperform Random rankings and a model based solely on Length features. The\nSynSem features which measure the complexity of writing in the text are somewhat better but still inferior compared to Position and Permutation. Using a paired Wilcoxon signed-rank test, we compared the \u03c4 values obtained by the different models. The Position and Permutation performed significantly better (p < 0.05) compared to Random, Length and SynSem baselines. However, \u03c4 differences between Position and Permutation are not statistically significant. With regard to feature combinations, we observe that both models yield better performance when combined with Length or SynSem. The Position model improves with the addition of both Length and SynSem, whereas the Permutation model combines best with SynSem features. The Position+SynSem+Length model is significantly better than Permutation (p < 0.05) but not Permutation+SynSem+Length or Position alone (again under the Wilcoxon test).\nThese results suggest that the solution ordering task is challenging with several factors influencing how a solution is perceived: the words used and their meaning, the writing style of the solution, and the amount of detail present in it. Our data comes from the FAQs produced by computer and operating system manufacturers and other well-managed websites. As a result, the text in the FAQ solutions is of high quality. However, the same is not true\nfor community-generated solution texts on discussion forums. In the latter case, we conjecture that the style of writing is likely to play a bigger role in how users perceive complexity. We thus expect that the benefit of adding Length and SynSem features will become stronger when we apply our models to texts from online forums.\nWe also computed how accurately the models identify the least and most complex solutions. For solution sets of size 5 and above (so that the task is non-trivial) we computed the number of times the rank one solution given by the models was also the easiest according to the FAQ gold-standard. Likewise, we also computed how often the models correctly predict the most complex solution. With Random rankings, the easiest and most difficult solutions are predicted correctly 15% of the time. Getting both correct for a single problem happens only 3% of the time. The Position+Length model overall performs best, identifying the easiest and most difficult solution 36% of the time. Both types of solution are identified correctly 18% of the time. Interestingly, the generative models are better at predicting the most difficult solution (35\u201337%) compared to the easiest one (28\u201336%). One reason for this could be that there are multiple easy solutions to try out but the most difficult one is probably more unique and so easier to identify.\nOverall, we observe that the two generative models perform comparably, with Position having a slight lead over Permutation. A key difference be-\ntween the models is that during training Permutation observes the full ordering of solutions while Position observes solutions coming from a few normalized position bins. Also note that in the Permutation model, multiple solutions with the same complexity level are grouped together in a solution set. This property of the model is advantageous for ordering as solutions with similar complexity should be placed adjacent to each other. At the same time, if levels 1 and 2 are flipped in the permutation sampled from the GMM, then any solution with complexity level 1 will be ordered after the solution with complexity 2. The Position model on the other hand, contains no special facility for grouping solutions with the same complexity. In sum, Position can more flexibly assign complexity levels to individual solutions."}, {"heading": "6 Conclusion", "text": "This work contains a first proposal to organize and navigate crowd-generated troubleshooting data according to the complexity of the troubleshooting action. We showed that users perceive and agree on the complexity of alternative suggestions, and presented Bayesian generative models of the troubleshooting data which can sort solutions by complexity with a performance close to human agreement on the task.\nOur results suggest that search and summarization tools for troubleshooting forum archives can be greatly improved by automatically predicting and using the complexity of the posted solutions. It should also be possible to build broad coverage automated troubleshooting systems by bootstrapping from conversations in discussion forums. In the future, we plan to deploy our models in several tasks such as user authority prediction, expert intervention, and thread analysis. Furthermore, we aim to specialize our models to include category-specific complexity levels and also explore options for personalizing rankings for individual users based on their knowledge of a topic and the history of their troubleshooting actions."}, {"heading": "Acknowledgements", "text": "We would like to thank the editor and the anonymous reviewers for their valuable feedback on an earlier draft of this paper. We are also thankful to members of the Probabilistic Models of Language reading group at the University of Edinburgh for\ntheir many suggestions and helpful discussions. The first author was supported by a Newton International Fellowship (NF120479) from the Royal Society and the British Academy."}], "year": 2015, "references": [{"title": "Modeling local coherence: An entity-based approach", "authors": ["R. Barzilay", "M. Lapata."], "venue": "Computational Linguistics, 34(1):1\u201334.", "year": 2008}, {"title": "Catching the drift: Probabilistic content models, with applications to generation and summarization", "authors": ["R. Barzilay", "L. Lee."], "venue": "Proceedings of NAACL-HLT, pages 113\u2013120.", "year": 2004}, {"title": "A bottom-up approach to sentence ordering for multi-document summarization", "authors": ["D. Bollegala", "N. Okazaki", "M. Ishizuka."], "venue": "Proceedings of COLING-ACL, pages 385\u2013392.", "year": 2006}, {"title": "Reinforcement learning for mapping instructions to actions", "authors": ["S.R.K. Branavan", "H. Chen", "L.S. Zettlemoyer", "R. Barzilay."], "venue": "Proceedings of ACLIJCNLP, pages 82\u201390.", "year": 2009}, {"title": "Learning to win by reading manuals in a Monte-Carlo framework", "authors": ["S.R.K. Branavan", "D. Silver", "R. Barzilay."], "venue": "Proceedings of ACL-HLT, pages 268\u2013 277.", "year": 2011}, {"title": "Content modeling using latent permutations", "authors": ["H. Chen", "S.R.K. Branavan", "R. Barzilay", "D.R. Karger."], "venue": "Journal of Artificial Intelligence Research, 36(1):129\u2013163.", "year": 2009}, {"title": "Global models of document structure using latent permutations", "authors": ["H. Chen", "S.R.K. Branavan", "R. Barzilay", "D.R. Karger."], "venue": "Proceedings of NAACL-HLT, pages 371\u2013379.", "year": 2009}, {"title": "Reading to learn: Constructing features from semantic abstracts", "authors": ["J. Eisenstein", "J. Clarke", "D. Goldwasser", "D. Roth."], "venue": "Proceedings of EMNLP, pages 958\u2013967.", "year": 2009}, {"title": "A unified local and global model for discourse coherence", "authors": ["M. Elsner", "J. Austerweil", "E. Charniak."], "venue": "Proceedings of NAACL-HLT, pages 436\u2013443.", "year": 2007}, {"title": "Distance-based ranking models", "authors": ["M.A. Fligner", "J.S. Verducci."], "venue": "Journal of the Royal Statistical Society, Series B, pages 359\u2013369.", "year": 1986}, {"title": "Decision-theoretic troubleshooting", "authors": ["D. Heckerman", "J.S. Breese", "K. Rommelse."], "venue": "Communications of the ACM, 38(3):49\u201357.", "year": 1995}, {"title": "Training linear SVMs in linear time", "authors": ["T. Joachims."], "venue": "Proceedings of KDD, pages 217\u2013226.", "year": 2006}, {"title": "Classifying dialogue acts in one-on-one live chats", "authors": ["S. Kim", "L. Cavedon", "T. Baldwin."], "venue": "Proceedings of EMNLP, pages 862\u2013871.", "year": 2010}, {"title": "Probabilistic text structuring: Experiments with sentence ordering", "authors": ["M. Lapata."], "venue": "Proceedings of ACL, pages 545\u2013552.", "year": 2003}, {"title": "Automatic evaluation of information ordering", "authors": ["M. Lapata."], "venue": "Computational Linguistics, 32(4):471\u2013484.", "year": 2006}, {"title": "Classifying user forum participants: Separating the gurus from the hacks, and other tales of the internet", "authors": ["M. Lui", "T. Baldwin."], "venue": "Proceedings of the 2010 Australasian Language Technology Workshop, pages 49\u201357.", "year": 2009}, {"title": "Measuring variability in sentence ordering for news summarization", "authors": ["N. Madnani", "R. Passonneau", "N. Ayan", "J. Conroy", "B. Dorr", "J. Klavans", "D. O\u2019Leary", "J. Schlesinger"], "venue": "In Proceedings of the Eleventh European Workshop on Natural Language Generation", "year": 2007}, {"title": "Non-null ranking models", "authors": ["C.L. Mallows."], "venue": "i. Biometrika, 44(1/2):pp. 114\u2013130.", "year": 1957}, {"title": "The Stanford CoreNLP natural language processing toolkit", "authors": ["C.D. Manning", "M. Surdeanu", "J. Bauer", "J. Finkel", "S.J. Bethard", "D. McClosky."], "venue": "Proceedings of ACL: System Demonstrations, pages 55\u2013", "year": 2014}, {"title": "Automated evaluation of text and discourse with Coh-Metrix", "authors": ["D.S. McNamara", "A.C. Graesser", "P.M. McCarthy", "Z. Cai."], "venue": "Cambridge University Press.", "year": 2014}, {"title": "WordNet: a lexical database for English", "authors": ["G.A. Miller."], "venue": "Communication of the ACM, 38(11):39\u201341.", "year": 1995}, {"title": "Reading level assessment using support vector machines and statistical language models", "authors": ["S. Schwarm", "M. Ostendorf."], "venue": "Proceedings of ACL, pages 523\u2013 530.", "year": 2005}, {"title": "Learning to follow navigational directions", "authors": ["A. Vogel", "D. Jurafsky."], "venue": "Proceedings of ACL, pages 806\u2013814.", "year": 2010}, {"title": "Predicting thread discourse structure over technical web forums", "authors": ["L. Wang", "M. Lui", "S. Kim", "J. Nivre", "T. Baldwin."], "venue": "Proceedings of EMNLP, pages 13\u201325.", "year": 2011}], "id": "SP:33cfb9e19764ddb606f9cf81c1aa25c4518f5f01", "authors": [{"name": "Annie Louis", "affiliations": []}], "abstractText": "Online discussion forums and community question-answering websites provide one of the primary avenues for online users to share information. In this paper, we propose text mining techniques which aid users navigate troubleshooting-oriented data such as questions asked on forums and their suggested solutions. We introduce Bayesian generative models of the troubleshooting data and apply them to two interrelated tasks: (a) predicting the complexity of the solutions (e.g., plugging a keyboard in the computer is easier compared to installing a special driver) and (b) presenting them in a ranked order from least to most complex. Experimental results show that our models are on par with human performance on these tasks, while outperforming baselines based on solution length or readability.", "title": "Which Step Do I Take First? Troubleshooting with Bayesian Models"}