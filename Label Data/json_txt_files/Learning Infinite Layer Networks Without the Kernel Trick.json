{"sections": [{"heading": "1. Introduction", "text": "With the increasing success of highly non-convex and complex learning architectures such as neural networks, there is an increasing effort to further understand and explain the limits of training such hierarchical structures.\nRecently there have been attempts to draw mathematical insight from kernel methods in order to better understand deep learning, as well as come up with new computationally learnable architectures. One such line of work consists of learning classifiers that are linear functions of a very large or infinite collection of non-linear functions (Bach,\n1University of Princeton, Princeton, New Jersey, USA 2Tel-Aviv University, Tel-Aviv, Israel. Correspondence to: Roi Livni <rlivni@cs.princeton.edu>, Daniel Carmon <carmonda@mail.tau.ac.il>, Amir Globerson <gamir@mail.tau.ac.il>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\n2014; Daniely et al., 2016; Cho & Saul, 2009; Heinemann et al., 2016; Williams, 1997). Such models can be interpreted as a neural network with infinitely many nodes in a hidden layer, and we thus refer to them as \u201cInfinite Layer Networks\u201d (ILN). They are of course also related to kernel based classifiers, as will be discussed later.\nA target function in an ILN class will be of the form: x\u2192 \u222b \u03c8(x;w)f(w)d\u00b5(w), (1)\nHere \u03c8 is some function of the input x and parameters w, and d\u00b5(w) is a prior over the parameter space. For example, \u03c8(x;w) can be a single sigmoidal neuron or a complete convolutional network. The integral can be thought of as an infinite sum over all such possible networks, and f(w) can be thought of as an infinite output weight vector to be trained.\nA Standard 1\u2013hidden layer network with a finite set of units can be obtained from the above formalism as follows. First, choose \u03c8(x;w) = \u03c3(x \u00b7w) where \u03c3 is an activation function (e.g., sigmoid or relu). Next, set d\u00b5(w) to be a discrete measure over a finite set w1, . . . ,wd.1 In this case, the integral results in a network with d hidden units, and the function f is the linear weights of the output layer. Namely:\nx\u2192 1 d d\u2211 i=1 f(wi) \u00b7 \u03c3(x \u00b7wi).\nThe main challenge when training 1\u2013hidden layer networks is of course to find the w1, . . . ,wd on which we wish to support our distribution. It is known (Livni et al., 2014), that due to hardness of learning intersection of halfspaces (Klivans & Sherstov, 2006; Daniely et al., 2014), 1\u2013hidden layer neural networks are computationally hard for a wide class of activation functions. Therefore, as the last example illustrates, the choice of \u00b5 is indeed crucial for performance.\nFor a fixed prior \u00b5, the class of ILN functions is highly expressive, since f can be chosen to approximate any 1- hidden layer architecture to arbitrary precision (by setting f to delta functions around the weights of the network, as\n1In \u03b4 function notation d\u00b5(w) = 1 d \u2211d i=1 \u03b4(w \u2212wi)dw\nwe did above for \u00b5). However, this expressiveness comes at a cost. As argued in Heinemann et al. (2016), ILN will generalize well when there is a large probability mass of w parameters that attain a small loss.\nThe key observation that makes certain ILN tractable to learn is that Eq. 1 is a linear functional in f . In that sense it is a linear classifier and enjoys the rich theory and algorithmic toolbox for such classifiers. In particular, one can use the fact that linear classifiers can be learned via the kernel trick in a batch (Cortes & Vapnik, 1995) as well as online settings (Kivinen et al., 2004). In other words, we can reduce learning ILN to the problem of computing the kernel function between two examples. Specifically the problem reduces to computing integrals of the following form:\nk(x1,x2) = \u222b \u03c8(x1;w) \u00b7 \u03c8(x2;w)d\u00b5(w) (2)\n= E w\u0304\u223c\u00b5 [\u03c8(x1; w\u0304) \u00b7 \u03c8(x2; w\u0304)] . (3)\nIn this work we extend this result to the case where no closed form kernel is available, and thus the kernel trick is not directly applicable. We thus turn our attention to the setting where features (i.e., w vectors) can be randomly sampled. In this setting, our main result shows that for the squared loss, we can efficiently learn the above class. Moreover, we can surprisingly do this with a computational cost comparable to that of methods that have access to the closed form kernel k(x1,x2).\nThe observation we begin with is that sampling random features (i.e., w above), leads to an unbiased estimate of the kernel in Eq. 2. Thus, if for example, we ignore complexity issues and can sample infinitely many w\u2019s, it is not surprising that we can avoid the need for exact computation of the kernel. However, our results provide a much stronger and practical result. Given T training samples, the lower bound on achievable accuracy is O(1/ \u221a T ) (see Shamir, 2015). We show that we can in fact achieve this rate, using O\u0303(T 2) calls2 to the random feature generator. For comparison, note that O(T 2) is the size of the kernel matrix, and is thus likely to be the cost of any algorithm that uses an explicit kernel matrix, where one is available. As we discuss later, our approach improves on previous random features based learning (Dai et al., 2014; Rahimi & Recht, 2009) in terms of sample/computational complexity, and expressiveness."}, {"heading": "2. Problem Setup", "text": "We consider algorithms that learn a mapping from input instances x \u2208 X to labels y \u2208 Y . We focus on the regression case where Y is the interval [\u22121, 1]. Our starting point is a class of feature functions \u03c8(w;x) : \u2126\u00d7X \u2192 R,\n2We use O\u0303 notation to suppress logarithmic factors\nparametrized by vectors w \u2208 \u2126. The functions \u03c8(w;x) may contain highly complex non linearities, such as multilayer networks consisting of convolution and pooling layers. Our only assumption on \u03c8(w;x) is that for all w \u2208 \u2126 and x \u2208 X it holds that |\u03c8(w;x)| < 1.\nGiven a distribution \u00b5 on \u2126, we denote by L2(\u2126, \u00b5) the class of square integrable functions over \u2126.\nL2(\u2126, \u00b5) =\n{ f : \u222b f2(w)d\u00b5(w) <\u221e } .\nWe will use functions f \u2208 L2(\u2126, \u00b5) as mixture weights over the class \u2126, where each f naturally defines a new regression function from x to R as follows:\nx\u2192 \u222b \u03c8(w;x)f(w)d\u00b5(w). (4)\nOur key algorithmic assumption is that the learner can efficiently sample random w according to the distribution \u00b5. Denote the time to generate one such sample by \u03c1.\nIn what follows it will be simpler to express the integrals as scalar products. Define the following scalar product on functions f \u2208 L2(\u2126, \u00b5).\n\u3008f, g\u3009 = \u222b f(w)g(w)d\u00b5(w) (5)\nWe denote the corresponding `2 norm by \u2016f\u2016 = \u221a \u3008f, f\u3009. Also, given features x denote by \u03a6(x) the function in L2(\u2126, \u00b5) given by \u03a6(x)[w] = \u03c8(w;x). The regression functions we are considering are then of the form x\u2192 \u3008f,\u03a6(x)\u3009.\nA subclass of norm bounded elements in L2(\u2126, \u00b5) induces a natural subclass of regression functions. Namely, we consider the following class:\nHB\u00b5 = {x\u2192 \u3008f,\u03a6(x)\u3009 : \u2016f\u2016 < B} .\nOur ultimate goal is to output a predictor f \u2208 L2(\u2126, \u00b5) that is competitive, in terms of prediction, with the best target function in the classHB\u00b5 .\nWe will consider an online setting, and use it to derive generalization bounds via standard online to batch conversion. In our setting, at each round a learner chooses a target function ft \u2208 L2(\u2126, \u00b5) and an adversary then reveals a sample xt and label yt. The learner then incurs a loss of\n`t(ft) = 1\n2 (\u3008ft,\u03a6(xt)\u3009 \u2212 yt)2 . (6)\nThe use of squared loss might seem restrictive if one is interested in classification. However, L2 loss is common by now in classification with support vector machines and kernel methods since (Suykens & Vandewalle, 1999; Suykens\net al., 2002). More recently Zhang et al. (2016) showed that when using a large number of features regression achieves performance comparable to the corresponding linear classifiers (see Section 5 therein).\nThe objective of the learner is to minimize her T round regret w.r.t norm bounded elements in L2(\u2126, \u00b5). Namely:\nT\u2211 t=1 `t(ft)\u2212 min f\u2217\u2208HB\u00b5 T\u2211 t=1 `t(f \u2217). (7)\nIn the statistical setting we assume that the sequence S = {(xi, yi)}Ti=1 is generated IID according to some unknown distribution P. We then define the expected loss of a predictor as\nL(f) = E (x,y)\u223cP\n[ 1\n2 (\u3008f,\u03a6(x)\u3009 \u2212 y)2\n] . (8)"}, {"heading": "3. Main Results", "text": "Theorem 1 states our result for the online model. The corresponding result for the statistical setting is given in Corollary 1. We will elaborate on the structure of the Algorithm later, but first provide the main result.\nAlgorithm 1: The SHRINKING GRADIENT algorithm.\nData: T, B > 1, \u03b7,m Result: Weights \u03b1(1), . . . , \u03b1(T+1) \u2208 RT . Functions\nft \u2208 L2(\u2126, \u00b5) defined as ft = \u2211t i=1 \u03b1 (t) i \u03a6(xi);\nInitialize \u03b1(1) = 0\u0304 \u2208 RT ; for t = 1, . . . , T do\nObserve xt, yt; Set Et = EST SCALAR PROD(\u03b1(t),x1:t\u22121,xt,m); if |Et| < 16B then\n\u03b1(t+1) = \u03b1(t); \u03b1\n(t+1) t = \u2212\u03b7(yt \u2212 Et);\nelse \u03b1(t+1) = 14\u03b1 (t);\nTheorem 1. Run Algorithm 1 with parameters T , B \u2265 1, \u03b7 = B\u221a\nT and m = O\n( B4T log (BT ) ) . Then:\n1. For every sequence of squared losses `1, . . . , `T observed by the algorithm we have for f1, . . . , fT :\nE [ T\u2211 t=1 `t(ft)\u2212 min f\u2217\u2208HB\u00b5 T\u2211 t=1 `t(f \u2217) ] = O(B \u221a T )\nAlgorithm 2: EST SCALAR PROD Data: \u03b1, x1:t\u22121, x, m Result: Estimated scalar product E if \u03b1 = 0\u0304 then\nSet E = 0 else\nfor k=1.. . . ,m do Sample i from the distribution q(i) = |\u03b1i|\u2211 |\u03b1i| ; Sample parameter w\u0304 from \u00b5. Set E(k) = sgn(\u03b1i)\u03c8(xi; w\u0304)\u03c8(x; w\u0304);\nSet E = \u2016\u03b1\u20161m \u2211m k=1E (k)\n2. The run-time of the algorithm is O\u0303 ( \u03c1B4T 2 ) .3\n3. For each t = 1 . . . T and a new test example x, we can with probability \u2265 1 \u2212 \u03b4 estimate \u3008ft,\u03a6(x)\u3009 within accuracy 0 by running Algorithm 2 with parameters \u03b1(t), {xi}ti=1, ,x and m = O(B\n4T 20\nlog 1/\u03b4). The resulting running time for a test point is then O(\u03c1m).\nWe next turn to the statistical setting, where we provide bounds on the expected performance. Following standard online to batch conversion and Theorem 1 we can obtain the following Corollary (e.g., see Shalev-Shwartz, 2011):\nCorollary 1 (Statistical Setting). The following holds for any > 0. Run Algorithm 1 as in Theorem 1, with T = O(B 2\n2 ). Let S = {(xt, yt)} T t=1, be an IID sample drawn from some unknown distribution P. Let fS = 1T \u2211 ft. Then the expected loss satisfies:\nE S\u223cP [L(fS)] < inf f\u2217\u2208HB\u00b5\nL(f\u2217) + .\nThe runtime of the algorithm, as well as estimation time on a test example are as defined in Theorem 1.\nProofs of the results are provided in Section 5.1 and the appendix."}, {"heading": "4. Related Work", "text": "Learning with random features can be traced to the early days of learning (Minsky & Papert, 1988), and infinite networks have also been introduced more than 20 years ago (Williams, 1997; Hornik, 1993). More recent works have considered learning neural nets (also multi-layer) with infinite hidden units using the kernel trick (Cho & Saul, 2009; Deng et al., 2012; Hazan & Jaakkola, 2015; Heinemann et al., 2016). These works take a similar approach\n3Ignoring logarithmic factors in B and T .\nto ours but focus on computing the kernel for certain feature classes in order to invoke the kernel trick. Our work in contrast avoids using the kernel trick and applies to any feature class that can be randomly generated. All the above works are part of a broader effort of trying to circumvent hardness in deep learning by mimicking deep nets through kernels (Mairal et al., 2014; Bouvrie et al., 2009; Bo et al., 2011; 2010), and developing general duality between neural networks and kernels (Daniely et al., 2016).\nFrom a different perspective the relation between random features and kernels has been noted by Rahimi & Recht (2007) who show how to represent translation invariant kernels in terms of random features. This idea has been further studied (Bach, 2015; Kar & Karnick, 2012) for other kernels as well. The focus of these works is mainly to allow scaling down of the feature space and representation of the final output classifier.\nDai et al. (2014) focus on tractability of large scale kernel methods, and their proposed doubly stochastic algorithm can also be used for learning with random features as we have here. In Dai et al. (2014) the objective considered is of the regularized form:\u03b32 \u2016f\u2016\n2 +R(f), with a corresponding sample complexity of O(1/(\u03b32 2)) samples needed to achieve approximation with respect to the risk of the optimum of the regularized objective.\nTo relate the above results to ours, we begin by emphasizing that the bound in (Dai et al., 2014) holds for fixed \u03b3, and refers to optimization of the regularized objective. Our objective is to minimize the risk R(f) which is the expected squared loss, for which we need to choose \u03b3 = O( B2 ) in order to attain accuracy (Sridharan et al., 2009). Plugging this \u03b3 into the generalization bound in Dai et al. (2014) we obtain that the algorithm in Dai et al. (2014) needs O(B 4\n4 ) samples to compete with the optimal target function in the B-ball. Our algorithm needs O(B 2\n2 ) examples which is considerably better. We note that their method does extend to a larger class of losses, whereas our is restricted to the quadratic loss.\nIn Rahimi & Recht (2009), the authors consider embedding the domain into the feature space x \u2192 [\u03c8(w1;x), . . . , \u03c8(wm;x)], where wi are IID random variables sampled according to some prior \u00b5(w). They show that with O(B 2 log 1/\u03b4 2 ) random features estimated on O(B 2 log 1/\u03b4 2 ) samples they can compete with the class:\nHB\u00b5 max = { x\u2192 \u222b \u03c8(w;x)f(w)d\u00b5(w) : |f(w)| \u2264 B } Our algorithm relates to the mean square error cost function which does not meet the condition in Rahimi & Recht (2009), and is hence formally incomparable. Yet we can invoke our algorithm to compete against a larger class\nof target functions. Our main result shows that Algorithm 1, using O\u0303(B 8 4 ) estimated features and using O( B2\n2 ) samples will, in expectation, output a predictor that is close to the best in HB\u00b5 . Note that |f(w)| < B implies Ew\u223c\u00b5(f2(w)) < B2. Hence HB\u00b5 max \u2286 H B \u00b5 . Note however, that the number of estimated features (as a function of B) is worse in our case.\nOur approach to the problem is to consider learning with a noisy estimate of the kernel. A related setting was studied in Cesa-Bianchi et al. (2011b), where the authors considered learning with kernels when the data is corrupted. Noise in the data and noise in the scalar product estimation are not equivalent when there is non-linearity in the kernel space embedding. There is also extensive research on linear regression with actively chosen attributes (CesaBianchi et al., 2011a; Hazan & Koren, 2012). The convergence rates and complexity of the algorithms are dimension dependent. It would be interesting to see if their method can be extended from finite set of attributes to a continuum set of attributes."}, {"heading": "5. Algorithm", "text": "We next turn to present Algorithm 1, from which our main result is derived. The algorithm is similar in spirit to Online Gradient Descent (OGD) (Zinkevich, 2003), but with some important modifications that are necessary for our analysis.\nWe first introduce the problem in the terminology of online convex optimization, as in Zinkevich (2003). At iteration t our algorithm outputs a hypothesis ft. It then receives as feedback (xt, yt), and suffers a loss `t(ft) as in Eq. 6. The objective of the algorithm is to minimize the regret against a benchmark of B-bounded functions, as in Eq. 7.\nA classic approach to the problem is to exploit the OGD algorithm. Its simplest version would be to update ft+1 \u2192 ft \u2212 \u03b7\u2207t where \u03b7 is a step size, and \u2207t is the gradient of the loss w.r.t. f at ft. In our case,\u2207t is given by:\n\u2207t = (\u3008ft,\u03a6(xt)\u3009 \u2212 yt) \u03a6(xt) (9)\nApplying this update would also result in a function ft =\u2211t i=1 \u03b1i\u03a6(xt) as we have in Algorithm 1 (but with different \u03b1i from ours). However, in our setting this update is not applicable since the scalar product \u3008ft,\u03a6(xt)\u3009 is not available. One alternative is to use a stochastic unbiased estimate of the gradient that we denote by \u2207\u0304t. This induces an update step ft+1 \u2192 ft \u2212 \u03b7\u2207\u0304t. One can show that OGD with such an estimated gradient enjoys the following upper bound on the regret E [ \u2211 `t(ft)\u2212 `t(f\u2217)] for every \u2016f\u2217\u2016 \u2264 B (e.g., see Shalev-Shwartz, 2011):\nB2\n\u03b7 + \u03b7 T\u2211 i=1 E [ \u2016\u2207t\u20162 ] + \u03b7 T\u2211 i=1 V [ \u2207\u0304t ] , (10)\nwhere V [ \u2207\u0304t ] = E [ \u2016\u2207\u0304t \u2212\u2207t\u20162 ] . We can bound the first two terms using standard techniques applicable for the squared loss (e.g., see Zhang, 2004; Srebro et al., 2010). The third term depends on our choice of gradient estimate. There are various choices for such an estimate, and we use a version which facilitates our analysis, as explained below. Assume that at iteration t, our function ft is given by ft =\u2211t i=1 \u03b1 (t) i \u03a6(xt). We now want to use sampling to obtain an unbiased estimate of \u3008ft,\u03a6(xt)\u3009. This will be done via a two step sampling procedure, as described in Algorithm 2. First, sample an index i \u2208 [1, . . . , t] by sampling according to the distribution q(i) \u221d |\u03b1(t)i |. Next, for the chosen i, sample w\u0304 according to \u00b5, and use \u03c8(x; w\u0304)\u03c8(xi; w\u0304) to construct an estimate of \u3008\u03a6(xi),\u03a6(xt)\u3009. The resulting unbiased estimate of \u3008\u03a6(xi),\u03a6(xt)\u3009 is denoted by Et and given by:\nEt = \u2016\u03b1(t)\u20161 m m\u2211 i=1 sgn(\u03b1(t)i )\u03c8(xi; w\u0304)\u03c8(xt; w\u0304) (11)\nThe corresponding unbiased gradient estimate is:\n\u2207\u0304t = (Et \u2212 yt)xt (12)\nThe variance of \u2207\u0304 affects the convergence rate and depends on both \u2016\u03b1\u20161 and the number of estimationsm. We wish to maintain m = O(T ) estimations per round, while achieving O( \u221a T ) regret.\nTo effectively regularize \u2016\u03b1\u20161, we modify the OGD algorithm so that whenever Et is larger then 16B, we do not perform the usual update. Instead, we perform a shrinking step that divides \u03b1(t) (and hence ft) by 4. Treating B as constant, this guarantees that \u2016\u03b1\u20161 = O(\u03b7T ), and in turn Var(\u2207\u0304t) = O(\u03b7 2T 2 m ). Setting \u03b7 = O(1/ \u221a T ), we have that m = O(T ) estimations are sufficient.\nThe rationale for the shrinkage is that wheneverEt is large, it indicates that ft is \u201cfar away\u201d from the B-ball, and a shrinkage step, similar to projection, brings ft closer to the optimal element in the B-ball. However, due to stochasticity, the shrinkage step does add a further term to the regret bound that we would need to take care of."}, {"heading": "5.1. Analysis", "text": "In what follows we analyze the regret for Algorithm 1, and provide a high level proof of Theorem 1. The appendix provides the necessary lemmas and a more detailed proof. We begin by modifying the regret bound for OGD in Eq. 10 to accommodate for steps that differ from the standard gradient update, such as shrinkage. We use the following notation for the regret at iteration t:\nRt(f \u2217) = E [ T\u2211 t=1 `t(ft)\u2212 `t(f\u2217) ] (13)\nLemma 1. Let `1, . . . , `T be an arbitrary sequence of convex loss functions, and let f1, . . . , fT be random vectors, produced by an online algorithm. Assume \u2016fi\u2016 \u2264 BT for all i \u2264 T . For each t let \u2207\u0304t be an unbiased estimator of \u2207`t(ft). Denote f\u0302t = ft\u22121 \u2212 \u03b7\u2207\u0304t\u22121 and let\nPt(f \u2217) = P [ \u2016ft \u2212 f\u2217\u2016 > \u2016f\u0302t \u2212 f\u2217\u2016 ] . (14)\nFor every \u2016f\u2217\u2016 \u2264 B it holds that :\nRt(f \u2217) \u2264 B\n2\n\u03b7 + \u03b7 T\u2211 t=1 E [ \u2016\u2207t\u20162 ] + \u03b7 T\u2211 t=1 V [ \u2207\u0304t ] +\nT\u2211 t=1 (BT +B) 2 \u03b7 E [Pt(f\u2217)] (15)\nSee Appendix B.1 for proof of the lemma. As discussed earlier, the first three terms on the RHS are the standard bound for OGD from Eq. 10. Note that in the standard OGD it holds that ft = f\u0302t, and therefore Pt(f\u2217) = 0 and the last term disappears.\nThe third term will be bounded by controlling \u2016\u03b1\u20161. The last term Pt(f\u2217) is a penalty that results from updates that stir ft away from the standard update step f\u0302t. This will indeed happen for the shrinkage step. The next lemma bounds this term. See Appendix B.2 for proof.\nLemma 2. Run Algorithm 1 with parameters T , B \u2265 1 and \u03b7 < 1/8. Let \u2207\u0304t be the unbiased estimator of \u2207`t(ft) of the form \u2207\u0304t = (Et \u2212 yt)\u03a6(xt). Denote f\u0302t = ft \u2212 \u03b7\u2207\u0304t and define Pt(f\u2217) as in Eq. 14. Then:\nPt(f \u2217) \u2264 2 exp ( \u2212 m\n(3\u03b7t)2\n)\nThe following lemma (see Appendix B.3 for proof) bounds the second and third terms of Eq. 15. Lemma 3. Consider the setting as in Lemma 2. Then V [ \u2207\u0304t ] \u2264 ((16B+1)\u03b7t) 2 m and E [ \u2016\u2207t\u20162 ] \u2264 2E [`t(ft)].\nProof of Theorem 1 Combining Lemmas 1, 2 and 3 and rearranging we get:\n(1\u2212 2\u03b7)E [Rt(f\u2217)] \u2264 B2\n\u03b7 + 2\u03b7 T\u2211 t=1 `t(f \u2217) + (16)\n\u03b7 ((16B + 1)\u03b7T )2T\nm +\n(BT +B) 2\n\u03b7\nT\u2211 t=1 Pt(f \u2217)\nTo bound the second term in Eq. 16 we note that:\nmin \u2016f\u2217\u2016<B T\u2211 t=1 `t(f \u2217) \u2264 T\u2211 t=1 `t(0) \u2264 T. (17)\nWe next set \u03b7 and m as in the statement of the theorem. Namely: \u03b7 = B\n2 \u221a T , andm = ((16B+1)B)2T log \u03b3, where \u03b3 = max (\n((16B+1)\u03b7T+B)2) \u03b72 , e\n) . This choice of m implies\nthat m > ((16B + 1)\u03b7T )2, and hence the third term in Eq. 16 is upper bounded by T .\nNext we have that m > (3\u03b7t)2 log \u03b3 for every t, and by the bound on BT we have that \u03b3 > (B+BT ) 2\n\u03b72 . Taken together with Lemma 2 we have that:\n(BT +B) 2\n\u03b7\nT\u2211 t=1 Pt(f \u2217) \u2264 \u03b7T. (18)\nThe above bounds imply that:\n(1\u2212 2\u03b7)E [Rt(f\u2217)] \u2264 B2\n\u03b7 + 2\u03b7T + \u03b7T + \u03b7T\nFinally by choice of \u03b7, and dividing both sides by (1\u2212 2\u03b7) we obtain the desired result."}, {"heading": "6. Experiments", "text": "In this section we provide a toy experiment to compare our Shrinking Gradient algorithm to other random feature based methods. In particular, we consider the following three algorithms: Fixed-Random: Sample a set of r features w1, . . . ,wr and evaluate these on all the train and test points. Namely, all x points will be evaluated on the same features. This is the standard random features approach proposed in Rahimi & Recht (2007; 2009). Doubly Stochastic Gradient Descent (Dai et al., 2014): Here each training point x samples k features w1, . . . ,wk. These features will from that point on be used for evaluating dot products with x. Thus, different x points will use different features. Shrinking Gradient: This is the approach proposed here in Section 3. Namely, each training point x samples m features in order to calculate the dot product with the current regression function.\nIn comparing the algorithms we choose r, k,m so that the same overall number of features is calculated. For all methods we explored different initial step sizes and schedules for changing the step size.\nThe key question in comparing the three algorithms is how well they use a given budget of random features. To explore this we perform an experiments to simulate the high dimensional feature case. We consider vectors x \u2208 RD, where a random feature w corresponds to a uniform choice of coordinate w in x. We work in the regime where D is large in the sense that D > T , where T is the size of the training data. Thus random sampling of T features will not reveal all coordinates of x. The training set is generated as follows. First, a training set x1, . . . ,xT \u2208 RD is\nsampled from a standard Gaussian. We furthermore clip negative values to zero, in order to make the data sparser and more challenging for feature sampling. Next a weight vector a \u2208 RD is chosen as a random sparse linear combination of the training points. This is done in order for the true function to be in the corresponding RKHS. Finally, the training set is labeled using yi = a \u00b7 xi.\nDuring training we do not assume that the algorithms have access to x. Rather they can uniformly sample coordinates from it, which mimics our setting of random features. For the experiment we take D = 550, 600, . . . , 800 and T = 200. All algorithms perform one pass over the data, to emulate the online regret setting. The results shown in Figure 1 show that our method indeed achieves a lower loss while working with the same feature budget."}, {"heading": "7. Discussion", "text": "We presented a new online algorithm that employs kernels implicitly but avoids the kernel trick assumption. Namely, the algorithm can be invoked even when one has access to only estimations of the scalar product. The problem was motivated by kernels resulting from neural nets, but it can of course be applied to any scalar product of the form we described. As an example of an interesting extension, consider a setting where a learner can observe an unbiased estimate of a coordinate in a kernel matrix, or alternatively the scalar product between any two observations. Our results imply that in this setting the above rates are applicable, and at least for the square loss, having no access to the true values in the kernel matrix is not necessarily prohibitive during training.\nThe results show that with sample size T we can achieve error of O( B\u221a\nT ). As demonstrated in Shamir (2015) these\nrates are optimal, even when the scalar product is computable. To achieve this rate our algorithm needs to perform O\u0303(B4T 2) scalar product estimations. When the scalar product can be computed, existing kernelized algorithms need to observe a fixed proportion of the kernel matrix, hence they observe order of \u2126(T 2) scalar products. In Cesa-Bianchi et al. (2015) it was shown that when the scalar product can be computed exactly, one would need access to at least \u2126(T ) entries to the kernel matrix. It is still an open problem whether one has to access \u2126(T 2) entries when the kernel can be computed exactly. However, as we show here, for fixed B even if the kernel can only be estimated O\u0303(T 2) estimations are enough. It would be interesting to further investigate and improve the performance of our algorithm in terms of the norm bound B.\nTo summarize, we have shown that the kernel trick is not strictly necessary in terms of sample complexity. Instead, simply sampling random features via our proposed algorithm results in a similar sample complexity. Recent empirical results by Zhang et al. (2016) show that using a large number of random features and regression comes close to the performance of the first successful multilayer CNNs (Krizhevsky et al., 2012) on CIFAR-10. Although deep learning architectures still substantially outperform random features, it is conceivable that with the right choice of random features, and scalable learning algorithms like we present here, considerable improvement in performance is possible."}, {"heading": "A. Estimation Concentration Bounds", "text": "In this section we provide concentration bounds for the estimation procedure in Algorithm 2. Lemma 4. Run Algorithm 2 with \u03b1 and, {xi}Ti=1, x, and m. Let f = \u2211 \u03b1i\u03a6(xi). Assume that |\u03c8(x;w)| < 1 for all w and x. Let E be the output of Algorithm 2. Then E is an unbiased estimator for \u3008f,\u03a6(x)\u3009 and:\nP [|E \u2212 \u3008f,\u03a6(x)\u3009| > ] \u2264 exp ( \u2212 m 2\n\u2016\u03b1\u201621\n) (19)\nProof. Consider the random variables \u2016\u03b1\u20161E(k) (where E(k) is as defined in Algorithm 2) and note that they are IID. One can show that E [ \u2016\u03b1\u20161E(k) ] =\u2211\n\u03b1iE [\u03c8(xi;w)\u03c8(x;w)] = \u3008f,\u03a6(x)\u3009. By the bound on \u03c8(x;w) we have that \u2223\u2223\u2016\u03b1\u20161E(k)\u2223\u2223 < \u2016\u03b1\u20161 with probability 1. Since E = 1m \u2211 E(k) the result follows directly from Hoeffding\u2019s inequality.\nNext, we bound the \u03b1(t) coeffcients and obtain a concentration bound for the estimated dot product Et. Lemma 5. The \u03b1(t) obtained in Algorithm 1 satisfies:\n\u2016\u03b1(t)\u20161 \u2264 (16B + 1)\u03b7t.\nAs a corollary of this and Lemma 4 we have that the function ft satisfies:\nP [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| > ] \u2264 exp ( \u2212\n2m\n((16B + 1)\u03b7t)2 ) (20)\nProof. We prove the statement by induction. We separate into two cases, depending on whether the shrinkage step was performed or not.\nIf |Et| \u2265 16B the algorithm sets \u03b1(t+1) = 14\u03b1 (t), and:\n\u2016\u03b1(t+1)\u20161 = 1\n4 \u2016\u03b1(t)\u20161 \u2264 (16B + 1)\u03b7(t+ 1)\nIf |Et| < 16B the gradient update is performed. Since |yt| \u2264 1 we have that |Et \u2212 yt| < 16B + 1 and:\n\u2016\u03b1(t+1)\u20161 \u2264 \u2016\u03b1(t)\u20161 + \u03b7|Et \u2212 yi| \u2264 (16B + 1)\u03b7(t+ 1)."}, {"heading": "B. Proofs of Lemmas", "text": "B.1. Proof of Lemma 1\nFirst, by convexity we have that\n2(`t(ft)\u2212 `t(f\u2217)) \u2264 2 \u3008\u2207t, ft \u2212 f\u2217\u3009 . (21)\nNext we upper bound \u3008\u2207t, ft \u2212 f\u2217\u3009. Denote by E the event \u2016ft+1 \u2212 f\u2217\u2016 > \u2016f\u0302t+1 \u2212 f\u2217\u2016. Note that:\nE [ \u2016ft+1 \u2212 f\u2217\u20162 ] \u2264 E [ \u2016f\u0302t+1 \u2212 f\u2217\u20162 ] +\nE [ \u2016ft+1 \u2212 f\u2217\u20162 \u2223\u2223E] \u00b7 Pt+1(f\u2217) \u2264 E [ \u2016f\u0302t+1 \u2212 f\u2217\u20162 ] + (B +BT ) 2Pt+1(f \u2217)\nPlugging in f\u0302t+1 = ft \u2212 \u03b7\u2207\u0304t, summing over t and using Eq. 21 and E [ \u2016\u2207\u0304t\u20162 ] = E [ \u2016\u2207t\u20162 ] + V [ \u2207\u0304t ] , we obtain the desired result.\nB.2. Proof for Lemma 2\nTo prove the bound in the lemma, we first bound the event Pt(f \u2217) w.r.t to two possible events:\nLemma 6. Consider the setting as in Lemma 2. Run Algorithm 1 and for each t consider the following two events:\n\u2022 Et1 : |Et| > 16B and |Et| > 14\u03b7\u2016ft\u2016.\n\u2022 Et2 : |Et| > 16B and \u2016ft\u2016 < 8B.\nFor every \u2016f\u2217\u2016 < B we have that Pt(f\u2217) < P [Et1 \u222a Et2].\nProof. Denote the event |Et| > 16B by Et0. Note that if Et0 does not happen, then ft = f\u0302t. Hence trivially\nPt(f \u2217) = P [ \u2016ft \u2212 f\u2217\u2016 > \u2016f\u0302t \u2212 f\u2217\u2016 \u2227 Et0 ] We will assume that: (1) |Et| > 16B., (2) |Et| < 14\u03b7\u2016ft\u2016., (3) \u2016ft\u2016 > 8B. We then show \u2016ft+1\u2212f\u2217\u2016 \u2264 \u2016f\u0302t+1\u2212f\u2217\u2016.\nIn other words, we will show that if Et0 happens and \u2016ft+1\u2212 f\u2217\u2016 > \u2016f\u0302t+1 \u2212 f\u2217\u2016, then either Et2 or Et1 happened. This will conclude the proof.\nFix t, note that since |\u03c8(x;w)| < 1 we have that \u2016\u03a6(x)\u2016 < 1. We then have:\n\u2016f\u0302t+1\u2016 = \u2016ft \u2212 \u03b7(Et \u2212 y)\u03a6(xt)\u2016 (22)\n\u2265 \u2016ft\u2016 \u2212 \u03b7|Et| \u2212 \u03b7 \u2265 3\n4 \u2016ft\u2016 \u2212 \u03b7\nwhere the last inequality is due to assumption (2) above. We therefore have the following for every \u2016f\u2217\u2016 < B:\n\u2016f\u0302t+1 \u2212 f\u2217\u2016 \u2265 3\n4 \u2016ft\u2016 \u2212 \u03b7 \u2212B\nOn the other hand, if ft+1 6= f\u0302t+1 then by construction of the algorithm ft+1 = 14ft:\n\u2016ft+1 \u2212 f\u2217\u2016 \u2264 \u2016ft+1\u2016+ \u2016f\u2217\u2016 \u2264 \u2016ft\u2016\n4 +B.\nNext note that \u03b7 < 2B and assumption (3) states \u2016ft\u2016 > 8B. Therefore: 12\u2016ft\u2016 > 4B > \u03b7 + 2B, and:\n\u2016f\u0302t+1 \u2212 f\u2217\u2016 \u2265 3\n4 \u2016ft\u2016 \u2212 \u03b7 \u2212B\n= 1\n4 \u2016ft\u2016+\n( 1\n2 \u2016ft\u2016 \u2212 \u03b7 \u2212 2B\n) +B\n\u2265 1 4 \u2016ft\u2016+B \u2265 \u2016ft+1 \u2212 f\u2217\u2016\nNext we upper bound P [Et1 \u222a Et2]. In what follows the superscript t is dropped. A bound for P [E1 \u2229 Ec2 ]: Assume that\n|Et \u2212 \u3008ft,\u03a6(xt)\u3009| < ( 1\n4\u03b7 \u2212 1)8B.\nWe assume T is sufficiently large and \u03b7 < 18 . We have 1 4\u03b7 \u2212 1 > 1. Since we assume E2 did not happen we must have \u2016ft\u2016 > 8B and |Et \u2212 \u3008ft,\u03a6(xt)\u3009| < ( 14\u03b7 \u2212 1)\u2016f\u2016, and therefore:\nEt \u2212 \u2016f\u2016 < |Et \u2212 \u3008ft,\u03a6(xt)\u3009| < ( 1\n4\u03b7 \u2212 1)\u2016f\u2016.\nWhich implies Et < 14\u03b7\u2016f\u2016, and we get that E1 did not happen. We conclude that if E1 and not E2 then:\n|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 ( 1\n4\u03b7 \u2212 1)8B.\nSince 14\u03b7 \u2212 1 > 1 we have that: |Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B, leading to:\nP [E1 \u2229 Ec2 ] \u2264 P [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B] . (23)\nA bound for P [E2]: If |Et| > 16B and \u2016ft\u2016 < 8B then by normalization of \u03a6(xt) we have that \u3008ft,\u03a6(xt)\u3009 < 8B and trivially we have that |Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B, and therefore:\nP [E2] \u2264 P [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B] . (24)\nTaking Eq. 23 and Eq. 24 we have that\nP [E2 \u222a E1] \u2264 2P [|Et \u2212 \u3008ft,\u03a6(xt)\u3009| \u2265 8B] . (25)\nBy Lemma 5 we have that:\nP (|Et \u2212 \u3008ft,\u03a6(xt)\u3009|) > 8B) <\nexp(\u2212 m(8B) 2\n((16B + 1)\u03b7t)2 ) < exp\n( \u2212 m\n(3\u03b7t)2 ) Taking the above upper bounds together with Lemma 6 we can prove Lemma 2.\nB.3. Proof of Lemma 3\nBegin by noting that since \u2016\u03a6(x)\u2016 < 1, it follows from the definitions of \u2207, \u2207\u0304 that V [ \u2207\u0304t ] = E [ \u2016\u2207\u0304t \u2212\u2207t\u20162 ] and therefore\nV [ \u2207\u0304t ] \u2264 E [ (Et \u2212 \u3008ft,\u03a6(xt)\u3009)2 ] = V [Et]\nBy construction (see Algorithm 2) we have that:\nV [Et] = 1 m V [ \u2016\u03b1(t)\u201621\u03c8(xi;w)\u03c8(xt;w) ] where the index i is sampled as in Algorithm 2, and \u03c8(xi;w)\u03c8(xt;w) is bounded by 1. By Lemma 5 we have that\nV [Et] \u2264 ((16B + 1)\u03b7t)2\nm . This provides the required bound on V [ \u2207\u0304t ] . Additionally, we have that\n\u2016\u2207t\u20162 = (\u3008ft,\u03a6(xt)\u3009 \u2212 yt)2\u2016\u03a6(xt)\u20162 \u2264 2`t(ft)\nand the result follows by taking expectation.\nAcknowledgements The authors would like to thank Tomer Koren for helpful discussions. Roi Livni was supported by funding from Eric and Wendy Schmidt Fund for Strategic Innovation. This work was supported by the Blavatnik Computer Science Research Fund, the Intel Collaborative Research Institute for Computational Intelligence (ICRI-CI), and an ISF Centers of Excellence grant."}], "year": 2017, "references": [{"title": "Breaking the curse of dimensionality with convex neural networks", "authors": ["Bach", "Francis"], "venue": "arXiv preprint arXiv:1412.8690,", "year": 2014}, {"title": "On the equivalence between kernel quadrature rules and random feature expansions", "authors": ["Bach", "Francis"], "venue": "arXiv preprint arXiv:1502.06800,", "year": 2015}, {"title": "Kernel descriptors for visual recognition", "authors": ["Bo", "Liefeng", "Ren", "Xiaofeng", "Fox", "Dieter"], "venue": "In Advances in neural information processing systems,", "year": 2010}, {"title": "Object recognition with hierarchical kernel descriptors", "authors": ["Bo", "Liefeng", "Lai", "Kevin", "Ren", "Xiaofeng", "Fox", "Dieter"], "venue": "In Computer Vision and Pattern Recognition (CVPR),", "year": 2011}, {"title": "On invariance in hierarchical models", "authors": ["Bouvrie", "Jake", "Rosasco", "Lorenzo", "Poggio", "Tomaso"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2009}, {"title": "Efficient learning with partially observed attributes", "authors": ["Cesa-Bianchi", "Nicolo", "Shalev-Shwartz", "Shai", "Shamir", "Ohad"], "venue": "The Journal of Machine Learning Research,", "year": 2011}, {"title": "Online learning of noisy data", "authors": ["Cesa-Bianchi", "Nicolo", "Shalev-Shwartz", "Shai", "Shamir", "Ohad"], "venue": "Information Theory, IEEE Transactions on,", "year": 2011}, {"title": "On the complexity of learning with kernels", "authors": ["Cesa-Bianchi", "Nicol\u00f2", "Mansour", "Yishay", "Shamir", "Ohad"], "venue": "In Proceedings of The 28th Conference on Learning Theory, pp", "year": 2015}, {"title": "Kernel methods for deep learning", "authors": ["Cho", "Youngmin", "Saul", "Lawrence K"], "venue": "In Advances in neural information processing systems,", "year": 2009}, {"title": "Scalable kernel methods via doubly stochastic gradients", "authors": ["Dai", "Bo", "Xie", "He", "Niao", "Liang", "Yingyu", "Raj", "Anant", "Balcan", "Maria-Florina F", "Song", "Le"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2014}, {"title": "From average case complexity to improper learning complexity", "authors": ["Daniely", "Amit", "Linial", "Nati", "Shalev-Shwartz", "Shai"], "venue": "In Proceedings of the 46th Annual ACM Symposium on Theory of Computing,", "year": 2014}, {"title": "Use of kernel deep convex networks and end-to-end learning for spoken language understanding", "authors": ["Deng", "Li", "Tur", "Gokhan", "He", "Xiaodong", "Hakkani-Tur", "Dilek"], "venue": "In Spoken Language Technology Workshop (SLT), 2012 IEEE,", "year": 2012}, {"title": "Linear regression with limited observation", "authors": ["Hazan", "Elad", "Koren", "Tomer"], "venue": "In Proceedings of the 29th International Conference on Machine Learning", "year": 2012}, {"title": "Steps toward deep kernel methods from infinite neural networks", "authors": ["Hazan", "Tamir", "Jaakkola", "Tommi"], "venue": "arXiv preprint arXiv:1508.05133,", "year": 2015}, {"title": "Improper deep kernels", "authors": ["Heinemann", "Uri", "Livni", "Roi", "Eban", "Elad", "Elidan", "Gal", "Globerson", "Amir"], "venue": "In Proceedings of the 19th International Conference on Artificial Intelligence and Statistics,", "year": 2016}, {"title": "Some new results on neural network approximation", "authors": ["Hornik", "Kurt"], "venue": "Neural Networks,", "year": 1993}, {"title": "Random feature maps for dot product kernels", "authors": ["Kar", "Purushottam", "Karnick", "Harish"], "venue": "In International Conference on Artificial Intelligence and Statistics,", "year": 2012}, {"title": "Online learning with kernels", "authors": ["Kivinen", "Jyrki", "Smola", "Alexander J", "Williamson", "Robert C"], "venue": "IEEE transactions on signal processing,", "year": 2004}, {"title": "Cryptographic hardness for learning intersections of halfspaces", "authors": ["Klivans", "Adam R", "Sherstov", "Alexander A"], "venue": "In Foundations of Computer Science,", "year": 2006}, {"title": "Imagenet classification with deep convolutional neural networks. In Advances in neural information processing", "authors": ["Krizhevsky", "Alex", "Sutskever", "Ilya", "Hinton", "Geoffrey E"], "year": 2012}, {"title": "On the computational efficiency of training neural networks", "authors": ["Livni", "Roi", "Shalev-Shwartz", "Shai", "Shamir", "Ohad"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2014}, {"title": "Convolutional kernel networks", "authors": ["Mairal", "Julien", "Koniusz", "Piotr", "Harchaoui", "Zaid", "Schmid", "Cordelia"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2014}, {"title": "Perceptrons: an introduction to computational geometry (expanded edition)", "authors": ["Minsky", "Marvin", "Papert", "Seymour"], "year": 1988}, {"title": "Random features for largescale kernel machines", "authors": ["Rahimi", "Ali", "Recht", "Benjamin"], "venue": "In Advances in neural information processing systems,", "year": 2007}, {"title": "Weighted sums of random kitchen sinks: Replacing minimization with randomization in learning", "authors": ["Rahimi", "Ali", "Recht", "Benjamin"], "venue": "In Advances in neural information processing systems,", "year": 2009}, {"title": "Online learning and online convex optimization", "authors": ["Shalev-Shwartz", "Shai"], "venue": "Foundations and Trends in Machine Learning,", "year": 2011}, {"title": "The sample complexity of learning linear predictors with the squared loss", "authors": ["Shamir", "Ohad"], "venue": "Journal of Machine Learning Research,", "year": 2015}, {"title": "Smoothness, low noise and fast rates", "authors": ["Srebro", "Nathan", "Sridharan", "Karthik", "Tewari", "Ambuj"], "venue": "In Advances in neural information processing systems,", "year": 2010}, {"title": "Fast rates for regularized objectives", "authors": ["Sridharan", "Karthik", "Shalev-Shwartz", "Shai", "Srebro", "Nathan"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2009}, {"title": "Least squares support vector machine classifiers", "authors": ["Suykens", "Johan AK", "Vandewalle", "Joos"], "venue": "Neural processing letters,", "year": 1999}, {"title": "Least squares support vector machines", "authors": ["Suykens", "Johan AK", "Van Gestel", "Tony", "De Brabanter", "Jos"], "venue": "World Scientific,", "year": 2002}, {"title": "Computing with infinite networks. Advances in neural information processing systems, pp", "authors": ["Williams", "Christopher"], "year": 1997}, {"title": "Understanding deep learning requires rethinking generalization", "authors": ["Zhang", "Chiyuan", "Bengio", "Samy", "Hardt", "Moritz", "Recht", "Benjamin", "Vinyals", "Oriol"], "venue": "arXiv preprint arXiv:1611.03530,", "year": 2016}, {"title": "Solving large scale linear prediction problems using stochastic gradient descent algorithms", "authors": ["Zhang", "Tong"], "venue": "In Proceedings of the twenty-first international conference on Machine learning,", "year": 2004}, {"title": "Online convex programming and generalized infinitesimal gradient ascent", "authors": ["Zinkevich", "Martin"], "venue": "In Machine Learning, Proceedings of the Twentieth International Conference,", "year": 2003}], "id": "SP:5259fa7eb797f497be1fdee02299df43f146547f", "authors": [{"name": "Roi Livni", "affiliations": []}, {"name": "Daniel Carmon", "affiliations": []}, {"name": "Amir Globerson", "affiliations": []}], "abstractText": "Infinite Layer Networks (ILN) have been proposed as an architecture that mimics neural networks while enjoying some of the advantages of kernel methods. ILN are networks that integrate over infinitely many nodes within a single hidden layer. It has been demonstrated by several authors that the problem of learning ILN can be reduced to the kernel trick, implying that whenever a certain integral can be computed analytically they are efficiently learnable. In this work we give an online algorithm for ILN, which avoids the kernel trick assumption. More generally and of independent interest, we show that kernel methods in general can be exploited even when the kernel cannot be efficiently computed but can only be estimated via sampling. We provide a regret analysis for our algorithm, showing that it matches the sample complexity of methods which have access to kernel values. Thus, our method is the first to demonstrate that the kernel trick is not necessary, as such, and random features suffice to obtain comparable performance.", "title": "Learning Infinite Layer Networks Without the Kernel Trick"}