{"sections": [{"heading": "1 Introduction", "text": "The Partially Observable Markov Decision Processes (POMDP) [8] is a general model for sequential decision making in stochastic and partially observable environments, which are ubiquitous in real-world problems. A key shortcoming of POMDP methods is the assumption that the dynamics of the environment are known a priori. In real-world applications, however, it may be impossible to obtain a complete and accurate description of the system. Instead, we may have uncertain prior knowledge about the model. When lacking a model, a prior can be incorporated into the POMDP problem in a principled way, as demonstrated by the Bayes-Adaptive POMDP framework [13].\nThe BA-POMDP framework provides a Bayesian approach to decision making by maintaining a probability distribution over possible models as the agent acts in an online reinforcement learning setting [5, 19]. This method casts the Bayesian reinforcement learning problem into a POMDP planning problem where the hidden model of the environment is part of the state space. Unfortunately, this planning problem becomes very large, with a countably infinite state space over all possible models, and as such, current solution methods are not scalable or perform poorly [13].\nOnline and sample-based planning has shown promising performance on non-trivial POMDP problems [12]. Online methods reduce the complexity by considering the relevant (i.e., reachable) states only, and sample-based approaches tackle the complexity issues through approximations in the form of simulated interactions with the environment. Here we modify one of those methods, Partial Observable Monte-Carlo Planning (POMCP) [15] and extend it to the Bayes-Adaptive case, leading to a novel approach: BA-POMCP.\nIn particular, we improve the sampling approach by exploiting the structure of the BA-POMDP resulting in root sampling and expected models methods. We also present an approach for more efficient model representation, which we call linking states. Lastly, we prove the correctness of our improvements, showing that they converge to the true BA-POMDP solution. As a result, we present methods that significantly improve the scalability of learning in BAPOMDPs, making them practical for larger problems."}, {"heading": "2 Background", "text": "First, we discuss POMDPs and BA-POMDPs in respectively Section 2.1 and 2.2."}, {"heading": "2.1 POMDPs", "text": "Formally, a POMDP is described by a tuple (S, A, Z, D, R, \u03b3, h), where S is the set of states of the environment; A is the set of actions; Z is the set of observations; D is the \u2018dynamics function\u2019 that describes the dynamics of the \u2217This is an extended version of a paper that was published at ICML\u20192017.\nar X\niv :1\n80 6.\n05 63\n1v 1\n[ cs\n.A I]\n1 4\nJu n\n20 18\nsystem in the form of transition probabilities D(s\u2032,z|s,a);1 R is the immediate reward function R(s, a) that describes the reward of selecting a in s; \u03b3 \u2208 [0,1) is the discount factor; and h is the horizon of an episode in the system.\nThe goal of the agent in a POMDP is to maximize the expected cumulative (discounted) reward, also called the expected return. The agent has no direct access to the system\u2019s state, so it can only rely on the action-observation history ht = \u3008a0,z1, . . . ,at\u22121,zt\u3009 up to the current step t. It can use this history to maintain a probability distribution over the state, also called a belief, b(s). A solution to a POMDP is then a mapping from a belief b to an action a, which is called a policy \u03c0. Solution methods aim to find an optimal policy, a mapping from a belief to an action with the highest possible expected return.\nThe agent maintains its belief during execution through belief updates. A belief update calculates the posterior probability of the state s\u2032 given the previous belief over s and action-observation pair \u3008a,z\u3009: b\u2032(s) = P (s\u2032|b(s), a, z). This operation is infeasible for large spaces because it enumerates over the entire state space. A common approximation method is to represent the belief with a (unweighted) particle filter [17]. A particle filter is a collection of K particles (states). Each particle represents a probability of 1K ; if a specific state x occurs n times in a particle filter, then P (x) = nK . The precision of the filter is determined by the number of particles K. To update such a belief after execution of action a and observation z, a standard approach is to utilize rejection sampling: the agent repeatedly samples a state s from its belief, then simulates the execution of a on s through D, and receives a (simulated) new state s\u2032sim and observation zsim. s\n\u2032 is added to the new belief only when zsim equals z, and rejected otherwise. This process repeats until the new belief contains K particles.\nPartially Observable Monte-Carlo Planning (POMCP) [15], is a scalable method which extends Monte Carlo tree search (MCTS) to solve POMDPs. POMCP is one of the leading algorithms for solving general POMDPs. At each time step, the algorithm performs online planning by incrementally building a lookahead tree that contains Q(h,a), where h is the action-observation history-path to reach that node. It samples hidden states s at the root node (called \u2018root sampling\u2019) and uses that state to sample a trajectory that first traverses the lookahead tree and then performs a (random) rollout. The return of this trajectory is used to update the statistics for all visited nodes. These statistics include the number of times an action has been taken at a history (N(h,a)) and estimated value of being in that node (Q(h,a)), based on an average over the returns.\nBecause this lookahead tree can be very large, the search is directed to the relevant parts by selecting the actions inside the tree that maximize the \u2018upper confidence bounds\u2019 [2]: U(h,a) = Q(h, a) + c \u221a log(N(h) + 1)/N(h,a). Here, N(h) is the number of times the history has been visited. At the end of each simulation, the discounted accumulated return is used to update the estimated value of all the nodes in the tree that have been visited during that simulation. POMCP terminates after some criteria has been met, typically defined by a maximum number of simulations or allocated time. The agent then picks the action with the highest estimated value (maxaQ(b,a)). POMCP can be shown to converge to an -optimal value function. Moreover, the method has demonstrated good performance in large domains with a limited number of simulations. The extension of POMCP that is used in this work is discussed in Section 3."}, {"heading": "2.2 BA-POMDPs", "text": "Most research concerning POMDPs has considered the task of planning: given a full specification of the model, determine an optimal policy (e.g., [8, 14]). However, in many real-world applications, the model is not (perfectly) known in advance, which means that the agent has to learn about its environment during execution. This is the task considered in reinforcement learning (RL) [16].\nA fundamental RL problem is the difficulty of deciding whether to select actions in order to learn a better model of the environment, or to exploit the current knowledge about the rewards and effects of actions. In recent years, Bayesian RL methods have become popular because they can provide a principled solution to this exploration/exploitation tradeoff [19, 5, 6, 10, 18].\nIn particular, we consider the framework of Bayes-Adaptive POMDPs [11, 13]. BA-POMDPs use Dirichlet distributions to model uncertainty over transitions and observations2 (typically assuming the reward function is chosen by the designer and is known). In particular, if the agent could observe both states and observations, it could maintain a vector \u03c7 with the counts of the occurrences for all \u3008s, a, s\u2032, z\u3009 tuples. We write \u03c7s\u2032zsa for the number of times that \u3008s,a\u3009 is followed by \u3008s\u2032,z\u3009.\nWhile the agent cannot observe the states and has uncertainty about the actual count vector, this uncertainty can be represented using regular POMDP formalisms. That is, the count vector is included as part of the hidden state of a specific POMDP, called a BA-POMDP. Formally, a BA-POMDP is a tuple \u3008S\u0304, A, D\u0304, R\u0304, Z, \u03b3, h\u3009 with some modified\n1 This formulation allows for easier notation and generalizes the typical formulation with separate transition T and observation functions O: D = \u3008T,O\u3009. In our experiments, we do employ this typical factorization.\n2 [11, 13] follow the standard T & O POMDP representations, but we use our combined D formalism.\nAlgorithm 1 BA-POMCP(b\u0304,num sims)\n1: //b\u0304 is an augmented belief (e.g., particle filter) 2: h0 \u2190 () . The empty history (i.e., now) 3: for i\u2190 1 . . . num sims do 4: //First, we root sample an (augmented) state: 5: s\u0304\u2190 SAMPLE(b\u0304) . reference to a particle 6: s\u0304\u2032 \u2190 COPY(s\u0304) 7: SIMULATE(s\u0304\u2032, 0, h0) 8: end for 9: a\u2190 GREEDYACTIONSELECTION(h0)\n10: return a\ncomponents in comparison to the POMDP. While the observation and action space remain unchanged, the state (space) of the BA-POMDP now includes Dirichlet parameters: s\u0304 = \u3008s, \u03c7\u3009, which we will refer to as augmented states. The reward model remains the same, since it is assumed to be known, R\u0304(\u3008s\u2032,\u03c7\u2032),a) = R(s,a). The dynamics functions, D\u0304, however, is described in terms of the counts in s\u0304, and is defined as follows\nD\u03c7(s \u2032,z|s, a) , E[D(s\u2032,z|s, a)|\u03c7] = \u03c7 s\u2032z sa\u2211\ns\u2032z \u03c7 s\u2032z sa\n. (1)\nThese expectations can now be used to define the transitions for the BA-POMDP. If we let \u03b4s \u2032z sa denote a vector of the length of \u03c7 containing all zeros except for the position corresponding to \u3008s,a,s\u2032,z\u3009 (where it has a one), and if we let Ia,b denote the Kronecker delta that indicates (is 1 when) a = b, then we can define D\u0304 as D\u0304(s\u2032,\u03c7\u2032,z|s,\u03c7, a) = D\u03c7(s\n\u2032,z|s, a)I\u03c7\u2032,\u03c7+\u03b4s\u2032zsa . Remember that these counts are not observed by the agent, since that would require observations of the state. The agent can only maintain belief over these count vectors. Still, when interacting with the environment, the ratio of the true\u2014but unknown\u2014count vectors will converge to coincide with the true transition and observation probabilities in expectation. It is important to realize, however, that this convergence of count vector ratios does not directly imply learnability by the agent: even though the ratio of the count vectors of the true hidden state will converge, the agent\u2019s belief over count vectors might not.\nBA-POMDPs are infinite state POMDP models and thus extremely difficult to solve. Ross et al. [13] introduced a technique to convert such models to finite models, but these are still very large. Therefore, Ross et al. propose a simple lookahead planner to solve BA-POMDPs in an online manner. This approach approximates the expected values associated with each action at the belief by applying a lookahead search of depth d. This method will function as the comparison baseline in our experiments, as no other BA-POMDP solution methods have been proposed."}, {"heading": "3 BA-POMDPs via Sample-based Planning", "text": "Powerful methods, such as POMCP [15], have significantly improved the scalability of POMDP solution methods. At the same time the most practical solution method for BA-POMDPs, the aforementioned lookahead algorithm, is quite limited in dealing with larger problems. POMDP methods have rarely been applied to BA-POMDPs [1], and no systematic investigation of their performance has been conducted. In this paper, we aim to address this void, by extending POMCP to BA-POMDPs, in an algorithm that we refer to as BA-POMCP. Moreover, we propose a number of novel adaptations to BA-POMCP that exploit the structure of the BA-POMDP. In this section, we first lay out the basic adaptation of POMCP to BA-POMDPs and then describe the proposed modifications that improve its efficiency.\nBA-POMCP BA-POMCP, just like POMCP, constructs a lookahead tree through simulated experiences (Algorithm 1). In BA-POMDPs, however, the dynamics of the system are inaccessible during simulations, and the belief is a probability distribution over augmented states. BA-POMCP, as a result, must sample augmented states from the belief b\u0304, and use copies of those states (s\u0304 = \u3008s,\u03c7\u3009) for each simulation (Algorithm 2). We will refer to this as root sampling of the state (line 6). The copy is necessary, as otherwise the STEP function in Algorithm 2 would alter the belief b\u0304. It is also expensive, for \u03c7 grows with the state, action and observation space, to |S|2 \u00d7 |A| \u00d7 |\u2126| parameters. 3 In practice, this operation becomes a bottleneck to the runtime of BA-POMCP in larger domains.\n3It is |S|2 \u00d7 |A|+ |S| \u00d7 |A| \u00d7 |\u2126| when assuming D is factored in T & O\nAlgorithm 2 SIMULATE(s\u0304, d, h) 1: if ISTERMINAL(h) || d == max depth then 2: return 0 3: end if 4: //Action selection uses statistics stored at node h: 5: a\u2190 UCBACTIONSELECTION(h) 6: R\u2190 R(s\u0304,a) 7: z \u2190 STEP(s\u0304, a) //modifies s\u0304 to sampled next state 8: h\u2032 \u2190 (h,a,z) 9: if h\u2032 \u2208 Tree then 10: r \u2190 R+ \u03b3 SIMULATE(s\u0304, d+ 1, h\u2032) 11: else 12: CONSTRUCTNODE(h\u2032) //Initializes statistics 13: r \u2190 R+ \u03b3 ROLLOUT(s\u0304, d+ 1, h\u2032) 14: end if 15: //Update statistics: 16: N(h,a)\u2190 N(h,a) + 1 17: Q(h,a)\u2190 N(h,a)\u22121\nN(h,a) Q(h,a) + 1 N(h,a) r\n18: return r\nAlgorithm 3 BA-POMCP-STEP(s\u0304 = \u3008s, \u03c7\u3009, a) 1: Dsa \u223c \u03c7sa 2: \u3008s\u2032,z\u3009 \u223c Dsa 3: //In place updating of s\u0304 = \u3008s, \u03c7\u3009 4: \u03c7s \u2032z sa \u2190 \u03c7s \u2032z sa + 1\n5: s\u2190 s\u2032 6: return z\nTo apply POMCP on BA-POMDPs, where the dynamics are unknown, we modify the STEP function, proposing several variants. The most straightforward one, BA-POMCP-STEP is employed in what we refer to as \u2018BA-POMCP\u2019. This method, shown in Algorithm 3, is similar to BA-MCP [7]: essentially, it samples a dynamic model Dsa which specifies probabilities Pr(s\u2032,z|s,a) and subsequently samples an actual next state and observation from that distribution. Note that the underlying states and observations are all represented simply as an index, and hence the assignment on line 5 is not problematic. However, the cost of the model sampling operation in line 1 is.\nRoot Sampling of the Model BA-MCP [7] addresses the fully observable BRL problem by using POMCP on an augmented state s\u0304 = \u3008s, T \u3009, consisting of the observable state, as well as the hidden true transition function T . Application of POMCP\u2019s root sampling of state in this case leads to \u2018root sampling of a transition function\u2019: Since the true transition model T does not change during the simulation, one is sampled at the root and used during the entire simulation. In the BA-POMCP case, root sampling of a state s\u0304 = \u3008s, \u03c7\u3009 does not lead to a same interpretation: no model, but counts are root sampled and they do change over time.\nWe use this as inspiration to introduce a similar, but clearly different, (since this is not root sampling of state) technique called root sampling of the model (which we will refer to as just \u2018root sampling\u2019). The idea is simple: every time we root sample a state s\u0304 = \u3008s, \u03c7\u3009 \u223c b\u0304 at the beginning of a simulation (line 5 in Algorithm 1), we directly sample a D\u0307 \u223c Dir(\u03c7), which we will refer to as the root-sampled model D\u0307 and it is used for the rest of the simulation.\nWe denote this root sampling in BA-POMCP as \u2018R-BA-POMCP\u2019. The approach is formalized by R-BA-POMCPSTEP (Algorithm 4). Note that no count updates take place (cf. line 4 in Algorithm 3). This highlights an important advantage of this technique: since the counts are not used in the remainder of the simulation, the copy of counts (as part of line 6 of Algorithm 1) can be avoided altogether. Since this copy operation is costly, especially in larger domains, where the number of states, action and observations and the number of counts is large, this can lead to significant savings. Finally, we point out that, similar to what Guez et al. [7] propose, D\u0307 can be constructed lazily: the part of the model D\u0307 is only sampled when it becomes necessary.\nThe transition probabilities during R-BA-POMCP differ from those in BA-POMCP, and it is not obvious that a policy based on R-BA-POMCP maintains the same guarantees. We prove in Section 4 that the solution of R-BAPOMCP in the limit converges to that of BA-POMCP.\nAlgorithm 4 R-BA-POMCP-STEP (s\u0304 = \u3008s, \u03c7\u3009, a) 1: //Sample from the root sampled model 2: s\u2032,z \u223c D\u0307s,a 3: s\u2190 s\u2032 4: return z\nAlgorithm 5 E-BA-POMCP-STEP(s\u0304 = \u3008s, \u03c7\u3009, a) 1: //Sample from the Expected model 2: s\u2032,z \u223c D\u03c7(\u00b7, \u00b7|s,a) 3: \u03c7s \u2032z sa \u2190 \u03c7s \u2032z sa + 1\n4: s\u2190 s\u2032 5: return z\nExpected models during simulations The second, complementary, adaptation modifies the way models are sampled from the root-sampled counts in STEP. This version samples the transitions from the expected dynamics D\u03c7 given in (1), rather than from a sampled dynamics function D \u223c Dir(\u03c7). The latter operation is relatively costly, while constructing D\u03c7 is very cheap. In fact, this operation is so cheap, that it is more efficient to (re-)calculate it on the fly rather than to actually store D\u03c7. This approach is shown in Algorithm 5.\nLinking States Lastly, we propose a specialized data structure to encode the augmented BA-POMDP states. The structure aims to optimize for the complexity of the count-copy operation in line 6 of Algorithm 1 while allowing modifications to s\u0304. The linking state sl is a tuple of a system state, a pointer (or link) to an unmodifiable set of counts \u03c7 and a set of updated counts \u3008s, l, \u03b4\u3009. l is a pointer to some set of counts \u03c7, which remain unchanged during count updates (such as in the STEP function), and instead are stored in the set of updated counts, \u03b4, as shown in Algorithm 6. The consequence is that the linking state copy-operation can safely perform a shallow copy of the counts \u03c7, and must only consider \u03b4, which is assumed to be much smaller.\nLinking states can be used during the (rejection-sample-based) belief update at the beginning of each real time step. While the root-sampled augmented states (including \u03b4 in linking states) are typically deleted at the end of each simulation during L-BA-POMCP, each belief update potentially increases the size of \u03b4 of each particle. Theoretically, the number of updated counts represented in \u03b4 increases and the size of \u03b4 may (eventually) grow similar to the size of \u03c7. Therefore, at some point, it is necessary to construct a new \u03c7\u2032 that combines \u03c7 and \u03b4 (after which \u03b4 can be safely emptied). We define a new parameter for the maximum size of \u03b4, \u03bb, and condition to merge only if the size of \u03b4 exceeds \u03bb. We noticed that, in practice, the number of merges is much smaller than the amount of copies in BA-POMCP. We also observed in our experiments that it is often the case that a specific (small) set of transitions are notably more popular than others and that \u03b4 grows quite slowly."}, {"heading": "4 Theoretical Analysis", "text": "Here, we analyze the proposed root sampling of the dynamics function and expected transition techniques, and demonstrate they converge to the solution of the BA-POMDP. These main steps of this proof are similar to those in [15]. We point out however, that the technicalities of proving the components are far more involved.\nThe convergence guarantees of the original POMCP method are based on showing that, for an arbitrary rollout policy \u03c0, the POMDP rollout distribution (the distribution over full histories when performing root sampling of state) is equal to the derived MDP rollout distribution (the distribution over full histories when sampling in the belief MDP). Given that these are identical it is easy to see that the statistics maintained in the search tree will converge to the same number in expectation. As such, we will show a similar result here for expected transitions (\u2018expected\u2019 for short) and root sampling of the dynamics function (\u2018root sampling\u2019 below).\nWe define H0 as the full history (also including states) at the root of simulation, Hd as the full history of a node at depth d in the simulation tree, and \u03c7(Hd) as the counts induced by Hd. We then define the rollout distributions:\nDefinition 1. The expected full-history expected transition BA-POMDP rollout distribution is the distribution over full histories of a BA-POMDP, when performing Monte-Carlo simulations according to a policy \u03c0. It is given by\nP\u03c0(Hd+1) = D\u03c7(Hd)(sd+1,zd+1|as,sd)\u03c0(ad|hd)P \u03c0(Hd) (2)\nwith P\u03c0(H0) = b0(\u3008s0,\u03c70\u3009) the belief \u2018now\u2019 (at the root of the online planning).\nAlgorithm 6 L-BA-POMCP-STEP(sl = \u3008s, l, \u03b4\u3009, a) 1: D \u223c \u3008l, \u03b4\u3009 2: s\u2032,z \u223c Ds,a 3: s\u2190 s\u2032 4: \u03b4s \u2032z sa \u2190 \u03b4s \u2032z sa + 1\n5: return z\nNote that there are two expectations in the above definition: \u2018expected transitions\u2019 mean that transitions for a history Hd are sampled from D\u03c7(Hd). The other \u2018expected\u2019 is the expectation of those samples (and it is easy to see that this will converge to the expected transition probabilities D\u03c7(Hd)(sd+1,zd+1|as,sd)). For root sampling of the dynamics model, this is less straightforward, and we give the definition in terms of the empirical distribution:\nDefinition 2. The empirical full-history root-sampling (RS) BA-POMDP rollout distribution is the distribution over full histories of a BA-POMDP, when performing Monte-Carlo simulations according to a policy \u03c0 in combination with root sampling of the dynamics model D. This distribution, for a particular stage d, is given by\nP\u0303\u03c0K(Hd) , 1\nKd Kd\u2211 i=1 I{ Hd=H (i) d\n}, where\n\u2022 K is the number of simulations that comprise the empirical distribution, \u2022 Kd is the number of simulations that reach depth d (not all simulations might be equally long), \u2022 H(i)d is the history specified by the i-th particle at stage d.\nNow, our main theoretical result is that these distributions are the same in the limit of the number of simulations:\nTheorem 3. The full-history RS-BA-POMDP rollout distribution (Def. 2) converges in probability to the quantity of Def. 1:\n\u2200Hd P\u0303\u03c0Kd(Hd) p\u2192 P\u03c0(Hd). (3)\nProof. The proof is listed in appendix A.\nCorollary 4. Given suitably chosen exploration constant (e.g., c > Rmax1\u2212\u03b3 ), BA-POMCP with root-sampling of dynamics function converges in probability to the expected transition solution.\nProof. Since Theorem 3 guarantees the distributions over histories are the same in the limit, they will converge to the same values maintained in the tree.\nFinally, we see that these are solutions for the BA-POMDP:\nCorollary 5. BA-POMCP with expected transitions sampling, as well as with root sampling of dynamics function converge to an -optimal value function of a BA-POMDP: V (\u3008s,\u03c7\u3009 ,h) p\u2192 V \u2217 (\u3008s,\u03c7\u3009 ,h), where =\nprecision 1\u2212\u03b3 .\nProof. A BA-POMDP is a POMDP, so the analysis from Silver and Veness [15] applies to the BA-POMDP, which means that the stated guarantees hold for BA-POMCP. The BA-POMDP is stated in terms of expected transitions, so the theoretical guarantees extend to the expected transition BA-POMCP, which in turn via corollary 4 implies that the theoretical guarantees extend to RS-BA-POMCP.\nFinally, we note that linking states does not affect they way that sampling is performed at all:\nProposition 6. Linking states does not affect convergence of BA-POMCP."}, {"heading": "5 Empirical Evaluation", "text": "Experimental setup In this section, we evaluate our algorithms on a small toy problem, the well-known Tiger problem [3] and test scalability on a larger domain: the Partially Observable Sysadmin (POSysadmin) problem. In POSysadmin, the agent acts as a system administrator with the task of maintaining a network of n computers. Computers are either \u2018working\u2019 or \u2018failing\u2019, which can be deterministically resolved by \u2018rebooting\u2019 the computer. The agent does not know the state of any computer, but can \u2018ping\u2019 any individual computer. At each step, any of the computers can \u2018fail\u2019 with some probability f . This leads to a state space of size 2n, an action space of 2n+ 1, where the agent can \u2018ping\u2019 or \u2018reboot\u2019 any of the computers, or \u2018do nothing\u2019, and an observation space of 3 ({NULL, failing, working}). The \u2018ping\u2019 action has a cost of 1 associated with it, while rebooting a computer costs 20 and switches the computer to \u2018working\u2019. Lastly, each \u2018failing\u2019 computer has a cost of 10 at each time step.\nWe conducted an empirical evaluation with aimed for 3 goals: The first goal attempts to support the claims made in Section 4 and show that the adaptations to BA-POMCP do not decrease the quality of the resulting policies. Second, we investigate the runtime of those modifications to demonstrate their contribution to the efficiency of BA-POMCP. The last part contains experiments that directly compare the performance per action selection time with the baseline approach of Ross et al. [13]. For brevity, Table 1 describes the default parameters for the following experiments. It will be explicitly mentioned whenever different values are used.\nBA-POMCP variants Section 4 proves that the solutions of the proposed modifications (root-sampling (R-), expected models (E-) and linking states (L-)) in the limit converge to the solution of BA-POMCP. Here, we investigate the behaviour of these methods in practice. For the Tiger problem, the agent\u2019s initial belief over the transition model is correct (i.e., counts that correspond to the true probabilities with high confidence), but it provides an uncertain belief that underestimates the reliability of the observations. Specifically, it assigns 5 counts to hearing the correct observation and 3 counts to incorrect: the agent initially beliefs it will hear correctly with a probability of 62.5%. The experiment is run for with 100, 1000 & 1000 simulations and all combinations of BA-POMCP adaptations.\nFigure 1a plots the average return over 10000 runs for a learning period of 100 episodes for Tiger. The key\nobservation here is two-fold. First, all methods improve over time through refining their knowledge about D. Second, there are three distinct clusters of lines, each grouped by the number of simulations. This shows that all 3 variants (R/L/E-BA-POMCP) lead to the same results.\nWe repeat this investigation with the (3-computer) POSysadmin problems, where we allow 100 simulations per time step. In this configuration, the network was fully connected with a failure probability f = 0.1. The (deterministic) observation function is assumed known a priori, but the prior over the transition function is noisy as follows: for each count c, we take the true probability of that transition (called p) and (randomly) either subtract or add .15. Note that we do not allow transitions with non-zero probability to fall below 0 by setting those counts to 0.001. Each Dirichlet distribution is then normalized the counts to sum to 20. With 3 computers, this results in |S| \u00d7 |A| = 8\u00d7 7 = 56 noisy Dirichlet distributions of |S| = 8 parameters.\nFigure 1b shows how each method is able to increase its performance over time for POSysadmin. Again, the proposed modifications do not seem to alter the solution quality for a specific number of simulations.\nBA-POMCP scalability While the previous experiments indicate that the three adaptations produce equally good policies, they do not support any of the efficiency claims made in Section 3. Here, we compare the scalability of BA-POMCP on the POSysadmin problem. The proposed BA-POMCP variants are repeatedly run for 100 episodes on instances of POSysadmin of increasing network size (3 to 10 computers), and we measure the average action selection time required for 1000 simulations. Note that the experiments are capped to allow up to 5 seconds per action selection, demonstrating the problem size that a specific method can perform 1000 simulations in under 5 seconds.\nFigure 2 shows that BA-POMCP takes less than 0.5 seconds to perform 1000 simulations on an augmented state with approximately 150 parameters (3 computers), but is quickly unable to solve larger problems, as it requires more than 4 seconds to plan for a BA-POMDP with 200000 counts. BA-POMCP versions with a single adaptation are able to solve the same problems twice as fast, while combinations are able to solve much larger problems with up to 5 million parameters (10 computers). This implies not only that each individual adaptation is able to speed up BA-POMCP, but also that they complement one another.\nPerformance The previous experiments first show that the adaptations do not decrease the policy quality of BAPOMCP and second that the modified BA-POMCP methods improve scalability. Here we put those thoughts together and directly consider the performance relative to the action selection time. In these experiments we take the average return over multiple repeats of 100 episodes and plot them according to the time required to reach such performance. Here BA-POMCP is also directly compared to the baseline lookahead planner by Ross et al. [13].\nFirst, we apply lookahead with depth 1&2 on the Tiger problem under the same circumstance as the first experiment for increasing number of particles (25, 50, 100, 200 & 500), which determines the runtime. The resulting average episode return is plotted against the action selection time in Figure 3a.\nThe results show that most methods reach near optimal performance after 0.5 seconds action selection time. R-BAPOMCP and E-R-BA-POMCP perform worse than their counterparts BA-POMCP and E-BAPOMCP, which suggests that root sampling of the dynamics actually slows down BA-POMCP slightly. This phenomenon is due to the fact that the Tiger problem is so small, that the overhead of copying the augmented state and re-sampling of dynamics (during\n(a) The average return over 100 episodes per action selection time of on the Tiger problem\n(b) The average return over 100 episodes per action selection time of BA-POMCP on the POSysadmin problem\nSTEP function) that root sampling avoids is negligible and does overcome the additional complexity of root sampling. Also note that, even though the Tiger problem is so trivial that a lookahead of depth 1 suffices to solve the POMDP problem optimally, BA-POMCP still consistently outperforms this baseline.\nThe last experiment shows BA-POMCP and lookahead on the POSysadmin domain with 6 computers (which contains 55744 counts) with a failure rate of 0.05. The agent was provided with an accurate belief \u03c7.4 The results are shown in Figure 3b.\nWe were unable to get lookahead search to solve this problem: the single instance which returned results in a reasonable amount of time (the single dot in the lower right corner) was with a lookahead depth of 1 (which is insufficient for this domain) with just 50 particles. BA-POMCP, however, was able to perform up to 4096 simulations within 5 seconds and reach an average return of approximately \u2212198, utilizing a belief of 1000 particles. The best performing method, L-R-E-BA-POMCP requires less than 2 seconds for similar results, and is able to reach approximately \u2212190 in less than 3 seconds. Finally, we see that each of the individual modifications outperform the original BA-POMCP, where Expected models seems to be the biggest contributor."}, {"heading": "6 Conclusion", "text": "This paper provides a scalable framework for learning in Bayes-Adaptive POMDPs. BA-POMDPs give a principled way of balancing exploration and exploiting in RL for POMDPs, but previous solution methods have not scaled to non-trivial domains. We extended the Monte Carlo Tree Search method POMCP to BA-POMDPs and described three modifications\u2014Root Sampling, Linking States and Expected Dynamics models\u2014 to take advantage of BA-POMDP structure. We proved convergence of the techniques and demonstrated that our methods can generate high-quality solutions on significantly larger problems than previous methods in the literature."}, {"heading": "Acknowledgements", "text": "Research supported by NSF grant #1664923 and NWO Innovational Research Incentives Scheme Veni #639.021.336.\n4 We do not use the same prior as in the first BA-POMCP variants experiments since this gives uninformative results due to the fact that solution methods convergence to the optimal policy with respect to the (noisy) belief, which is different from the one with respect to the true model."}, {"heading": "A Proof of Theorem 3", "text": "While RS-BA-POMCP is potentially more efficient, it is not directly clear whether it still converges to an -optimal value function. Here we show that the method is sound by showing that, when using root sampling of the model, the distribution over full histories (including states, actions and observations) will converge in probability to the same distribution when not using this additional root sampling step."}, {"heading": "Notation", "text": "We will give an concise itemized description of the used notation."}, {"heading": "Action-observation histories.", "text": "\u2022 hd is an action-observation history at depth d of a simulation. \u2022 hd = (a0,z1, . . . ,ad\u22121,zd).\n\u2018Full\u2019 histories. In addition to actions and observations, full histories also include the states. \u2022 H0 is the (unknown) full history (of real experience) at the root of the simulation: i.e., if there have been k steps of\n\u2018real\u2019 experience H0 = (s\u2212k,a\u2212k,s\u2212k+1,z\u2212k\u22121, . . . ,a\u22121,s0,z0). \u2022 Hd is a full history (of simulated experience) at depth d in the lookahead tree: Hd = (H0,a0,s1,z1,a1,s2,z2, . . . ,ad\u22121,sd,zd) =\n(Hd\u22121,ad\u22121,sd,zd) = \u3008H0,s0:d,hd\u3009. \u2022 H(i)d is the full history at depth d corresponding to simulation i. \u2022 In our proof, we will also need to indicate if a particular full history Hd is consistent with a full history at the root\nof simulation:\nCons(H0,Hd) = { 1 if Hd is consistent with the full history at the root H0 , 0 otherwise.\nDynamics Function. We fold transition and observations function into one: \u2022 D denotes the dynamics model. \u2022 Dstztst\u22121at\u22121 = D s\u2032z sa = Dst\u22121,at\u22121(st,zt) = D(st,zt|st\u22121,at\u22121) = Pr(st,zt|st\u22121,at\u22121).\n\u2022 Dsa denotes the vector: \u2329 Ds 1z1 sa , . . . ,D s|S|z|Z| sa \u232a ."}, {"heading": "Counts.", "text": "\u2022 \u03c7s\u2032zsa denotes how often \u3008s\u2032,z\u3009 occurred after \u3008s,a\u3009. \u2022 \u03c7sa is the vector of counts for \u3008s,a\u3009. \u2022 \u03c7 = \u3008\u03c7s1a1 , . . . ,\u03c7s|S|a|A|\u3009 is the total collection of all such count vectors. \u2022 \u03c7(Hd) denotes the vector of counts at simulated full history Hd. \u2022 If \u03c70 = \u03c7(H0) is the count vector at the root of simulation, we have that \u03c7(Hd) = \u03c70 + \u2206(Hd), with \u2206(Hd) the\nvector of counts of all (s,a,s\u2032,z) quadruples occurring in Hd since the root of simulation (after H0)."}, {"heading": "Dirichlet distributions.", "text": "\u2022 Let x = \u3008x1 . . . xK\u3009 \u2208 \u2206K and \u03b1 = \u3008\u03b11 . . . \u03b1K\u3009 be a count vector, then we write Dir(x|\u03b1) = Pr(x;\u03b1) = B(\u03b1) \u220fK i=1 x \u03b1i\u22121 i , with B(\u03b1) = \u0393( \u2211 i \u03b1i)\u220f\ni \u0393(\u03b1i) the Dirichlet normalization constant, with \u0393 the gamma function.\n\u2022 So, in translated in terms of dynamics function and counts, we have:\n\u2013 for a particular s,a: Dir(Dsa|\u03c7sa) = Pr(Dsa;\u03c7sa) = B(\u03c7sa) \u220f \u3008s\u2032,z\u3009\u2208S\u00d7Z ( Ds \u2032z sa )\u03c7s\u2032zsa \u22121 .\n\u2013 we will also abuse notation and write Dir(D|\u03c7) = \u220f \u3008s,a\u3009Dir(Dsa|\u03c7sa)."}, {"heading": "Var.", "text": "\u2022 x\u0307 denotes a root sampled quantity x. \u2022 I{condition} is the indicator function which is 1 iff condition is true and 0 otherwise."}, {"heading": "Definitions", "text": "Definition 7. The expected full-history expected transition BA-POMDP rollout distribution is the distribution over full histories of a BA-POMDP, when performing Monte-Carlo simulations according to a policy \u03c0. It is given by\nP\u03c0(Hd+1) = D\u03c7(Hd)(sd+1,zd+1|as,sd)\u03c0(ad|hd)P \u03c0(Hd) (4)\nwith P\u03c0(H0) = b0(\u3008s0,\u03c70\u3009) the belief \u2018now\u2019 (at the root of the online planning).\nDefinition 8. The empirical full-history root-sampling (RS) BA-POMDP rollout distribution is the distribution over full histories of a BA-POMDP, when performing Monte-Carlo simulations according to a policy \u03c0 in combination with root sampling of the dynamics model D. This distribution, for a particular stage d, is given by\nP\u0303\u03c0K(Hd) , 1\nKd Kd\u2211 i=1 I{ Hd=H (i) d\n}, where\n\u2022 K is the number of simulations that comprise the empirical distribution. \u2022 Kd is the number of simulations that reach depth d (not all simulations might be equally long). \u2022 H(i)d is the history specified by the i-th particle at stage d.\nRemark: throughout this proof we assume that there is only 1 initial count vector at the root. Or put better: we assume that there is one unique H0 at which all simulations start. However, for \u2018real\u2019 steps t > 0 we could be in different Hrealt all corresponding to the same observed real history h real t . In this case, root sampling from the belief can be thought of root sampling the initial full history H0 \u223c b(Hrealt ). As such, our proof shows convergence in probability of\n\u2200H0\u2200Hd P\u0303\u03c0Kd(Hd|H0) p\u2192 P\u03c0(Hd|H0).\nfor each such sampled H0. It is clear that that directly implies that \u2200Hd P\u0303\u03c0Kd(Hd) = EH0 [ P\u0303\u03c0Kd(Hd|H0) ] p\u2192 EH0 [P\u03c0(Hd|H0)] = P\u03c0(Hd).\nIn the below, we omit the explicit conditioning on H0."}, {"heading": "Proof of Main Theorem", "text": "The proof depends on a lemma that follows below.\nTheorem 9. The full-history RS-BA-POMDP rollout distribution (Def. 8) converges in probability to full-history BAPOMDP rollout distribution (Def. 7):\n\u2200Hd P\u0303\u03c0Kd(Hd) p\u2192 P\u03c0(Hd). (5)\nProof. For ease of notation we prove this for stage d+ 1. Note that a history Hd+1 = (Hd,ad,sd+1,zd+1), only differs from Hd in that it has one extra transition for the (sd,ad,sd+1,zd+1) quadruple, implying that \u03c7(Hd+1) only differs from \u03c7(Hd) in the counts \u03c7sdad for sdad. Therefore, the expression for P\u0303 \u03c0 Kd\n(Hd) derived in Lemma 10 below (cf. equation (23)) can be written in recursive form as\nP\u0303\u03c0(Hd+1) = Cons(H0,Hd) d\u220f t=0 \u03c0(at|ht) \u220f \u3008s,a\u3009 B(\u03c7sa(H0)) B(\u03c7sa(Hd+1))\n= Cons(H0,Hd) d\u22121\u220f t=0 \u03c0(at|ht)\u03c0(ad|hd) \u220f \u3008s,a\u3009 B(\u03c7sa(H0)) B(\u03c7sa(Hd)) B(\u03c7sa(Hd)) B(\u03c7sa(Hd+1)) = Cons(H0,Hd) d\u22121\u220f t=0 \u03c0(at|ht)\u03c0(ad|hd) \u220f \u3008s,a\u3009 B(\u03c7sa(H0)) B(\u03c7sa(Hd)) \u220f \u3008s,a\u3009 B(\u03c7sa(Hd)) B(\u03c7sa(Hd+1))\n =\nCons(H0,Hd) d\u22121\u220f t=0 \u03c0(at|ht) \u220f \u3008s,a\u3009 B(\u03c7sa(H0)) B(\u03c7sa(Hd)) \u03c0(ad|hd) B(\u03c7sdad(Hd)) B(\u03c7sdad(Hd+1))\n= P\u0303\u03c0(Hd)\u03c0(ad|hd) B(\u03c7sdad(Hd))\nB(\u03c7sdad(Hd+1))\nwith base case P\u0303\u03c0(H0) = 1, and\nB(\u03c7sdad(Hd))\nB(\u03c7sdad(Hd+1)) =\nB(\u03c7sdad(H0)) B(\u03c7sdad(Hd+1)) \u00b7 B(\u03c7sdad(Hd)) B(\u03c7sdad(H0)) = B(\u03c7sdad(H0))/B(\u03c7sdad(Hd+1)) B(\u03c7sdad(H0))/B(\u03c7sdad(Hd)) (6)\nthe result of dividing out the contribution of the old counts for sdad and multiplying in the new contribution. Now, we investigate these terms more closely.\nAgain remember that the sole difference between Hd+1 = (Hd,ad,sd+1,zd+1) and Hd is that it has one extra transition for the (sd,ad,sd+1,zd+1) quadruple. Let us write T = \u2211 (s\u2032,z) \u03c7 s\u2032z sdad\n(Hd) for the total of the counts for sd,ad and N = \u03c7sd+1zd+1sdad (Hd) for the number of counts for that such a transition was to (sd+1zd+1). Because Hd+1 only has 1 extra transition, we also know that for this history, the total counts is one higher: \u2211 (s\u2032,z) \u03c7 s\u2032z sdad (Hd+1) = T + 1 and since that transition was to (sd+1zd+1) the counts \u03c7 sd+1zd+1 sdad (Hd+1) = N + 1. Now let us expand the term from (6):\nB(\u03c7sdad(Hd))\nB(\u03c7sdad(Hd+1)) =\n\u0393(T )/ \u220f s\u2032z \u0393(\u03c7 s\u2032z sdad (Hd))\n\u0393(T + 1)/ \u220f s\u2032z \u0393(\u03c7 s\u2032z sdad (Hd+1))\n= \u0393(T )\n\u0393(T + 1)\n\u220f s\u2032z \u0393(\u03c7 s\u2032z sdad\n(Hd+1))\u220f s\u2032z \u0393(\u03c7 s\u2032 sdad (Hd))\n= \u0393(T )\n\u0393(T + 1)\n\u0393(\u03c7 sd+1zd+1 sdad (Hd+1)) \u220f s\u2032z 6=(sd+1zd+1) \u0393(\u03c7 s\u2032z sdad (Hd+1))\n\u0393(\u03c7 sd+1zd+1 sdad (Hd)) \u220f s\u2032z 6=(sd+1zd+1) \u0393(\u03c7 s\u2032z sdad (Hd))\n= \u0393(T )\n\u0393(T + 1)\n\u0393(\u03c7 sd+1zd+1 sdad (Hd+1))\n\u0393(\u03c7 sd+1zd+1 sdad (Hd))\n= \u0393(T )\n\u0393(T + 1)\n\u0393(N + 1)\n\u0393(N)\nNow, the gamma function has the property that \u0393(x+ 1) = x\u0393(x) [4], which means that we get\n= \u0393(T )\nT\u0393(T )\nN\u0393(N) \u0393(N) = N T .\nTherefore we get B(\u03c7sdad(Hd))\nB(\u03c7sdad(Hd+1)) =\n\u03c7 sd+1zd+1 sdad (Hd)\u2211\n(s\u2032,z) \u03c7 s\u2032z sdad (Hd)\nand thus\nP\u0303\u03c0(Hd+1) = P\u0303 \u03c0(Hd)\u03c0(ad|hd)\n\u03c7 sd+1zd+1 sdad (Hd)\u2211\n(s\u2032,z) \u03c7 s\u2032z sdad (Hd) . (7)\nthe r.h.s. of this equation is identical to (4) except for the difference in between P\u0303\u03c0(Hd) and P\u03c0(Hd). This can be resolved by forward induction with base step: P\u0303\u03c0(H0) = b0(\u3008s0,\u03c70,\u03c80\u3009) = P\u03c0(H0), and the induction step (show P\u0303\u03c0(Hd+1) = P\n\u03c0(Hd+1) given P\u0303\u03c0(Hd) = P\u03c0(Hd)) directly following from (4) and (7). Therefore we can conclude that \u2200d P\u0303\u03c0(Hd) = P\u03c0(Hd).\nSince Lemma 10 establishes that \u2200Hd P\u0303\u03c0Kd(Hd) p\u2192 P\u0303\u03c0(Hd), we directly have\n\u2200Hd P\u0303\u03c0Kd(Hd) p\u2192 P\u03c0(Hd),\nthus proving the result.\nThe proof depends on the following lemma:\nLemma 10. The full-history RS-BA-POMDP rollout distribution converges in probability to the following quantity:\n\u2200Hd P\u0303\u03c0Kd(Hd) p\u2192 b0(s0) [ d\u220f t=1 \u03c0(at\u22121|ht\u22120) ]\u220f \u3008s,a\u3009 B(\u03c7sa(H0)) B(\u03c7sa(Hd)  (8) with B(\u03b1) = \u0393(\u03b11+...\u00b7+\u03b1k)\u0393(\u03b11)\u00b7...\u00b7\u0393(\u03b1k) the normalization term of a Dirichlet distribution with parametric vector \u03b1.\nProof. Via the weak law of large numbers, we have that the empirical mean of a random variable converges in probability to its expectation.\n\u2200Hd P\u0303\u03c0Kd(Hd) p\u2192 1 Kd Kd\u2211 i=1 I{ Hd=H (i) d } p\u2192 E [ I{ Hd=H (i) d }] This expectation can be rewritten as follows\nE [ I{ Hd=H (i) d }] = \u2211 H\n(i) d\nP\u0303\u03c0 ( H\n(i) d ) I{ Hd=H (i) d } = P\u0303\u03c0 (Hd) (9)\nwhere P\u0303\u03c0(Hd) denotes the (true, non-empirical) probability that the RS-BA-POMDP rollout generates full historyHd. This is an expectation over the root sampled model D\u0307:\nP\u0303\u03c0(Hd) = \u222b P\u0303\u03c0 ( Hd|D\u0307 ) Dir(D\u0307|\u03c7\u0307)dD\u0307 (10)\n= \u222b [ Cons(H0,Hd)\nd\u220f t=1 D\u0307(st,zt|st\u22121,at\u22121)\u03c0(at\u22121|ht\u22121)\n] Dir(D\u0307|\u03c7\u0307)dD\u0307 (11)\n= Cons(H0,Hd) [ d\u220f t=1 \u03c0(at\u22121|ht\u22121) ](\u222b [ d\u220f t=1 D\u0307(st,zt|st\u22121,at\u22121) ] Dir(D\u0307|\u03c7\u0307)dD\u0307 ) (12)\nWhere Cons(H0,Hd) is a term that indicates whether (takes value 1 if) Hd is consistent with the full history at the root H0.5\n5An earlier version of this proof ([9]) contained a term b0(s0) instead of Cons(H0,Hd), which fails to recognize that this proof assumes H0 to be fixed. See also the remark on page 11.\nNow we can exploit the fact that only the Dirichlet for the transitions specified by Hd matter.\u222b [ d\u220f t=1 D\u0307(st,zt|st\u22121,at\u22121) ] Dir(D\u0307|\u03c70)dD\u0307 (13) ={split up the integral over one big vector into integrals over smaller vectors}\u222b \u00b7 \u00b7 \u00b7 \u222b [ d\u220f\nt=1\nD\u0307st,ztst\u22121,at\u22121 ]\u220f \u3008s,a\u3009 Dir(D\u0307sa|\u03c7sa(H0))  dD\u0307s1a1 . . . dD\u0307s|S|a|A| (14) ={reorder the transition probabilities: \u2206sas \u2032z \u03c7 (Hd)is the number of occurences of (s,a,s\n\u2032,z)in Hd}\u222b \u00b7 \u00b7 \u00b7 \u222b \u220f\n\u3008s,a\u3009 \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u2206sas\u2032z\u03c7 (Hd)\u220f \u3008s,a\u3009 Dir(D\u0307sa|\u03c7sa(H0))  dD\u0307s1a1 . . . dD\u0307s|S|a|A| (15) = \u222b \u00b7 \u00b7 \u00b7 \u222b \u220f\n\u3008s,a\u3009 \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u2206sas\u2032z\u03c7 (Hd)\u220f \u3008s,a\u3009 B(\u03c7\u0307sa) \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u03c7sas\u2032z0 \u22121 dD\u0307s1a1 . . . dD\u0307s|S|a|A| (16) = \u222b \u00b7 \u00b7 \u00b7 \u222b \u220f\n\u3008s,a\u3009  \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u2206sas\u2032z\u03c7 (Hd)B(\u03c7\u0307sa) \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u03c7sas\u2032z0 \u22121 dD\u0307s1a1 . . . dD\u0307s|S|a|A| (17) = \u222b \u00b7 \u00b7 \u00b7 \u222b \u220f\n\u3008s,a\u3009 B(\u03c7\u0307sa)  \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u2206sas\u2032z\u03c7 (Hd) \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u03c7sas\u2032z0 \u22121 dD\u0307s1a1 . . . dD\u0307s|S|a|A| (18) = \u222b \u00b7 \u00b7 \u00b7 \u222b \u220f\n\u3008s,a\u3009 B(\u03c7\u0307sa) \u220f \u3008s\u2032,z\u3009 ( D\u0307s \u2032z sa )\u03c7sas\u2032z0 \u22121+\u2206sas\u2032z\u03c7 (Hd) dD\u0307s1a1 . . . dD\u0307s|S|a|A| (19) Now we reverse the order of integration and multiplication, which is possible since the different s,a pairs over which we integrate are disjoint.6 We obtain:\n= \u220f \u3008s,a\u3009 B(\u03c7sa(H0)) \u222b \u220f \u3008s\u2032,z\u3009 ( D\u0307sa(s \u2032,z) )\u03c7sas\u2032z0 +\u2206sas\u2032z\u03c7 (Hd)\u22121 dD\u0307sa (20)\n={since we integrate over the entire vector D\u0307sa, the integral equals 1/B(\u03c7sa(H0) + \u2206sa\u03c7 (Hd))}\u220f \u3008s,a\u3009 B(\u03c7sa(H0)) 1 B(\u03c7sa(H0) + \u2206sa\u03c7 (Hd)) (21)\n= \u220f \u3008s,a\u3009 B(\u03c7sa(H0)) B(\u03c7sa(Hd)) (22)\nTherefore\nP\u0303\u03c0(Hd) = Cons(H0,Hd) [ d\u22121\u220f t=0 \u03c0(at|ht) ]\u220f \u3008s,a\u3009 B(\u03c7sa(H0)) B(\u03c7sa(Hd))  , (23) proving (8).\n6E.g, consider two sets A1 = { a (1) 1 ,a (2) 1 } and A2 = { a (1) 2 ,a (2) 2 ,a (3) 2 } . Equation (19) is of the same form as\n\u2211 a1\u2208A1 \u2211 a2\u2208A2 2\u220f i=1 ai = \u2211 a1\u2208A1 \u2211 a2\u2208A2 a1a2 = a (1) 1 a (1) 2 + a (1) 1 a (2) 2 + a (1) 1 a (3) 2 + a (2) 1 a (1) 2 + a (2) 1 a (2) 2 + a (2) 1 a (3) 2\n= a (1) 1 ( a (1) 2 + a (2) 2 + a (3) 2 ) + a (2) 1 ( a (1) 2 + a (2) 2 + a (3) 2 ) = ( a (1) 1 + a (2) 1 )( a (1) 2 + a (2) 2 + a (3) 2 ) =\n \u2211 a1\u2208A1 a1  \u2211 a2\u2208A2 a2  = 2\u220f i=1 \u2211 ai\u2208Ai ai"}], "year": 2018, "references": [{"title": "Scalable planning and learning for multiagent POMDPs", "authors": ["C. Amato", "F.A. Oliehoek"], "venue": "In Proceedings of the TwentyNinth AAAI Conference on Artificial Intelligence,", "year": 2015}, {"title": "Finite-time analysis of the multiarmed bandit problem", "authors": ["P. Auer", "N. Cesa-Bianchi", "P. Fischer"], "venue": "Machine learning,", "year": 2002}, {"title": "Acting optimally in partially observable stochastic domains", "authors": ["A.R. Cassandra", "L.P. Kaelbling", "M.L. Littman"], "venue": "In Proc. of the AAAI Conf. on Artificial Intelligence,", "year": 1994}, {"title": "Optimal Statistical Decisions", "authors": ["M.H. DeGroot"], "venue": "Wiley-Interscience,", "year": 2004}, {"title": "Optimal Learning: Computational procedures for Bayes-adaptive Markov decision processes", "authors": ["M.O. Duff"], "venue": "PhD thesis, University of Massachusetts Amherst,", "year": 2002}, {"title": "Reinforcement learning with kernels and Gaussian processes", "authors": ["Y. Engel", "S. Mannor", "R. Meir"], "venue": "In Proceedings of the ICML Workshop on Rich Representations for Reinforcement Learning,", "year": 2005}, {"title": "Efficient Bayes-adaptive reinforcement learning using sample-based search", "authors": ["A. Guez", "D. Silver", "P. Dayan"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2012}, {"title": "Planning and acting in partially observable stochastic domains", "authors": ["L.P. Kaelbling", "M.L. Littman", "A.R. Cassandra"], "venue": "Artificial intelligence,", "year": 1998}, {"title": "Best response bayesian reinforcement learning for multiagent systems with state uncertainty", "authors": ["F.A. Oliehoek", "C. Amato"], "venue": "In AAMAS Workshop on Multiagent Sequential Decision Making Under Uncertainty,", "year": 2014}, {"title": "Model-based Bayesian reinforcement learning in partially observable domains", "authors": ["P. Poupart", "N.A. Vlassis"], "venue": "In International Symposium on Artificial Intelligence and Mathematics,", "year": 2008}, {"title": "Bayes-Adaptive POMDPs", "authors": ["S. Ross", "B. Chaib-draa", "J. Pineau"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2007}, {"title": "Online planning algorithms for POMDPs", "authors": ["S. Ross", "J. Pineau", "S. Paquet", "B. Chaib-Draa"], "venue": "Journal of Artificial Intelligence Research,", "year": 2008}, {"title": "A Bayesian approach for learning and planning in partially observable Markov decision processes", "authors": ["S. Ross", "J. Pineau", "B. Chaib-draa", "P. Kreitmann"], "venue": "The Journal of Machine Learning Research,", "year": 2011}, {"title": "A survey of point-based POMDP solvers", "authors": ["G. Shani", "J. Pineau", "R. Kaplow"], "venue": "Autonomous Agents and Multi-Agent Systems,", "year": 2012}, {"title": "Monte-Carlo planning in large POMDPs", "authors": ["D. Silver", "J. Veness"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2010}, {"title": "Reinforcement Learning: An Introduction", "authors": ["R.S. Sutton", "A.G. Barto"], "year": 1998}, {"title": "Monte Carlo POMDPs", "authors": ["S. Thrun"], "venue": "In Advances in Neural Information Processing Systems,", "year": 1999}, {"title": "Bayesian reinforcement learning", "authors": ["N. Vlassis", "M. Ghavamzadeh", "S. Mannor", "P. Poupart"], "venue": "In Reinforcement Learning,", "year": 2012}, {"title": "Exploration control in reinforcement learning using optimistic model selection", "authors": ["J.L. Wyatt"], "venue": "In International Conference on Machine Learning,", "year": 2001}], "id": "SP:614b197a11eba3f25337b0c9b9cb409ae6230238", "authors": [{"name": "Sammie Katt", "affiliations": []}, {"name": "Frans A. Oliehoek", "affiliations": []}, {"name": "Christopher Amato", "affiliations": []}], "abstractText": "The POMDP is a powerful framework for reasoning under outcome and information uncertainty, but constructing an accurate POMDP model is difficult. Bayes-Adaptive Partially Observable Markov Decision Processes (BAPOMDPs) extend POMDPs to allow the model to be learned during execution. BA-POMDPs are a Bayesian RL approach that, in principle, allows for an optimal trade-off between exploitation and exploration. Unfortunately, BAPOMDPs are currently impractical to solve for any non-trivial domain. In this paper, we extend the Monte-Carlo Tree Search method POMCP to BA-POMDPs and show that the resulting method, which we call BA-POMCP, is able to tackle problems that previous solution methods have been unable to solve. Additionally, we introduce several techniques that exploit the BA-POMDP structure to improve the efficiency of BA-POMCP along with proof of their convergence.", "title": "Learning in POMDPs with Monte Carlo Tree Search\u2217"}