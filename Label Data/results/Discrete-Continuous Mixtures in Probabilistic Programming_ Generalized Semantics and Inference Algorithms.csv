0,1,label2,summary_sentences
"People vary widely both in their linguistic preferences when producing language and in their ability to understand specific natural-language expressions, depending on what they know about the domain, their age and cognitive capacity, and many other factors.",1 Introduction,[0],[0]
"It has long been recognized that effective NLG systems should therefore adapt to the current user, in order to generate language which works well for them.",1 Introduction,[0],[0]
"This adaptation needs to address all levels of the NLG pipeline, including discourse planning (Paris, 1988), sentence planning (Walker et al., 2007), and RE generation (Janarthanam and Lemon, 2014), and depends on many features of the user, including level of expertise and language proficiency, age, and gender.
",1 Introduction,[0],[0]
Existing techniques for adapting the output of an NLG system have shortcomings which limit their practical usefulness.,1 Introduction,[0],[0]
"Some systems need user-specific information in training (Ferreira and Paraboni, 2014) and therefore cannot generalize to unseen users.",1 Introduction,[0],[0]
"Other systems assume that each user in the training data is annotated with their group, which allows them to learn a model from the data of each group.",1 Introduction,[0],[0]
"However, hand-designed user groups
may not reflect the true variability of the data, and may therefore inhibit the system’s ability to flexibly adapt to new users.
",1 Introduction,[0],[0]
"In this paper, we present a user adaptation model for NLG systems which induces user groups from training data in which these groups were not annotated.",1 Introduction,[0],[0]
"At training time, we probabilistically assign users to groups and learn the language preferences for each group.",1 Introduction,[0],[0]
"At evaluation time, we assume that our system has a chance to interact with each new user repeatedly – e.g., in the context of a dialogue system.",1 Introduction,[0],[0]
"It will then calculate an increasingly accurate estimate of the user’s group membership based on observable behavior, and use it to generate utterances that are suitable to the user’s true group.
",1 Introduction,[0],[0]
We evaluate our model on two tasks involving the generation of referring expressions (RE).,1 Introduction,[0],[0]
"First, we predict the use of spatial relations in humanlike REs in the GRE3D domain (Viethen and Dale, 2010) using a log-linear production model in the spirit of Ferreira and Paraboni (2014).",1 Introduction,[0],[0]
"Second, we predict the comprehension of generated REs, in a synthetic dataset based on data from the GIVE Challenge domain (Striegnitz et al., 2011) with the log-linear comprehension model of Engonopoulos et al. (2013).",1 Introduction,[0],[0]
"In both cases, we show that our model discovers user groups in the training data and infers the group of unseen users with high confidence after only a few interactions during testing.",1 Introduction,[0],[0]
"In the GRE3D domain, our system outperformed a strong baseline which used demographic information for the users.",1 Introduction,[0],[0]
Differences between individual users have a substantial impact on language comprehension.,2 Related Work,[0],[0]
"Factors that play a role include level of expertise and spatial ability (Benyon and Murray, 1993); age (Häuser et al., 2017); gender (Dräger and Koller,
ar X
iv :1
80 6.
",2 Related Work,[0],[0]
"05 94
7v 1
[ cs
.C",2 Related Work,[0],[0]
"L
] 1
5 Ju
n 20
18
2012); or language proficiency (Koller et al., 2010).
",2 Related Work,[0],[0]
Individual differences are also reflected in the way people produce language.,2 Related Work,[0],[0]
"Viethen and Dale (2008) present a corpus study of human-produced REs (GRE3D3) for simple visual scenes, where they note two clearly distinguishable groups of speakers, one that always uses a spatial relation and one that never does.",2 Related Work,[0],[0]
Ferreira and Paraboni (2014) show that a model using speaker-specific information outperforms a generic model in predicting the attributes used by a speaker when producing an RE.,2 Related Work,[0],[0]
"However, their system needs to have seen the particular speaker in training, while our system can dynamically adapt to unseen users.",2 Related Work,[0],[0]
"Ferreira and Paraboni (2017) also demonstrate that splitting speakers in predefined groups and training each group separately improves the human likeness of REs compared to training individual user models.
",2 Related Work,[0],[0]
"The ability to adapt to the comprehension and production preferences of a user is especially important in the context of a dialog system, where there are multiple chances of interacting with the same user.",2 Related Work,[0],[0]
Some methods adapt to dialog system users by explicitly modeling the users’ knowledge state.,2 Related Work,[0],[0]
"An early example is Paris (1988); she selects a discourse plan for a user, depending on their level of domain knowledge ranging between novice and expert, but provides no mechanism for inferring the group to which the user belongs.",2 Related Work,[0],[0]
"Rosenblum and Moore (1993) try to infer what knowledge a user possesses during dialogue, based on the questions they ask.",2 Related Work,[0],[0]
Janarthanam and Lemon (2014) adapt to unseen users by using reinforcement learning with simulated users to make a system able to adjust to the level of the user’s knowledge.,2 Related Work,[0],[0]
"They use five predefined groups from which they generate the simulated users’ behavior, but do not assign real users to these groups.",2 Related Work,[0],[0]
"Our system makes no assumptions about the user’s knowledge and does not need to train with simulated users, or use any kind of information-seeking moves; we instead rely on the groups that are discovered in training and dynamically assign new, unseen users, based only on their observable behavior in the dialog.
",2 Related Work,[0],[0]
"Another example of a user-adapting dialog component is SPaRKy (Walker et al., 2007), a trainable sentence planner that can tailor sentence plans to individual users’ preferences.",2 Related Work,[0],[0]
"This requires training on separate data for each user; in contrast to this, we leverage the similarities between users and can take advantage of the full training data.",2 Related Work,[0],[0]
We start with a basic model of the way in which people produce and comprehend language.,3 Log-linear models for NLG in dialog,[0],[0]
"In order to generalize over production and comprehension, we will simply say that a human language user exhibits a certain behavior b among a range of possible behaviors, in response to a stimulus s.",3 Log-linear models for NLG in dialog,[0],[0]
"The behavior of a speaker is the utterance b they produce in order to achieve a communicative goal s; the behavior of a listener is the meaning b which they assign to the utterance s they hear.
",3 Log-linear models for NLG in dialog,[0],[0]
"Given this terminology, we define a basic loglinear model (Berger et al., 1996) of language use as follows:
P (b|s; ρ) = exp(ρ · φ(b, s))∑ b′",3 Log-linear models for NLG in dialog,[0],[0]
"exp(ρ · φ(b′, s))
",3 Log-linear models for NLG in dialog,[0],[0]
"(1)
where ρ is a real-valued parameter vector of length n and φ(b, s) is a vector of real-valued feature functions f1, ..., fn over behaviors and stimuli.",3 Log-linear models for NLG in dialog,[0],[0]
"The parameters can be trained by maximum-likelihood estimation from a corpus of observations (b, s).",3 Log-linear models for NLG in dialog,[0],[0]
"In addition to maximum-likelihood training it is possible to include some prior probability distribution, which expresses our belief about the probability of any parameter vector and which is generally used for regularization.",3 Log-linear models for NLG in dialog,[0],[0]
"The latter case is referred to as a posteriori training, which selects the value of ρ that maximizes the product of the parameter probability and the probability of the data.
",3 Log-linear models for NLG in dialog,[0],[0]
"In this paper, we focus on the use of such models in the context of the NLG module of a dialogue system, and more specifically on the generation of referring expressions (REs).",3 Log-linear models for NLG in dialog,[0],[0]
"Using (1) as a comprehension model, Engonopoulos et al. (2013) developed an RE generation model in which the stimulus s = (r, c) consists of an RE r and a visual context c of the GIVE Challenge (Striegnitz et al., 2011), as illustrated in Fig. 1.",3 Log-linear models for NLG in dialog,[0],[0]
The behavior is the object b in the visual scene to which the user will resolve the RE.,3 Log-linear models for NLG in dialog,[0],[0]
"Thus for instance, when we consider the RE r =“the blue button” in the context of Fig. 1, the log-linear model may assign a higher probability to the button on the right than to the one in the background.",3 Log-linear models for NLG in dialog,[0],[0]
"Engonopoulos and Koller (2014) develop an algorithm for generating the RE r which maximizes P (b∗|s; ρ), where b∗ is the intended referent in this setting.
",3 Log-linear models for NLG in dialog,[0],[0]
"Conversely, log-linear models can also be used to directly capture how a human speaker would refer to an object in a given scene.",3 Log-linear models for NLG in dialog,[0],[0]
"In this case, the stimulus s = (a, c) consists of the target object a and
the visual context c, and the behavior b is the RE.",3 Log-linear models for NLG in dialog,[0],[0]
"We follow Ferreira and Paraboni (2014) in training individual models for the different attributes which can be used in the RE (e.g., that a is a button; that it is blue; that the RE contains a binary relation such as “to the right of”), such that we can simply represent b as a binary choice b ∈ {1,−1} between whether a particular attribute should be used in the RE or not.",3 Log-linear models for NLG in dialog,[0],[0]
"We can then implement an analog of Ferreira’s model in terms of (1) by using feature functions φ(b, a, c) = b · φ′(a, c), where φ′(a, c) corresponds to their context features, which do not capture any speaker-specific information.",3 Log-linear models for NLG in dialog,[0],[0]
"As discussed above, a user-agnostic model such as (1) does not do justice to the variability of language comprehension and production across different speakers and listeners.",4 Log-linear models with user groups,[0],[0]
We will therefore extend it to a model which distinguishes different user groups.,4 Log-linear models with user groups,[0],[0]
We will not try to model why1 users behave differently.,4 Log-linear models with user groups,[0],[0]
"Instead our model sorts users into groups simply based on the way in which they respond to stimuli, in the sense of Section 3, and implements this by giving each group g its own parameter vector ρ(g).",4 Log-linear models with user groups,[0],[0]
"As a theoretical example, Group 1 might contain users who reliably comprehend REs which use colors (“the green button”), whereas Group 2 might contain users who more easily understand relational REs (“the button next to the lamp”).",4 Log-linear models with user groups,[0],[0]
"These groups are then discovered at training time.
",4 Log-linear models with user groups,[0],[0]
"When our trained NLG system starts interacting with an unseen user u, it will infer the group to which u belongs based on u’s observed responses to previous stimuli.",4 Log-linear models with user groups,[0],[0]
"Thus as the dialogue with u unfolds, the system will have an increasingly pre-
1E.g., in the sense of explicitly modeling sociolects or the difference between novice system users vs. experts.
cise estimate of the group to which u belongs, and will thus be able to generate language which is increasingly well-tailored to this particular user.",4 Log-linear models with user groups,[0],[0]
"We assume training data D = {(bi, si, ui)}i which contains stimuli si together with the behaviors bi which the users ui exhibited in response to si.",4.1 Generative story,[0],[0]
"We write D(u) = {(bu1 , su1), . . .",4.1 Generative story,[0],[0]
"(buN , suN )} for the data points for each user",4.1 Generative story,[0],[0]
"u.
",4.1 Generative story,[0],[0]
"The generative story we use is illustrated in Fig. 2; observable variables are shaded gray, unobserved variables and parameters to be set in training are shaded white and externally set hyperparameters have no circle around them.",4.1 Generative story,[0],[0]
"Arrows indicate which variables and parameters influence the probability distribution of other variables.
",4.1 Generative story,[0],[0]
"We assume that each user belongs to a group g ∈ {1, . . .",4.1 Generative story,[0],[0]
",K}, where the number K of groups is fixed beforehand based on, e.g., held out data.",4.1 Generative story,[0],[0]
"A group g is assigned to u at random from the distribution
P (g|π) = exp(πg)∑K g′=1 exp(πg′)
(2)
",4.1 Generative story,[0],[0]
"Here π ∈ RK is a vector of weights, which defines how probable each group is a-priori.
",4.1 Generative story,[0],[0]
"We replace the single parameter vector ρ of (1) with group-specific parameters vectors ρ(g), thus obtaining a potentially different log-linear model P ( b|s; ρ(g) ) for each group.",4.1 Generative story,[0],[0]
"After assigning a group, our model generates responses bu1 , . . .",4.1 Generative story,[0],[0]
", b u N at
random from P ( b|s; ρ(g) ) , based on the group specific parameter vector and the stimuli su1 , . . .",4.1 Generative story,[0],[0]
", s u N .",4.1 Generative story,[0],[0]
This accounts for the generation of the data.,4.1 Generative story,[0],[0]
"We model the parameter vectors π ∈ RK , and ρ(g) ∈",4.1 Generative story,[0],[0]
"Rn for every 1 ≤ g ≤ K as drawn from
P (D; θ) = ∏ u∈U K∑ g=1",4.1 Generative story,[0],[0]
"P (g|π) · ∏ d∈D(u) P ( bd|sd; ρ(g) ) · N (π|0, σ(π)) · K∏",4.1 Generative story,[0],[0]
g=1 N,4.1 Generative story,[0],[0]
"( ρ(g)|0, σ(ρ) )",4.1 Generative story,[0],[0]
"(3) L(θ) =
∑ u∈U log K∑",4.1 Generative story,[0],[0]
g=1,4.1 Generative story,[0],[0]
P (g|π) · ∏ d∈D(u) P ( bd|sd; ρ(g) ),4.1 Generative story,[0],[0]
"(4)
AL(θ) = ∑ u∈U K∑ g=1
P (g|D(u); θ(i−1)) ·",4.1 Generative story,[0],[0]
logP (g|π) +,4.1 Generative story,[0],[0]
"∑
d∈Du
logP ( bd|sd; ρ(g) )",4.1 Generative story,[0],[0]
"(5)
normal distributions N (0, σ(π)), and N (0, σ(ρ)), which are centered at 0 with externally given variances and no covariance between parameters.",4.1 Generative story,[0],[0]
This has the effect of making parameter choices close to zero more probable.,4.1 Generative story,[0],[0]
"Consequently, our models are unlikely to contain large weights for features that only occurred a few times or which are only helpful for a few examples.",4.1 Generative story,[0],[0]
"This should reduce the risk of overfitting the training set.
",4.1 Generative story,[0],[0]
The equation for the full probability of the data and a specific parameter setting is given in (3).,4.1 Generative story,[0],[0]
"The left bracket contains the likelihood of the data, while the right bracket contains the prior probability of the parameters.",4.1 Generative story,[0],[0]
Once we have set values θ =,4.2 Predicting user behavior,[0],[0]
"(π, ρ(1), . . .",4.2 Predicting user behavior,[0],[0]
", ρ(K))",4.2 Predicting user behavior,[0],[0]
"for all the parameters, we want to predict what behavior b a user u will exhibit in response to a stimulus s. If we encounter a completely new user u, the prior user group distribution from (2) gives the probability that this user belongs to each group.",4.2 Predicting user behavior,[0],[0]
"We combine this with the group-specific log-linear behavior models to obtain the distribution:
P (b|s; θ) = K∑ g=1 P ( b|s; ρ(g) )",4.2 Predicting user behavior,[0],[0]
"· P (g|π) (6)
",4.2 Predicting user behavior,[0],[0]
"Thus, we have a group-aware replacement for (1).",4.2 Predicting user behavior,[0],[0]
"Furthermore, in the interactive setting of a dialogue system, we may have multiple opportunities to interact with the same user u. We can then develop a more precise estimate of u’s group based on their responses to previous stimuli.",4.2 Predicting user behavior,[0],[0]
Say that we have made the previous observations D(u) =,4.2 Predicting user behavior,[0],[0]
"{〈s1, b1〉, . . .",4.2 Predicting user behavior,[0],[0]
", 〈sN , bN 〉} for user u.",4.2 Predicting user behavior,[0],[0]
"Then we can use Bayes’ theorem to calculate a posterior estimate for u’s group membership:
P ( g|D(u); θ ) ∝",4.2 Predicting user behavior,[0],[0]
P ( D(u)|ρ(g) ) ·,4.2 Predicting user behavior,[0],[0]
"P (g|π) (7)
",4.2 Predicting user behavior,[0],[0]
This posterior balances whether a group is likely in general against whether members of that group behave as u does.,4.2 Predicting user behavior,[0],[0]
"We can use Pu(g) = P ( g|D(u); θ ) as our new estimate for the group membership probabilities for u and replace (6) with: P ( b|s,D(u); θ ) =
K∑ g=1 P ( b|s; ρ(g) ) ·",4.2 Predicting user behavior,[0],[0]
"Pu(g) (8)
for the next interaction with u. An NLG system can therefore adapt to each new user over time.",4.2 Predicting user behavior,[0],[0]
"Before the first interaction with u, it has no specific information about u and models u’s behavior based on (6).",4.2 Predicting user behavior,[0],[0]
"As the system interacts with u repeatedly, it collects observationsD(u) about u’s behavior.",4.2 Predicting user behavior,[0],[0]
"This allows it to calculate an increasingly accurate posterior Pu(g) = P ( g|D(u); θ ) of u’s group membership, and thus generate utterances which are more and more suitable to u using (8).",4.2 Predicting user behavior,[0],[0]
"So far we have not discussed how to find settings for the parameters θ = π, ρ(1), . . .",5 Training,[0],[0]
", ρ(K), which define our probability model.",5 Training,[0],[0]
"The key challenge for training is the fact that we want to be able to train while treating the assignment of users to groups as unobserved.
",5 Training,[0],[0]
"We will use a maximum a posteriori estimate for θ, i.e., the setting which maximizes (3) when D is our training set.",5 Training,[0],[0]
"We will first discuss how to pick parameters to maximize only the left part of (3), i.e., the data likelihood, since this is the part that involves unobserved variables.",5 Training,[0],[0]
We will then discuss handling the parameter prior in section 5.2.,5 Training,[0],[0]
"Gradient descent based methods (Nocedal and Wright, 2006) exist for finding the parameter settings which maximize the likelihood for log-linear
models, under the conditions that all relevant variables are observed in the training data.",5.1 Expectation Maximization,[0],[0]
"If group assignments were given, gradient computations, and therefore gradient based maximization, would be straightforward for our model.",5.1 Expectation Maximization,[0],[0]
"One algorithm specifically designed to solve maximization problems with unknown variables by reducing them to the case where all variables are observed, is the expectation maximization (EM) algorithm (Neal and Hinton, 1999).",5.1 Expectation Maximization,[0],[0]
"Instead of maximizing the data likelihood from (3) directly, EM equivalently maximizes the log-likelihood, given in (4).",5.1 Expectation Maximization,[0],[0]
"It helps us deal with unobserved variables by introducing “pseudo-observations” based on the expected frequency of the unobserved variables.
",5.1 Expectation Maximization,[0],[0]
"EM is an iterative algorithm which produces a sequence of parameter settings θ(1), . . .",5.1 Expectation Maximization,[0],[0]
", θ(n).",5.1 Expectation Maximization,[0],[0]
Each will achieve a larger value for (4).,5.1 Expectation Maximization,[0],[0]
Each new setting is generated in two steps: (1) an lower bound on the log-likelhood is generate and (2) the new parameter setting is found by optimizing this lower bound.,5.1 Expectation Maximization,[0],[0]
"To find the lower bound we compute the probability for every possible value the unobserved variables could have had, based on the observed variables and the parameter setting θ(i−1) from the last iteration step.",5.1 Expectation Maximization,[0],[0]
"Then the lower bound essentially assumes that each assignment was seen with a frequency equal to these probabilities - these are the “pseudo-observations”.
",5.1 Expectation Maximization,[0],[0]
In our model the unobserved variables are the assignments of users to groups.,5.1 Expectation Maximization,[0],[0]
"The probability of seeing each user u assigned to a group, given all the data D(u) and the model parameters from the last iteration θ(i−1), is simply the posterior group membership probability P ( g|D(u); θ(i−1) ) .",5.1 Expectation Maximization,[0],[0]
The lower bound is then given by (5).,5.1 Expectation Maximization,[0],[0]
"This is the sum of the log probabilities of the data points under each group model, weighted by P ( g|D(u); θ(i−1) ) .",5.1 Expectation Maximization,[0],[0]
We can now use gradient descent techniques to optimize this lower bound.,5.1 Expectation Maximization,[0],[0]
To fully implement EM we need a way to maximize (5).,5.1.1 Maximizing the Lower Bound,[0],[0]
"This can be achieved with gradient based methods such as L-BFGS (Nocedal and Wright, 2006).",5.1.1 Maximizing the Lower Bound,[0],[0]
Here the gradient refers to the vector of all partial derivatives of the function with respect to each dimension of θ.,5.1.1 Maximizing the Lower Bound,[0],[0]
"We therefore need to calculate these partial derivatives.
",5.1.1 Maximizing the Lower Bound,[0],[0]
There are existing implementations of the gradient computations our base model such as in Engonopoulos et al. (2013).,5.1.1 Maximizing the Lower Bound,[0],[0]
"The gradients of (5)
for each of the ρ(g) is simply the gradient for the base model on each datapoint d weighted by P ( g|D(u); θ(i−1) )",5.1.1 Maximizing the Lower Bound,[0],[0]
"if d ∈ Du, i.e., the probability that the user u from which the datapoint originates belongs to group g. We can therefore compute the gradients needed for each ρ(g) by using implementations developed for the base model.
",5.1.1 Maximizing the Lower Bound,[0],[0]
"We also need gradients for the parameters in π, which are only used in our extended model.",5.1.1 Maximizing the Lower Bound,[0],[0]
"We can use the rules for computing derivatives to find, for each dimension g:
∂UL(θ) ∂πg = ∑ u∈U Pu(g)− exp (πg)∑K g′=1 exp ( πg′ )
where Pu(g) = P ( g|D(u); θ(i−1) ) .",5.1.1 Maximizing the Lower Bound,[0],[0]
Using these gradients we can use L-BFGS to maximize the lower bound and implement the EM iteration.,5.1.1 Maximizing the Lower Bound,[0],[0]
So far we have discussed maximization only for the likelihood without accounting for the prior probabilities for every parameter.,5.2 Handling the Parameter Prior,[0],[0]
"To obtain our full training objective we add the log of the right hand side of (3):
log N (π|0, σ(π)) · K∏",5.2 Handling the Parameter Prior,[0],[0]
g=1 N,5.2 Handling the Parameter Prior,[0],[0]
"( ρ(g)|0, σ(ρ) )",5.2 Handling the Parameter Prior,[0],[0]
"i.e., the parameter prior, to (4) and (5).",5.2 Handling the Parameter Prior,[0],[0]
The gradient contribution from these priors can be computed with standard techniques.,5.2 Handling the Parameter Prior,[0],[0]
"We can now implement an EM loop, which maximizes (3) as follows: we randomly pick an initial value θ(0) for all parameters.",5.3 Training Iteration,[0],[0]
Then we repeatedly compute the P ( g|D(u); θ(i−1) ) values and maximize the lower bound using L-BFGS to find θ(i).,5.3 Training Iteration,[0],[0]
This EM iteration is guaranteed to eventually converge towards a local optimum of our objective function.,5.3 Training Iteration,[0],[0]
"Once change in the objective falls below a pre-defined threshold, we keep the final θ setting.
",5.3 Training Iteration,[0],[0]
"For our implementation we make a small improvement to the approach: L-BFGS is itself an iterative algorithm and instead of running it until convergence every time we need to find a new θ(i), we only let it take a few steps.",5.3 Training Iteration,[0],[0]
"Even if we just took a single L-BFGS step in each iteration, we would still obtain a correct algorithm (Neal and
Hinton, 1999) and this has the advantage that we do not spend time trying to find a θ(i) which is a good fit for the likely poor group assignments P ( g|D(u); θ(i−1) )",5.3 Training Iteration,[0],[0]
we obtain from early parameter estimates.,5.3 Training Iteration,[0],[0]
Our model can be used in any component of a dialog system for which a prediction of the user’s behavior is needed.,6 Evaluation,[0],[0]
"In this work, we evaluate it in two NLG-related prediction tasks: RE production and RE comprehension.",6 Evaluation,[0],[0]
In both cases we evaluate the ability of our model to predict the user’s behavior given a stimulus.,6 Evaluation,[0],[0]
"We expect our user-group model to gradually improve its prediction accuracy compared to a generic baseline without user groups as it sees more observations from a given user.
",6 Evaluation,[0],[0]
In all experiments described below we set the prior variances σγ = 1.0 and σπ = 0.3 after trying out values between 0.1 and 10 on the training data of the comprehension experiment.,6 Evaluation,[0],[0]
"Task The task of RE generation can be split in two steps: attribute selection, the selection of the visual attributes to be used in the RE such as color, size, relation to other objects and surface realization, the generation of a full natural language expression.",6.1 RE production,[0],[0]
"We focus here on attribute selection: given a visual scene and a target object, we want to predict the set of attributes of the target object that a human speaker would use in order to describe it.",6.1 RE production,[0],[0]
"Here we treat attribute selection in terms of individual classification decisions on whether to use each attribute, as described in Section 3.",6.1 RE production,[0],[0]
"More specifically, we focus on predicting whether the speaker will use a spatial relation to another object (“landmark”).",6.1 RE production,[0],[0]
"Our motivation for choosing this attribute stems from the fact that previous authors (Viethen and Dale, 2008; Ferreira and Paraboni, 2014) have found substantial variation between different users with respect to their preference towards using spatial relations.
",6.1 RE production,[0],[0]
"Data We use the GRE3D3 dataset of humanproduced REs (Viethen and Dale, 2010), which contains 630 descriptions for 10 scenes collected from 63 users, each describing the same target object in each scene.",6.1 RE production,[0],[0]
35% of the descriptions in this corpus use a spatial relation.,6.1 RE production,[0],[0]
"An example of such a scene can be seen in Fig. 3.
",6.1 RE production,[0],[0]
"Models We use two baselines for comparison:
Basic: The state-of-the-art model on this task with this dataset, under the assumption that users are seen in training, is presented in Ferreira and Paraboni (2014).",6.1 RE production,[0],[0]
"They define context features such as type of relation between the target object and its landmark, number of object of the same color or size, etc., then train an SVM classifier to predict the use of each attribute.",6.1 RE production,[0],[0]
"We recast their model in terms of a log-linear model with the same features, to make it fit with the setup of Section 3.
Basic++: Ferreira and Paraboni (2014) also take speaker features into account.",6.1 RE production,[0],[0]
"We do not use speaker identity and the speaker’s attribute frequency vector, because we only evaluate on unseen users.",6.1 RE production,[0],[0]
"We do use their other speaker features (age, gender), together with Basic’s context features; this gives us a strong baseline which is aware of manually annotated user group characteristics.
",6.1 RE production,[0],[0]
"We compare these baselines to our Group model for values of K between 1 and 10, using the exact same features as Basic.",6.1 RE production,[0],[0]
"We do not use the speaker features of Basic++, because we do not want to rely on manually annotated groups.",6.1 RE production,[0],[0]
"Note that our results are not directly comparable with those of Ferreira and Paraboni (2014), because of a different training-test split: their model requires having seen speakers in training, while we explicitly want to test our model’s ability to generalize to unseen users.
",6.1 RE production,[0],[0]
"Experimental setup We evaluate using crossvalidation, splitting the folds so that all speakers we see in testing are previously unseen in training.",6.1 RE production,[0],[0]
We use 9 folds in order to have folds of the same size (each containing 70 descriptions coming from 7 speakers).,6.1 RE production,[0],[0]
At each iteration we train on 8 folds and test on the 9th.,6.1 RE production,[0],[0]
"At test time, we process each test instance iteratively: we first predict for each instance whether the user uwould use a spatial relation or not and test our prediction; we then add the
actual observation from the corpus to the set D(u) of observations for this particular user, in order to update our estimate about their group membership.
",6.1 RE production,[0],[0]
"Results Figure 4 shows the test F1-score (microaveraged over all folds) as we increase the number of groups, compared to the baselines.",6.1 RE production,[0],[0]
"For our Group models, these are averaged over all interactions with the user.",6.1 RE production,[0],[0]
"Our model gets F1-scores between 0.69 and 0.76 for all values ofK > 1, outperforming both Basic (0.22) and Basic++ (0.23).
",6.1 RE production,[0],[0]
"In order to take a closer look at our model’s behavior, we also show the accuracy of our model as it observes more instances at test time.",6.1 RE production,[0],[0]
We compare the model with K = 3 groups against the two baselines.,6.1 RE production,[0],[0]
"Figure 5 shows that the group model’s F1-score increases dramatically after the first two observations and then stays high throughout the test phase, always outperforming both baselines by at least 0.37 F1-score points after the first observation.",6.1 RE production,[0],[0]
The baseline models of course are not expected to improve with time; fluctuations are due to differences between the visual scenes.,6.1 RE production,[0],[0]
"In the same figure, we plot the evolution of the entropy of the group model’s posterior distribution over the groups (see (7)).",6.1 RE production,[0],[0]
"As expected, the model is highly uncertain at the beginning of the test phase about which group the user belongs to, then gets more and more certain as the set D(u) of observations from that user grows.",6.1 RE production,[0],[0]
Task Our next task is to predict the referent to which a user will resolve an RE in the context of a visual scene.,6.2 RE comprehension,[0],[0]
"Our model is given a stimulus s = (r, c) consisting of an instruction containing an RE r and a visual context c and outputs a probability distribution over all possible referents b.",6.2 RE comprehension,[0],[0]
"Such a model can be used by a probabilistic RE generator to select an RE which is highly likely to be correctly understood by the user or predict potential
misunderstandings (see Section 3).
",6.2 RE comprehension,[0],[0]
Data We use the GIVE-2.5 corpus for training and the GIVE-2 corpus for testing our model (the same used by Engonopoulos et al. (2013)).,6.2 RE comprehension,[0],[0]
These contain recorded observations of dialog systems giving instructions to users who play a game in a 3D environment.,6.2 RE comprehension,[0],[0]
"Each instruction contains an RE r, which is recorded in the data together with the visual context c at the time the instruction was given.",6.2 RE comprehension,[0],[0]
The object b which the user understood as the referent of the RE is inferred by the immediately subsequent action of the user.,6.2 RE comprehension,[0],[0]
"In total, we extracted 2927 observations by 403 users from GIVE-25 and 5074 observations by 563 users from GIVE-2.
",6.2 RE comprehension,[0],[0]
Experimental setup We follow the training method described in Section 3.,6.2 RE comprehension,[0],[0]
"At test time, we present the observations from each user in the order they occur in the test data; for each stimulus, we ask our models to predict the referent a which the user understood to be the referent of the RE, and compare with the recorded observation.",6.2 RE comprehension,[0],[0]
"We subsequently add the recorded observation to the dataset for the user and continue.
",6.2 RE comprehension,[0],[0]
"Models As a baseline, we use the Basic model described in Section 3, with the features of the “semantic” model of Engonopoulos et al. (2013).",6.2 RE comprehension,[0],[0]
"Those features capture information about the objects in the visual scene (e.g. salience) and some basic semantic properties of the RE (e.g. color, position).",6.2 RE comprehension,[0],[0]
"We use those features for our Group model as well, and evaluate for K between 1 and 10.
Results on GIVE data Basic had a test accuracy of 72.70%, which was almost identical with the accuracy of our best Group model for K = 6 (72.78%).",6.2 RE comprehension,[0],[0]
This indicates that our group model does not differentiate between users.,6.2 RE comprehension,[0],[0]
"Indeed, after training, the 6-group model assigns 81% prior probabil-
ity to one of the groups, and effectively gets stuck with this assignment while testing; the mean entropy of the posterior group distribution only falls from an initial 1.1 to 0.7 after 10 observations.
",6.2 RE comprehension,[0],[0]
We speculate that the reason behind this is that the features we use are not sensitive enough to capture the differences between the users in this data.,6.2 RE comprehension,[0],[0]
"Since our model relies completely on observable behavior, it also relies on the ability of the features to make relevant distinctions between users.
",6.2 RE comprehension,[0],[0]
"Results on synthetic data In order to test this hypothesis, we made a synthetic dataset based on the GIVE datasets with 1000 instances from 100 users, in the following way: for each user, we randomly selected 10 scenes from GIVE-2, and replaced the target the user selected, so that half of the users always select the target with the highest visual salience, and the other half always select the one with the lowest.",6.2 RE comprehension,[0],[0]
"Our aim was to test whether our model is capable of identifying groups when they are clearly present in the data and exhibit differences which our features are able to capture.
",6.2 RE comprehension,[0],[0]
We evaluated the same models in a 2-fold crossvalidation.,6.2 RE comprehension,[0],[0]
Figure 6 shows the prediction accuracy for Basic and the Group models for K from 1 to 10.,6.2 RE comprehension,[0],[0]
"All models for K > 1 clearly outperform the baseline model: the 2-group model gets 62.3% vs 28.6% averaged over all test examples, while adding more than two groups does not further improve the accuracy.",6.2 RE comprehension,[0],[0]
We also show in Figure 7 the evolution of the accuracy asD(u) grows: the Group model with K = 2 reaches a 64% testing accuracy after seeing two observations from the same user.,6.2 RE comprehension,[0],[0]
"In the same figure, the entropy of the posterior distribution over groups (see production experiment) falls towards zero as D(u) grows.",6.2 RE comprehension,[0],[0]
"These results show that our model is capable of correctly assigning a user to the group they belong to, once the features are adequate for distinguishing between different user behaviors.",6.2 RE comprehension,[0],[0]
"Our model was shown to be successful in discovering groups of users with respect to their behavior, within datasets which present discernible user variation.",6.3 Discussion,[0],[0]
"In particular, if all listeners are influenced in a similar way by e.g. the visual salience of an object, then the group model cannot learn different weights for the visual salience feature; if this happens for all available features, there are effectively no groups for our model to discover.
",6.3 Discussion,[0],[0]
"Once the groups have been discovered, our model can then very quickly distinguish between them at test time.",6.3 Discussion,[0],[0]
This is reflected in the steep performance improvement even after the first user observation in both the real data experiment in 6.1 and the synthetic data experiment in 6.2.,6.3 Discussion,[0],[0]
"We have presented a probabilistic model for NLG which predicts the behavior of individual users of a dialog system by dynamically assigning them to user groups, which were discovered during training2.",7 Conclusion,[0],[0]
"We showed for two separate NLG-related tasks, RE production and RE comprehension, how our model, after being trained with data that is not annotated with user groups, can quickly adapt to unseen users as it gets more observations from them in the course of a dialog and makes increasingly accurate predictions about their behavior.
",7 Conclusion,[0],[0]
"Although in this work we apply our model to tasks related to NLG, nothing hinges on this choice; it can also be applied to any other dialog-related prediction task where user variation plays a role.",7 Conclusion,[0],[0]
"In the future, we will also try to apply the basic principles of our user group approach to more sophisticated underlying models, such as neural networks.
2Our code and data is available in https://bit.ly/ 2jIu1Vm",7 Conclusion,[0],[0]
We present a model which predicts how individual users of a dialog system understand and produce utterances based on user groups.,abstractText,[0],[0]
"In contrast to previous work, these user groups are not specified beforehand, but learned in training.",abstractText,[0],[0]
"We evaluate on two referring expression (RE) generation tasks; our experiments show that our model can identify user groups and learn how to most effectively talk to them, and can dynamically assign unseen users to the correct groups as they interact with the system.",abstractText,[0],[0]
Discovering User Groups for Natural Language Generation,title,[0],[0]
"As originally defined by Pearl (1988), Bayesian networks express joint distributions over finite sets of random variables as products of conditional distributions.",1. Introduction,[0],[0]
"Probabilistic programming languages (PPLs) (Koller et al., 1997; Milch et al., 2005a; Goodman et al., 2008; Wood et al., 2014b) apply the same idea to potentially infinite sets of variables with general dependency structures.",1. Introduction,[0],[0]
"Thanks to their expressive power, PPLs have been used to solve many real-world applications, including Captcha (Le et al., 2017), seismic monitoring (Arora et al., 2013), 3D pose estimation (Kulkarni et al., 2015), generating design suggestions (Ritchie et al., 2015), concept learning (Lake et al., 2015), and cognitive science applications (Stuhlmüller & Goodman, 2014).
",1. Introduction,[0],[0]
"In practical applications, we often have to deal with a mix-
1University of California, Berkeley 2Arizona State University 3Vicarious Inc. 4Carnegie Mellon University.",1. Introduction,[0],[0]
"Correspondence to: Yi Wu <jxwuyi@gmail.com>.
",1. Introduction,[0],[0]
"Proceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018.",1. Introduction,[0],[0]
"Copyright 2018 by the author(s).
ture of continuous and discrete random variables.",1. Introduction,[0],[0]
"Existing PPLs support both discrete and continuous random variables, but not discrete-continuous mixtures, i.e., variables whose distributions combine discrete and continuous elements.",1. Introduction,[0],[0]
"Such variables are fairly common in practical applications: sensors that have thresholded limits, e.g. thermometers, weighing scales, speedometers, pressure gauges; or a hybrid sensor that can report a either real value or an error condition.",1. Introduction,[0],[0]
"The occurrence of such variables has been noted in many other applications from a wide range of scientific domains (Kharchenko et al., 2014; Pierson & Yau, 2015; Gao et al., 2017).
",1. Introduction,[0],[0]
"Many PPLs have a restricted syntax that forces the expressed random variables to be either discrete or continuous, including WebPPL (Goodman & Stuhlmüller, 2014), Edward (Tran et al., 2016), Figaro (Pfeffer, 2009) and Stan (Carpenter et al., 2016).",1. Introduction,[0],[0]
"Even for PPLs whose syntax allows for mixtures of discrete and continuous variables, such as BLOG (Milch et al., 2005a), Church (Goodman, 2013), Venture (Mansinghka et al., 2014) and Anglican (Wood et al., 2014a), the underlying semantics of these PPLs implicitly assumes the random variables are not mixtures.",1. Introduction,[0],[0]
"Moreover, the inference algorithms associated with the semantics inherit the same assumption and can produce incorrect results when discrete-continuous mixtures are used.
",1. Introduction,[0],[0]
"Consider the following GPA example: a two-variable Bayes net Nationality → GPA where the nationality follows a binary distribution
P (Nationality = USA) = P (Nationality = India)",1. Introduction,[0],[0]
"= 0.5
and the conditional probabilities are discrete-continuous mixtures
GPA|Nationality = USA ∼0.01 · 1 {GPA = 4}+ 0.99 · Unif(0, 4),
GPA|Nationality = India ∼0.01 · 1 {GPA = 10}+ 0.99 · Unif(0, 10).
",1. Introduction,[0],[0]
This is a typical scenario in practice because many top students have perfect GPAs.,1. Introduction,[0],[0]
Now suppose we observe a student with a GPA of 4.0.,1. Introduction,[0],[0]
Where do they come from?,1. Introduction,[0],[0]
"If the student is Indian, the probability of any singleton set {g}
where 0 <",1. Introduction,[0],[0]
"g < 10 is zero, as this range has a probability density.",1. Introduction,[0],[0]
"On the other hand if the student is American, the set {4} has the probability 0.01.",1. Introduction,[0],[0]
"Thus, by Bayes theorem, P (Nationality = USA|GPA = 4) = 1, which means the student must be from the USA.
",1. Introduction,[0],[0]
"However, if we run the default Bayesian inference algorithm for this problem in PPLs, e.g., the standard importance sampling algorithm (Milch et al., 2005b), a sample that picks India receives a density weight of 0.99/10.0 = 0.099, whereas one that picks USA receives a discrete-mass weight of 0.01.",1. Introduction,[0],[0]
"Since the algorithm does not distinguish probability density and mass, it will conclude that the student is very probably from India, which is far from the truth.
",1. Introduction,[0],[0]
"We can fix the GPA example by considering a density weight infinitely smaller than a discrete-mass weight (Nitti et al., 2016; Tolpin et al., 2016).",1. Introduction,[0],[0]
"However, the situation becomes more complicated when involving more than one evidence variable, e.g., GPAs over multiple semesters for students who may study in both countries.",1. Introduction,[0],[0]
Vector-valued variables also cause problems—does a point mass in three dimensions count more or less than a point mass in two dimensions?,1. Introduction,[0],[0]
"These practical issues motivate the following two tasks:
• Inherit all the existing properties of PPL semantics and extend it to handle random variables with mixed discrete and continuous distributions;
• Design provably correct inference algorithms for the extended semantics.
",1. Introduction,[0],[0]
"In this paper, we carry out all these two tasks and implement the extended semantics as well as the new algorithms in a widely used PPL, Bayesian Logic (BLOG) (Milch et al., 2005a).",1. Introduction,[1.0],"['In this paper, we carry out all these two tasks and implement the extended semantics as well as the new algorithms in a widely used PPL, Bayesian Logic (BLOG) (Milch et al., 2005a).']"
Measure-Theoretical Bayesian Nets (MTBNs) Measure theory can be applied to handle discrete-continuous mixtures or even more abstract measures.,1.1. Main Contributions,[1.0],['Measure-Theoretical Bayesian Nets (MTBNs) Measure theory can be applied to handle discrete-continuous mixtures or even more abstract measures.']
"In this paper, we define a generalization of Bayesian networks called measure-theoretic Bayesian networks (MTBNs) and prove that every MTBN represents a unique measure on the input space.",1.1. Main Contributions,[0],[0]
"We then show how MTBNs can provide a more general semantic foundation for PPLs.
More concretely, MTBNs support (1) random variables with infinitely (even uncountably) many parents, (2) random variables valued in arbitrary measure spaces (with RN as one case) distributed according to any measure (including discrete, continuous and mixed), (3) establishment of conditional independencies implied by an infinite graph, and (4) open-universe semantics in terms of the possible worlds in the vocabulary of the model.
",1.1. Main Contributions,[0],[0]
Inference Algorithms,1.1. Main Contributions,[0],[0]
"We propose a provably correct inference algorithm, lexicographic likelihood weighting (LLW), for general MTBNs with discrete-continuous mixtures.",1.1. Main Contributions,[0],[0]
"In addition, we propose LPF, a particle-filtering variant of LLW for sequential Monte Carlo (SMC) inference on state-space models.
",1.1. Main Contributions,[0],[0]
"Incorporating MTBNs into an existing PPL We incorporate MTBNs into BLOG with simple modifications and then define the generalized BLOG language, measuretheoretic BLOG, which formally supports arbitrary distributions, including discrete-continuous mixtures.",1.1. Main Contributions,[1.0],"['Incorporating MTBNs into an existing PPL We incorporate MTBNs into BLOG with simple modifications and then define the generalized BLOG language, measuretheoretic BLOG, which formally supports arbitrary distributions, including discrete-continuous mixtures.']"
We prove that every generalized BLOG model corresponds to a unique MTBN.,1.1. Main Contributions,[1.0],['We prove that every generalized BLOG model corresponds to a unique MTBN.']
"Thus, all the desired theoretical properties of MTBNs can be carried to measure-theoretic BLOG.",1.1. Main Contributions,[0],[0]
We also implement the LLW and LPF algorithms in the backend of measure-theoretic BLOG and use three representative examples to show their effectiveness.,1.1. Main Contributions,[0],[0]
This paper is organized as follows.,1.2. Organization,[0],[0]
We first discuss related work in Section 2.,1.2. Organization,[0],[0]
"In Section 3, we formally define measure-theoretic Bayesian nets and study their theoretical properties.",1.2. Organization,[1.0],"['In Section 3, we formally define measure-theoretic Bayesian nets and study their theoretical properties.']"
Section 4 describes the LLW and LPF inference algorithms for MTBNs with discrete-continuous mixtures and establishes their correctness.,1.2. Organization,[1.0],['Section 4 describes the LLW and LPF inference algorithms for MTBNs with discrete-continuous mixtures and establishes their correctness.']
"In Section 5, we introduce the measure-theoretic extension of BLOG and study its theoretical foundations for defining probabilistic models.",1.2. Organization,[0],[0]
"In Section 6, we empirically validate the generalized BLOG system and the new inference algorithms on three representative examples.",1.2. Organization,[0],[0]
"The motivating GPA example has been also discussed as a special case under some other PPL systems (Tolpin et al., 2016; Nitti et al., 2016).",2. Related Work,[0],[0]
Tolpin et al. (2016) and Nitti et al. (2016) proposed different solutions specific to this example but did not address the general problems of representation and inference with random variables with mixtures of discrete and continuous distributions.,2. Related Work,[0],[0]
"In contrast, we present a general formulation with provably correct inference algorithms.
",2. Related Work,[0],[0]
"Our approach builds upon the foundations of the BLOG probabilistic programming language (Milch, 2006).",2. Related Work,[0],[0]
We use a measure theoretic formulation to generalize the syntax and semantics of BLOG to random variables that may have infinitely many parents and mixed continuous and discrete distributions.,2. Related Work,[0],[0]
"The BLP framework Kersting & De Raedt (2007) unifies logic programming with probability models, but requires each random variable to be influenced by a finite set of random variables in order to define the semantics.",2. Related Work,[0],[0]
"This amounts to requiring only finitely many ances-
tors of each random variable.",2. Related Work,[0],[0]
Choi et al. (2010) present an algorithm for carrying out lifted inference over models with purely continuous random variables.,2. Related Work,[0],[0]
"They also require parfactors to be functions over finitely many random variables, thus limiting the set of influencing variables for each node to be finite.",2. Related Work,[0],[0]
Gutmann et al. (2011a) also define densities over finite dimensional vectors.,2. Related Work,[0],[0]
"In a relatively more general formulation (Gutmann et al., 2011b) define the distribution of each random variable using a definite clause, which corresponds to the limitation that each random variable (either discrete or continuous) has finitely many parents.",2. Related Work,[0],[0]
Frameworks building on Markov networks also have similar restrictions.,2. Related Work,[0],[0]
"Wang & Domingos (2008) only consider networks of finitely many random variables, which can have either discrete or continuous distributions.",2. Related Work,[0],[0]
"Singla & Domingos (2007) extend Markov logic to infinite (non-hybrid) domains, provided that each random variable has only finitely many influencing random variables.
",2. Related Work,[0],[0]
"In contrast, our approach not only allows models with arbitrarily many random variables with mixed discrete and continuous distributions, but each random variable can also have arbitrarily many parents as long as all ancestor chains are finite (but unbounded).",2. Related Work,[0],[0]
"The presented work constitutes a rigorous framework for expressing probability models with the broadest range of cardinalities (uncountably infinite parent sets) and nature of random variables (discrete, mixed, and even arbitrary measure spaces), with clear semantics in terms of first-order possible worlds and the generalization of conditional independences on such models.
",2. Related Work,[0],[0]
"Lastly, there are also other works using measure-theoretic approaches to analyze the semantics properties of probabilistic programs but with different emphases, such as the commutativity (Staton, 2017), design choices for monad structures (Ramsey, 2016) and computing a disintegration (Shan & Ramsey, 2017).",2. Related Work,[0],[0]
"In this section, we introduce measure-theoretic Bayesian networks (MTBNs) and prove that an MTBN represents a unique measure with desired theoretical properties.",3. Measure-Theoretic Bayesian Networks,[0],[0]
We assume familiarity with measure-theoretic approaches to probability theory.,3. Measure-Theoretic Bayesian Networks,[0],[0]
Some background is included in Appx.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"A.
We begin with some necessary definitions of graph theory.
",3. Measure-Theoretic Bayesian Networks,[0],[0]
Definition 3.1.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"A digraph G is a pair G = (V,E) of a set of vertices V , of any cardinality, and a set of directed edges E ⊆ V × V .",3. Measure-Theoretic Bayesian Networks,[0],[0]
"The notation u→ v denotes (u, v) ∈ E, and u 7→ v denotes the existence of a path from u to v in G.
Definition 3.2.",3. Measure-Theoretic Bayesian Networks,[0],[0]
"A vertex v ∈ V is a root vertex if there are no incoming edges to it, i.e., there is no u ∈ V such that u → v. Let pa(v)",3. Measure-Theoretic Bayesian Networks,[0],[0]
"= {u ∈ V : u → v} denote the set of parents of a vertex v ∈ V , and nd(v) =",3. Measure-Theoretic Bayesian Networks,[0],[0]
"{u ∈ V : not v 7→
u} denote its set of non-descendants.",3. Measure-Theoretic Bayesian Networks,[0],[0]
Definition 3.3.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"A well-founded digraph (V,E) is one with no countably infinite ancestor chain v0 ← v1 ← v2 ← . . .",3. Measure-Theoretic Bayesian Networks,[0],[0]
".
",3. Measure-Theoretic Bayesian Networks,[0],[0]
This is the natural generalization of a finite directed acyclic graph to the infinite case.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"Now we are ready to give the key definition of this paper.
",3. Measure-Theoretic Bayesian Networks,[0],[0]
Definition 3.4.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"A measure-theoretic Bayesian network M = (V,E, {Xv}v∈V , {Kv}v∈V ) consists of (a) a wellfounded digraph (V,E) of any cardinality, (b) an arbitrary measurable space Xv for each v ∈ V , and (c) a probability kernel Kv from ∏ u∈pa(v) Xu to Xv for each v ∈ V .
",3. Measure-Theoretic Bayesian Networks,[0],[0]
"By definition, MTBNs allow us to define very general and abstract models with the following two major benefits:
1.",3. Measure-Theoretic Bayesian Networks,[0.9999999428847424],"['By definition, MTBNs allow us to define very general and abstract models with the following two major benefits: 1.']"
"We can define random variables with infinitely (even uncountably) many parents because MTBN is defined on a well-founded digraph.
2.",3. Measure-Theoretic Bayesian Networks,[0],[0]
"We can define random variables in arbitrary measure spaces (with RN as one case) distributed according to any measure (including discrete, continuous and mixed).
",3. Measure-Theoretic Bayesian Networks,[0],[0]
"Next, we related MTBN to a probability measure.",3. Measure-Theoretic Bayesian Networks,[0],[0]
"Fix an MTBN M = (V,E, {Xv}v∈V , {Kv}v∈V ).",3. Measure-Theoretic Bayesian Networks,[0],[0]
For U ⊆ V let XU = ∏ u∈U Xu be the product measurable space over variables u ∈ U .,3. Measure-Theoretic Bayesian Networks,[0],[0]
"With this notation, Kv is a kernel from Xpa(v) to Xv.",3. Measure-Theoretic Bayesian Networks,[0],[0]
Whenever W ⊆ U let πUW : XU → XW denote the projection map.,3. Measure-Theoretic Bayesian Networks,[0],[0]
Let XV be our base measurable space upon which we will consider different probability measures µ.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"Let Xv for v ∈ V denote both the underlying set of Xv and the random variable given by the projection πV{v}, and XU for U ⊆ V the underlying space of XU and the random variable given by the projection πVU .
",3. Measure-Theoretic Bayesian Networks,[0],[0]
Definition 3.5.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"An MTBN M represents a measure µ on XV , if for all v ∈ V :
• Xv is conditionally independent of its non-descendants Xnd(v) given its parents Xpa(v).",3. Measure-Theoretic Bayesian Networks,[0],[0]
"• Kv(Xpa(v), A) = Pµ[Xv ∈ A|Xpa(v)] holds almost surely for any A ∈ Xv, i.e., Kv is a version of the conditional distribution of Xv given its parents.
",3. Measure-Theoretic Bayesian Networks,[0],[0]
Def. 3.5 captures the generalization of the local properties of Bayes networks – conditional independence and conditional distributions defined by parent-child relationships.,3. Measure-Theoretic Bayesian Networks,[0],[0]
Here we assume the conditional probability exists and is unique.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"This is a mild condition because this holds as long as the probability space is regular (Kallenberg, 2002).
",3. Measure-Theoretic Bayesian Networks,[0],[0]
"The next theorem shows that MTBNs are well-defined.
",3. Measure-Theoretic Bayesian Networks,[0],[0]
Theorem 3.6.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"An MTBN M represents a unique measure µ on XV .
",3. Measure-Theoretic Bayesian Networks,[0],[0]
The proof of theorem 3.6 requires several intermediate results and is presented in Appx.,3. Measure-Theoretic Bayesian Networks,[0],[0]
B.,3. Measure-Theoretic Bayesian Networks,[0],[0]
The proof proceeds by first defining a projective family of measures.,3. Measure-Theoretic Bayesian Networks,[0],[0]
This gives a way to recursively construct our measure µ.,3. Measure-Theoretic Bayesian Networks,[0],[0]
We then define a notion of consistency such that every consistent projective family constructs a measure that M represents.,3. Measure-Theoretic Bayesian Networks,[0],[0]
"Lastly, we give an explicit characterization of the unique consistent projective family, and thus of the unique measure M represents.",3. Measure-Theoretic Bayesian Networks,[0],[0]
We introduce the lexicographic likelihood weighting (LLW) algorithm for provably correct inference on MTBNs.,4. Generalized Inference Algorithms,[0],[0]
We also present lexicographic particle filter (LPF) for statespace models by adapting LLW for the sequential Monte Carlo (SMC) framework.,4. Generalized Inference Algorithms,[0],[0]
"Suppose we have an MTBN with finitely many random variables X1, . . .",4.1. Lexicographic likelihood weighting,[0],[0]
", XN , and that, without loss of generality, we observe real-valued random variables X1, . . .",4.1. Lexicographic likelihood weighting,[0],[0]
", XM for M < N as evidence.",4.1. Lexicographic likelihood weighting,[0],[0]
"Suppose the distribution of Xi given its parents Xpa(i) is a mixture between a density fi(xi|xpa(i)) with respect to the Lebesgue measure and a discrete distribution Fi(xi|xpa(i)), i.e., for any > 0, we have P (Xi ∈",4.1. Lexicographic likelihood weighting,[0],[0]
"[xi − , xi]|Xpa(i))",4.1. Lexicographic likelihood weighting,[0],[0]
"=∑ x∈[xi− ,xi] Fi(xi|Xpa(i))",4.1. Lexicographic likelihood weighting,[0],[0]
+ ∫,4.1. Lexicographic likelihood weighting,[0],[0]
xi xi− fi(x|Xpa(i)),4.1. Lexicographic likelihood weighting,[0],[0]
dx.,4.1. Lexicographic likelihood weighting,[0],[0]
This implies that Fi(xi|xpa(i)) is nonzero for at most countably many values,4.1. Lexicographic likelihood weighting,[0],[0]
xi.,4.1. Lexicographic likelihood weighting,[0],[0]
"If Fi is nonzero for finitely many points, it can be represented by a list of those points and their values.
",4.1. Lexicographic likelihood weighting,[0],[0]
"Lexicographic Likelihood Weighting (LLW) extends the classical likelihood weighting (Milch et al., 2005b) to this setting.",4.1. Lexicographic likelihood weighting,[0],[0]
"It visits each node of the graph in topological order, sampling those variables that are not observed, and accumulating a weight for those that are observed.",4.1. Lexicographic likelihood weighting,[0],[0]
"In particular, at an evidence variable Xi we update a tuple (d,w) of the number of densities and a weight, initially (0, 1), by:
(d,w)← { (d,wFi(xi|xpa(i))) Fi(xi|xpa(i))",4.1. Lexicographic likelihood weighting,[0],[0]
"> 0, (d+ 1, wfi(xi|xpa(i)))",4.1. Lexicographic likelihood weighting,[0],[0]
"otherwise.
(1)
Finally, having K samples x(1), . .",4.1. Lexicographic likelihood weighting,[0],[0]
.,4.1. Lexicographic likelihood weighting,[0],[0]
", x(K) by this process and accordingly a tuple (d(i), w(i)) for each sample x(i), let d∗ = mini:w(i) 6=0 d
(i) and estimate E[f(X)|X1:M ] by∑ {i:d(i)=d∗} w
(i) f(x(i))∑",4.1. Lexicographic likelihood weighting,[0],[0]
{i:d(i)=d∗} w (i) .,4.1. Lexicographic likelihood weighting,[0],[0]
"(2)
The algorithm is summarised in Alg. 1",4.1. Lexicographic likelihood weighting,[0],[0]
The next theorem shows this procedure is consistent.,4.1. Lexicographic likelihood weighting,[0],[0]
Theorem 4.1.,4.1. Lexicographic likelihood weighting,[0],[0]
"LLW is consistent: (2) converges almost surely to E[f(X)|X1:M ].
",4.1. Lexicographic likelihood weighting,[0.9999999330685172],['LLW is consistent: (2) converges almost surely to E[f(X)|X1:M ].']
"Algorithm 1 Lexicographic Likelihood Weighting Require: densities f , masses F , evidences E, and K.
for i = 1 . .",4.1. Lexicographic likelihood weighting,[0],[0]
.K,4.1. Lexicographic likelihood weighting,[0],[0]
"do sample all the ancestors of E from prior compute (d(i), w(i)) by Eq.",4.1. Lexicographic likelihood weighting,[0],[0]
(1) end for d?,4.1. Lexicographic likelihood weighting,[0],[0]
"← mini:w(i) 6=0 d(i)
",4.1. Lexicographic likelihood weighting,[0],[0]
"Return (∑
i:d(i)=d? w (i)f(x(i))
) /",4.1. Lexicographic likelihood weighting,[0],[0]
(∑ i:d(i)=d?,4.1. Lexicographic likelihood weighting,[0],[0]
"w (i) )
",4.1. Lexicographic likelihood weighting,[0],[0]
"In order to prove Theorem 4.1, the main technique we adopt is to use a more restricted algorithm, the Iterative Refinement Likelihood Weighting (IRLW) as a reference.",4.1. Lexicographic likelihood weighting,[0],[0]
"Suppose we want to approximate the posterior distribution of an X -valued random variable X conditional on a Yvalued random variable Y , for arbitrary measure spaces X and Y .",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"In general, there is no notion of a probability density of Y given X for weighing samples.",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"If, however, we could make a discrete approximation Yt of Y then we could weight samples by the probability P",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
[Yt = yt|X].,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"If we increase the accuracy of the approximation with the number of samples, this should converge in the limit.",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"We show this is possible, if we are careful about how we approximate:
Definition 4.2.",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
An approximation scheme for a measurable space Y consists of a measurable spaceA and measurable approximation functions αi :,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"Y → A for i = 1, 2, . . .",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
and αji :,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
A → A for i < j such that αj ◦ α,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
j,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"i = αi and y can be measurably recovered from the subsequence αt(y), αt+1(y), . . .",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"for any t > 0.
",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"When Y is a real-valued variable we will use the approximation scheme αn(y) = 2−nd2nye where dre denotes the ceiling of r, i.e., the smallest integer no smaller than it.",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
Observe in this case that P (αn(Y ) = αn(y)),4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
= P (αn(y)− 2−n < Y ≤ αn(y)) which we can compute from the CDF of Y .,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
Lemma 4.3.,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"IfX,Y are real-valued random variables with E |X| <∞, then limi→∞ E[X|αi(Y )]",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"= E[X|Y ].
",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
Proof.,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
Let Fi = σ(αi(Y )),4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
be the sigma algebra generated by αi(Y ).,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
Whenever i ≤,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
j,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
we have αi(Y ),4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
= (αj ◦αji )(Y ) and so Fi ⊆ Fj .,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"This means E[X|αi(Y )] = E[X|Fi] is a martingale, so we can use martingale convergence results.",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"In particular, since E |X| <∞
E[X|Fi]→ E[X|F∞] a.s. and in L1, where F∞ =",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
⋃,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
i Fi is the sigma-algebra generated by {αi(Y ),4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
": i ∈ N} (see Theorem 7.23 in (Kallenberg, 2002)).
",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"Y is a measurable function of the sequence (α1(Y ), . . .",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"),",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
as limi→∞ αi(Y ),4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"= Y , and so σ(Y ) ⊆ F∞. By definition
the sequence is a measurable function of Y , and so F∞ ⊆ σ(Y ), and so E[X|F∞] = E[X|Y ] giving our result.
",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"Iterative refinement likelihood weighting (IRLW) samples x(1), . . .",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
", x(K)",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
from the prior,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"and evaluates:
∑K i=1",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"P (αn(Y )|X = x(i))f(x(i))∑K
i=1",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"P (αn(Y )|X = x(i)) (3)
Using Lemma 4.3, G.12, and G.13, we can show IRLW is consistent.
",4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
Theorem 4.4.,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
IRLW is consistent: (3) converges almost surely to E[f(X)|Y ].,4.1.1. ITERATIVE REFINEMENT LIKELIHOOD WEIGHTING,[0],[0]
"Now we are ready to prove Theorem 4.1.
",4.1.2. PROOF OF THEOREM 4.1,[0],[0]
Proof of Theorem 4.1.,4.1.2. PROOF OF THEOREM 4.1,[0],[0]
We prove the theorem for evidence variables that are leaves It is straightforward to extend the proof when the evidence variables are non-leaf nodes.,4.1.2. PROOF OF THEOREM 4.1,[0],[0]
"Let x be a sample produced by the algorithm with number of densities and weight (d,w).",4.1.2. PROOF OF THEOREM 4.1,[0],[0]
With In = ∏ i=1...,4.1.2. PROOF OF THEOREM 4.1,[0],[0]
"M (αn(xi)− 2−n, αn(xi)] a 2−n-cube around x1:M we have
lim n→∞ P (X1:M ∈ In|XM+1:N = xM+1:N )",4.1.2. PROOF OF THEOREM 4.1,[0],[0]
"w 2−dn = 1.
",4.1.2. PROOF OF THEOREM 4.1,[0],[0]
"Using In as an approximation scheme by Def. 4.2, the numerator in the above limit is the weight used by IRLW.",4.1.2. PROOF OF THEOREM 4.1,[0],[0]
"But given the above limit, using w 2−dn as the weight will give the same result in the limit.",4.1.2. PROOF OF THEOREM 4.1,[0],[0]
"Then if we have K samples, in the limit of n→∞ only those samples x(i) with minimal d(i) will contribute to the estimation, and up to normalization they will contribute weight w(i) to the estimation.",4.1.2. PROOF OF THEOREM 4.1,[0],[0]
"We now consider inference in a special class of highdimensional models known as state-space models, and show how LLW can be adapted to avoid the curse of dimensionality when used with such models.",4.2. Lexicographic particle filter,[1.0],"['We now consider inference in a special class of highdimensional models known as state-space models, and show how LLW can be adapted to avoid the curse of dimensionality when used with such models.']"
A state-space model (SSM) consists of latent states {Xt}0≤t≤T and the observations {Yt}0≤t≤T with a special dependency structure where pa(Yt) =,4.2. Lexicographic particle filter,[0],[0]
"Xt and pa(Xt) = Xt−1 for 0 < t ≤ T .
SMC methods (Doucet et al., 2001), also knowns as particle filters, are a widely used class of methods for inference on SSMs.",4.2. Lexicographic particle filter,[0],[0]
"Given the observed variables {Yt}0≤t≤T , the posterior distribution P (Xt|Y0:t) is approximated by a set of K particles where each particle x(k)t represents a sample of {Xi}0≤i≤t.",4.2. Lexicographic particle filter,[0],[0]
"Particles are propagated forward through the transition model P (Xt|Xt−1) and resampled at each time step t according to the weight of each particle, which is defined by the likelihood of observation Yt.
",4.2. Lexicographic particle filter,[1.0000000093575334],"['Particles are propagated forward through the transition model P (Xt|Xt−1) and resampled at each time step t according to the weight of each particle, which is defined by the likelihood of observation Yt.']"
"Algorithm 2 Lexicographic Particle Filter (LPF) Require: densities f , masses F , evidences Y , and K
for t = 0, . . .",4.2. Lexicographic particle filter,[0],[0]
", T do for k = 0, . . .",4.2. Lexicographic particle filter,[0],[0]
",K do x
(k) t ← sample from transition
compute (d(k), w(k)) by Eq. 4 end for d?",4.2. Lexicographic particle filter,[0],[0]
← mink:w(k) 6=0 d(k) ∀k : d(k) >,4.2. Lexicographic particle filter,[0],[0]
"d?, w(k) ← 0 Output ( w(k)f(x (k) t ) ) / (∑ k w (k) ) resample particles according to w(k)
end for
In the MTBN setting, the distribution of Yt1 given its parent Xt can be a mixture of density ft(yt|xt) and a discrete distribution Ft(yt|xt).",4.2. Lexicographic particle filter,[0],[0]
"Hence, the resampling step in a particle filter should be accordingly modified: following the idea from LLW, when computing the weight of a particle, we enumerate all the observations yt,",4.2. Lexicographic particle filter,[0],[0]
"i at time step t and again update a tuple (d,w), initially (0,1), by
(d,w)← { (d,wFt(yt,i|xt)) Ft(yt,i|xt) > 0, (d+ 1, wft(yt,i|xt))",4.2. Lexicographic particle filter,[0],[0]
otherwise.,4.2. Lexicographic particle filter,[0],[0]
"(4)
We discard all those particles with a non-minimum d value and then perform the normal resampling step.",4.2. Lexicographic particle filter,[0],[0]
"We call this algorithm lexicographical particle filter (LPF), which is summarized in Alg. 2.
",4.2. Lexicographic particle filter,[0],[0]
The following theorem guarantees the correctness of LPF.,4.2. Lexicographic particle filter,[0],[0]
"Its Proof easily follows the analysis for LLW and the classical proof of particle filtering based on importance sampling.
",4.2. Lexicographic particle filter,[0],[0]
Theorem 4.5.,4.2. Lexicographic particle filter,[0],[0]
LPF is consistent: the outputs of Alg.,4.2. Lexicographic particle filter,[0],[0]
2 converges almost surely to {E[f(Xt)|Y0:t]}0≤t≤T .,4.2. Lexicographic particle filter,[0],[0]
In Section 3 and Section 4 we provided the theoretical foundation of MTBN and general inference algorithms.,5. Generalized Probabilistic Programming Languages,[0],[0]
This section describes how to incorporate MTBN into a practical PPL.,5. Generalized Probabilistic Programming Languages,[0],[0]
"We focus on a widely used open-universe PPL, BLOG (Milch, 2006).",5. Generalized Probabilistic Programming Languages,[0],[0]
"We define the generalized BLOG language, the measure-theoretic BLOG, and prove that every well-formed measure-theoretic BLOG model corresponds to a unique MTBN.",5. Generalized Probabilistic Programming Languages,[0],[0]
"Note that our approach also applies to other PPLs2.
",5. Generalized Probabilistic Programming Languages,[0],[0]
1There can be multiple variables observed.,5. Generalized Probabilistic Programming Languages,[0],[0]
"Here the notation Yt denotes {Yt,i}i for conciseness.
",5. Generalized Probabilistic Programming Languages,[0],[0]
"2It has been shown that BLOG has equivalent semantics to other PPLs (Wu et al., 2014; McAllester et al., 2008).",5. Generalized Probabilistic Programming Languages,[0],[0]
Figure 1.,16 query Nationality(David) = USA;,[0],[0]
"A BLOG code for the GPA example.
",16 query Nationality(David) = USA;,[0],[0]
"We begin with a brief description of the core syntax of BLOG, with particular emphasis on (1) number statements, which are critical for expressing open-universe models3, and (2) new syntax for expressing MTBNs, i.e., the Mix distribution.",16 query Nationality(David) = USA;,[0],[0]
Further description of BLOG’s syntax can be found in Li & Russell (2013).,16 query Nationality(David) = USA;,[0],[0]
Fig. 1 shows a BLOG model with measure-theoretic extensions for a multi-student GPA example.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
"Line 1 declares two types, Applicant and Country.",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"Line 2 defines 3 distinct countries with keyword distinct, New Zealand, India and USA.",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"Lines 3 to 5 define a number statement, which states that the number of US applicants follows a Poisson distribution with a higher mean than those from New Zealand or India.",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"Line 6 defines an origin function, which maps the object being generated to the arguments that were used in the number statement that was responsible for generating it.",5.1. Syntax of measure-theoretic BLOG,[0],[0]
Here Nationality maps applicants to their nationalities.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
Lines 7 and 13 define two random variables by keyword random.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
Lines 7 to 12 state that the GPA of an applicant is distributed as a mixture of weighted discrete and continuous distributions.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
"For US applicants, the range of values 0",5.1. Syntax of measure-theoretic BLOG,[0],[0]
< GPA < 4 follows a truncated Gaussian with bounds 0 and 4 (line 9).,5.1. Syntax of measure-theoretic BLOG,[0],[0]
The probability mass outside the range is attributed to the corresponding bounds: P (GPA = 0),5.1. Syntax of measure-theoretic BLOG,[0],[0]
= P,5.1. Syntax of measure-theoretic BLOG,[0],[0]
(,5.1. Syntax of measure-theoretic BLOG,[0],[0]
GPA = 4) = 10−4 (line 10).,5.1. Syntax of measure-theoretic BLOG,[0],[0]
GPA distributions for other countries are specified similarly.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
Line 13 defines a random applicant David.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
"Line 15 states that the David’s GPA is observed to be 4 and we query in line 16 whether David is from USA.
",5.1. Syntax of measure-theoretic BLOG,[0],[0]
Number Statement (line 3 to 5) Fig. 2 shows the syntax of a number statement for Typei.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
"In this specification, gj are origin functions (discussed below); ȳj are tuples of arguments drawn from x̄ = x1, . .",5.1. Syntax of measure-theoretic BLOG,[0],[0]
.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
", xk; ϕj are first-order formulas with free variables ȳj ; ēj are tuples of expressions
3The specialized syntax in BLOG to express models with infinite number of variables.
",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"over a subset of x1, . . .",5.1. Syntax of measure-theoretic BLOG,[0],[0]
", xk; and cj(ēj) specify kernels κj : Π{Xτe :e∈ēj}Xe → N where τe is the type of the expression e.
#Typei(g1 = x1, . . .",5.1. Syntax of measure-theoretic BLOG,[0],[0]
", gk = xk) ∼",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"if ϕ1(ȳ1) then c1(ē1)
else if ϕ2(ȳ2) then c2(ē2)
.",5.1. Syntax of measure-theoretic BLOG,[0],[0]
". .
",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"else cm(ēm);
ments can be recovered using the origin functions gj , each of which is declared as:
origin Typej gj(Typei),
where Typej is the type of the argument xj in the number statement of Typei where gj was used.",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"The value of the jth variable used in the number statement that generated u, an element of the universe, is given by gj(u).",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"Line 6 in Fig. 1 is an example of origin function.
",5.1. Syntax of measure-theoretic BLOG,[0],[0]
Mixture Distribution (line 9 to 12),5.1. Syntax of measure-theoretic BLOG,[0],[0]
"In measure-theoretic BLOG, we introduce a new distribution, the mixture distribution (e.g., lines 9-10 in Fig. 1).",5.1. Syntax of measure-theoretic BLOG,[0],[0]
"A mixture distribution is specified as:
Mix({c1(ē1)→ w1(ē′), . . .",5.1. Syntax of measure-theoretic BLOG,[0],[0]
", ck(ēk)→ wk(ē′)}), where ci are arbitrary distributions, and wi’s are arbitrary real valued functions that sum to 1 for every possible assignment to their arguments: ∀ē′ ∑ i wi(ē
′) =",5.1. Syntax of measure-theoretic BLOG,[0.9930942735516413],"[', ck(ēk)→ wk(ē′)}), where ci are arbitrary distributions, and wi’s are arbitrary real valued functions that sum to 1 for every possible assignment to their arguments: ∀ē′ ∑ i wi(ē ′) = 1.']"
1.,5.1. Syntax of measure-theoretic BLOG,[0],[0]
"Note that in our implementation of measure-theoretical BLOG, we only allow a Mix distribution to express a mixture of densities and masses for simplifying the system design, although it still possible to express the same semantics without Mix.",5.1. Syntax of measure-theoretic BLOG,[1.0],"['Note that in our implementation of measure-theoretical BLOG, we only allow a Mix distribution to express a mixture of densities and masses for simplifying the system design, although it still possible to express the same semantics without Mix.']"
In this section we present the semantics of measure-theoretic BLOG and its theoretical properties.,5.2. Semantics of measure-theoretic BLOG,[0],[0]
Every BLOG model implicitly defines a first-order vocabulary consisting of the set of functions and types mentioned in the model.,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"BLOG’s semantics are based on the standard, open-universe semantics of first-order logic.",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"We first define the set of all possible elements that may be generated for a BLOG model.
",5.2. Semantics of measure-theoretic BLOG,[0],[0]
Definition 5.1.,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"The set of possible elements UM for a BLOG model M with types {τ1, . . .",5.2. Semantics of measure-theoretic BLOG,[0],[0]
", τk} is ⋃ j∈N{Uj}, where
• U0 = 〈U01 , . . .",5.2. Semantics of measure-theoretic BLOG,[0],[0]
", U0k 〉, U0j = {cj : cj is a distinct τi constant inM} • Ui+1",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"= 〈U i+11 , . . .",5.2. Semantics of measure-theoretic BLOG,[0],[0]
", U i+1 k 〉, where U i+1m = U",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"im ∪
{uν,ū,m : ν(x̄) is a number statement of type τm, ū is a tuple of elements of the type of x̄ from U i, m ∈ N}
Def.",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"5.1 allows us to define the set of random variables corresponding to a BLOG model.
",5.2. Semantics of measure-theoretic BLOG,[0],[0]
Definition 5.2.,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"The set of basic random variables for a BLOG modelM, BRV (M), consists of:
• for each number statement ν(x̄), a number variable",5.2. Semantics of measure-theoretic BLOG,[0],[0]
Vν,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"[ū] over the standard measurable space N, where ū is of the type of x̄. • for each function f(x̄) and tuple ū from UM of the type of x̄, a function application variable",5.2. Semantics of measure-theoretic BLOG,[0],[0]
Vf [ū] with the measurable space XVf,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"[ū] = Xτf , where Xτf is the measurable space corresponding to τf , the return type of f .
",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"We now define the space of consistent assignments to random variables.
",5.2. Semantics of measure-theoretic BLOG,[0],[0]
Definition 5.3.,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"An instantiation σ of the basic RVs defined by a BLOG modelM is consistent if and only if:
•",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"For every element uν,v̄,i used in an assignment of the form",5.2. Semantics of measure-theoretic BLOG,[0],[0]
σ(Vf [ū]),5.2. Semantics of measure-theoretic BLOG,[0],[0]
= w or σ(Vν [ū]),5.2. Semantics of measure-theoretic BLOG,[0],[0]
"= m > 0, σ(Vν",5.2. Semantics of measure-theoretic BLOG,[0],[0]
[v̄]),5.2. Semantics of measure-theoretic BLOG,[0],[0]
≥,5.2. Semantics of measure-theoretic BLOG,[0],[0]
i;,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"• For every fixed function symbol f with the interpretation f̃ , σ(Vf [ū]) = f̃(ū); and • For every element uν,ū=〈u1,...,um〉,i, generated by the number statement ν, with origin functions g1, . . .",5.2. Semantics of measure-theoretic BLOG,[0],[0]
", gm, for every gj ∈ {g1, . . .",5.2. Semantics of measure-theoretic BLOG,[0],[0]
", gm}, σ(Vgj [uν,ū,i]) = uj .",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"That is, origin functions give correct inverse maps.
",5.2. Semantics of measure-theoretic BLOG,[1.0000000196883123],"['That is, origin functions give correct inverse maps.']"
Lemma 5.4.,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"Every consistent assignment σ to the basic RVs forM defines a unique possible world in the vocabulary ofM.
The proof of Lemma 5.4 is in Appx.",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"F. In the following definition, we use the notation e[ū/x̄] to denote a substitution of every occurrence of the variable xi with ui in the expression e. For any BLOG modelM, let V (M) = BRV (M); for each v ∈ V , Xv is the measurable space corresponding to v. Let E(M) consist of the following edges for every number statement or function application statement of the form s(x̄):
• The edge (Vg[w̄], Vs[ū])",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"if g is a function symbol in M such that g(ȳ) appears in s(x̄), and either g(w̄) = g(ȳ)[ū/x̄] or an occurrence of g(ȳ) in s(x̄) uses quantified variables z1, . . .",5.2. Semantics of measure-theoretic BLOG,[0],[0]
", zn, ū′ is a tuple of elements of the type of z̄ and g(w̄) = g(ȳ)[ū/x̄][ū′/z̄].",5.2. Semantics of measure-theoretic BLOG,[0],[0]
"• The edge (Vν [v̄], Vs[ū]), for element uν,v̄,i ∈ ū.
Note that the first set of edges defined in E(M) above may include infinitely many parents for Vs[ū].",5.2. Semantics of measure-theoretic BLOG,[0],[0]
Let the dependency statement in the BLOG model M corresponding to a number or function variable Vs[f̄ ] be s. Let expr(s) be the set of expressions used in s.,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"Each such statement then defines in a straightforward manner, a kernel Ks(ū) : Xexpr(s(ū))",5.2. Semantics of measure-theoretic BLOG,[0],[0]
→ XVs[ū].,5.2. Semantics of measure-theoretic BLOG,[0],[0]
"In order ensure consistent assignments, we include a special value null ∈",5.2. Semantics of measure-theoretic BLOG,[0],[0]
Xτ for each τ,5.2. Semantics of measure-theoretic BLOG,[0],[0]
Figure 3.,9 query hasFakeCoin;,[0],[0]
"BLOG code for the Scale example
inM, and require that Ks(ū)(σ(pa(Vs[ū])), {null}c) = 0",9 query hasFakeCoin;,[0],[0]
whenever σ violates the first condition of consistent assignments (Def. 5.3).,9 query hasFakeCoin;,[0],[0]
"In other words, all the local kernels ensure are locally consistent: variables involving an object uν,ū,i get a non-null assignment only if the assignment to its number statement represents the generation of at least i objects (σ(Vν(ū))",9 query hasFakeCoin;,[0],[0]
≥ i).,9 query hasFakeCoin;,[0],[0]
"Each kernel of the formKs(ū) can be transformed into a kernel Kpa(Vs[ū]) from its parent vertices (representing basic random variables) by composing the kernels determining the truth value of each expression e ∈ expr(v) in terms of the basic random variables, with the kernel KeVs[ū].",9 query hasFakeCoin;,[0],[0]
Let κ(M) = {Kpa(Vs[ū]) : Vs[ū] ∈ BRV (M)}.,9 query hasFakeCoin;,[0],[0]
Definition 5.5.,9 query hasFakeCoin;,[0],[0]
"The MTBN M for a BLOG model M is defined using V = V (M), E = E(M), the set of measurable spaces {Xv : v ∈ BRV (M)} and the kernels for each vertex given by κ(M).
",9 query hasFakeCoin;,[0],[0]
"By Thm. 3.6, we have the main result of this section, which provides the theoretical foundation for the generalized BLOG language:
Theorem 5.6.",9 query hasFakeCoin;,[0],[0]
"If the MTBNM for a BLOG model is a wellfounded digraph, thenM represents a unique measure µ on XBRV (M).",9 query hasFakeCoin;,[0],[0]
"We implemented the measure-theoretic extension of BLOG and evaluated our inference algorithms on three models where naive algorithms fail: (1) the GPA model (GPA); (2) the noisy scale model (Scale); and (3) a SSM, the aircraft tracking model (Aircraft-Tracking).",6. Experiment Results,[0],[0]
"The implementation is based on BLOG’s C++ compiler (Wu et al., 2016).
",6. Experiment Results,[0.9999999983170967],"['The implementation is based on BLOG’s C++ compiler (Wu et al., 2016).']"
GPA model: Fig. 1 presents the BLOG code for the GPA example as explained in Sec. 5.,6. Experiment Results,[0],[0]
"Since the GPA of David is exactly 4, Bayes rule implies that David must be from USA.",6. Experiment Results,[0],[0]
"We evaluate LLW and the naive LW on this model in Fig 4(a), where the naive LW converges to an incorrect posterior.
",6. Experiment Results,[0],[0]
Scale model:,6. Experiment Results,[0],[0]
"In the noisy scale example (Fig. 3), we have an even number of coins and there might be a fake coin among them (Line 4).",6. Experiment Results,[0],[0]
The fake coin will be slightly heavier than a normal coin (Line 2-3).,6. Experiment Results,[0],[0]
We divide the coins into two halves and place them onto a noisy scale.,6. Experiment Results,[0],[0]
"When there is no fake coin, the scale always balances (Line 7).
",6. Experiment Results,[0],[0]
"When there is a fake coin, the scale will noisily reflect the weight difference with standard deviation σ",6. Experiment Results,[0],[0]
(sigma in Line 6).,6. Experiment Results,[0],[0]
Now we observe that the scale is balanced (Line 8),6. Experiment Results,[0],[0]
and we would like to infer whether a fake coin exists.,6. Experiment Results,[0],[0]
We again compare LLW against the naive LW with different choices of the σ parameter in Fig. 4(b).,6. Experiment Results,[0],[0]
"Since the scale is precisely balanced, there must not be a fake coin.",6. Experiment Results,[0],[0]
"LLW always produces the correct answer but naive LW converges to different incorrect posteriors for different values of σ; as σ increases, naive LWs result approaches the true posterior.
",6. Experiment Results,[0],[0]
Aircraft-Tracking model: Fig. 5 shows a simplified BLOG model for the aircraft tracking example.,6. Experiment Results,[0],[0]
"In this state-space model, we have N = 6 radar points (Line 1) and a single aircraft to track.",6. Experiment Results,[0],[0]
Both the radars and the aircraft are considered as points on a 2D plane.,6. Experiment Results,[0],[0]
The prior of the aircraft movement is a Gaussian process (Line 3 to 6).,6. Experiment Results,[0],[0]
"Each radar r has an effective range radius(r): if the aircraft is within the range, the radar will noisily measure the distance from the aircraft to its own location (Line 13); if the aircraft is out of range, the radar will almost surely just output its radius (Line 10 to 11).",6. Experiment Results,[0],[0]
Now we observe the measurements from all the radar points for T time steps and we want to infer the location of the aircraft.,6. Experiment Results,[0],[0]
"With the measure-theoretic extension, a generalized BLOG program is more expressive for modeling truncated sensors: if a radar outputs exactly its radius, we can surely infer that the aircraft must be out of the effective range of this radar.",6. Experiment Results,[0],[0]
"However, this information cannot be captured by the original BLOG language.",6. Experiment Results,[0],[0]
"To illustrate this case, we manually generated a synthesis dataset of T = 8 time steps4 and evaluated LPF against the naive particle filter with different numbers of particles in Fig. 4(c).",6. Experiment Results,[0],[0]
We take the mean of the samples from all the particles as the predicted aircraft location.,6. Experiment Results,[1.0],['We take the mean of the samples from all the particles as the predicted aircraft location.']
"Since we know the ground truth, we measure the average mean square error between the true location and the prediction.",6. Experiment Results,[0],[0]
"LPF accurately predicts the
4The full BLOG programs with complete data are available at https://goo.gl/f7qLwy.",6. Experiment Results,[0],[0]
Figure 5.,18 query Y(t) for Timestep t;,[0],[0]
"BLOG code for the Aircraft-Tracking example
true locations while the naive PF converges to the incorrect results.",18 query Y(t) for Timestep t;,[1.0000000189195977],['BLOG code for the Aircraft-Tracking example true locations while the naive PF converges to the incorrect results.']
"We presented a new formalization, measure-theoretic Bayesian networks, for generalizing the semantics of PPLs to include random variables with mixtures of discrete and continuous distributions.",7. Conclusion,[1.0],"['We presented a new formalization, measure-theoretic Bayesian networks, for generalizing the semantics of PPLs to include random variables with mixtures of discrete and continuous distributions.']"
"We developed provably correct inference algorithms for such random variables and incorporated MTBNs into a widely used PPL, BLOG.",7. Conclusion,[1.0],"['We developed provably correct inference algorithms for such random variables and incorporated MTBNs into a widely used PPL, BLOG.']"
"We believe that together with the foundational inference algorithms, our proposed rigorous framework will facilitate the development of powerful techniques for probabilistic reasoning in practical applications from a much wider range of scientific areas.",7. Conclusion,[1.0],"['We believe that together with the foundational inference algorithms, our proposed rigorous framework will facilitate the development of powerful techniques for probabilistic reasoning in practical applications from a much wider range of scientific areas.']"
"This work is supported by the DARPA PPAML program, contract FA8750-14-C-0011.",Acknowledgment,[0],[0]
"Simon S. Du is funded by NSF grant IIS1563887, AFRL grant FA8750-17-2-0212 and DARPA D17AP00001.",Acknowledgment,[0],[0]
"Despite the recent successes of probabilistic programming languages (PPLs) in AI applications, PPLs offer only limited support for random variables whose distributions combine discrete and continuous elements.",abstractText,[0],[0]
We develop the notion of measure-theoretic Bayesian networks (MTBNs) and use it to provide more general semantics for PPLs with arbitrarily many random variables defined over arbitrary measure spaces.,abstractText,[0],[0]
"We develop two new general sampling algorithms that are provably correct under the MTBN framework: the lexicographic likelihood weighting (LLW) for general MTBNs and the lexicographic particle filter (LPF), a specialized algorithm for statespace models.",abstractText,[0],[0]
"We further integrate MTBNs into a widely used PPL system, BLOG, and verify the effectiveness of the new inference algorithms through representative examples.",abstractText,[0],[0]
Discrete-Continuous Mixtures in Probabilistic Programming: Generalized Semantics and Inference Algorithms,title,[0],[0]
