{"sections": [{"heading": "1. Introduction", "text": "Deep neural networks achieve near-human accuracy on many perception tasks (He et al., 2016; Amodei et al., 2015). However, they lack robustness to small alterations of the inputs at test time (Szegedy et al., 2014). Indeed when presented with a corrupted image that is barely distinguishable from a legitimate one by a human, they can predict incorrect labels, with high-confidence. An adversary can design such so-called adversarial examples, by adding a small perturbation to a legitimate input to maximize the likelihood of an incorrect class under constraints on the magnitude of the perturbation (Szegedy et al., 2014; Goodfellow et al., 2015; Moosavi-Dezfooli et al., 2015; Pa-\n1Facebook AI Research. Correspondence to: Moustapha Cisse <moustaphacisse@fb.com>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\npernot et al., 2016a). In practice, for a significant portion of inputs, a single step in the direction of the gradient sign is sufficient to generate an adversarial example (Goodfellow et al., 2015) that is even transferable from one network to another one trained for the same problem but with a different architecture (Liu et al., 2016; Kurakin et al., 2016).\nThe existence of transferable adversarial examples has two undesirable corollaries. First, it creates a security threat for production systems by enabling black-box attacks (Papernot et al., 2016a). Second, it underlines the lack of robustness of neural networks and questions their ability to generalize in settings where the train and test distributions can be (slightly) different as is the case for the distributions of legitimate and adversarial examples.\nWhereas the earliest works on adversarial examples already suggested that their existence was related to the magnitude of the hidden activations gradient with respect to their inputs (Szegedy et al., 2014), they also empirically assessed that standard regularization schemes such as weight decay or training with random noise do not solve the problem (Goodfellow et al., 2015; Fawzi et al., 2016). The current mainstream approach to improving the robustness of deep networks is adversarial training. It consists in generating adversarial examples on-line using the current network\u2019s parameters (Goodfellow et al., 2015; Miyato et al., 2015; Moosavi-Dezfooli et al., 2015; Szegedy et al., 2014; Kurakin et al., 2016) and adding them to the training data. This data augmentation method can be interpreted as a robust optimization procedure (Shaham et al., 2015).\nIn this paper, we introduce Parseval networks, a layerwise regularization method for reducing the network\u2019s sensitivity to small perturbations by carefully controlling its global Lipschitz constant. Since the network is a composition of functions represented by its layers, we achieve increased robustness by maintaining a small Lipschitz constant (e.g., 1) at every hidden layer; be it fully-connected, convolutional or residual. In particular, a critical quantity governing the local Lipschitz constant in both fully connected and convolutional layers is the spectral norm of the weight matrix. Our main idea is to control this norm by parameterizing the network with parseval tight frames (Kovac\u030cevic\u0301 & Chebira, 2008), a generalization of orthogonal matrices.\nThe idea that regularizing the spectral norm of each weight\nmatrix could help in the context of robustness appeared as early as (Szegedy et al., 2014), but no experiment nor algorithm was proposed, and no clear conclusion was drawn on how to deal with convolutional layers. Previous work, such as double backpropagation (Drucker & Le Cun, 1992) has also explored jacobian normalization as a way to improve generalization. Our contribution is twofold. First, we provide a deeper analysis which applies to fully connected networks, convolutional networks, as well as Residual networks (He et al., 2016). Second, we propose a computationally efficient algorithm and validate its effectiveness on standard benchmark datasets. We report results on MNIST, CIFAR-10, CIFAR-100 and Street View House Numbers (SVHN), in which fully connected and wide residual networks were trained (Zagoruyko & Komodakis, 2016) with Parseval regularization. The accuracy of Parseval networks on legitimate test examples matches the state-of-the-art, while the results show notable improvements on adversarial examples. Besides, Parseval networks train significantly faster than their vanilla counterpart.\nIn the remainder of the paper, we first discuss the previous work on adversarial examples. Next, we give formal definitions of the adversarial examples and provide an analysis of the robustness of deep neural networks. Then, we introduce Parseval networks and its efficient training algorithm. Section 5 presents experimental results validating the model and providing several insights."}, {"heading": "2. Related work", "text": "Early papers on adversarial examples attributed the vulnerability of deep networks to high local variations (Szegedy et al., 2014; Goodfellow et al., 2015). Some authors argued that this sensitivity of deep networks to small changes in their inputs is because neural networks only learn the discriminative information sufficient to obtain good accuracy rather than capturing the true concepts defining the classes (Fawzi et al., 2015; Nguyen et al., 2015).\nStrategies to improve the robustness of deep networks include defensive distillation (Papernot et al., 2016b), as well as various regularization procedures such as contractive networks (Gu & Rigazio, 2015). However, the bulk of recent proposals relies on data augmentation (Goodfellow et al., 2015; Miyato et al., 2015; Moosavi-Dezfooli et al., 2015; Shaham et al., 2015; Szegedy et al., 2014; Kurakin et al., 2016). It uses adversarial examples generated online during training. As we shall see in the experimental section, regularization can be complemented with data augmentation; in particular, Parseval networks with data augmentation appear more robust than either data augmentation or Parseval networks considered in isolation."}, {"heading": "3. Robustness in Neural Networks", "text": "We consider a multiclass prediction setting, where we have Y classes in Y = {1, ..., Y }. A multiclass classifier is a function g\u0302 : (x \u2208 RD,W \u2208 W) 7\u2192 argmaxy\u0304\u2208Y gy\u0304(x,W ), where W are the parameters to be learnt, and gy\u0304(x,W ) is the score given to the (input, class) pair (x, y\u0304) by a function g : RD \u00d7 W \u2192 RY . We take g to be a neural network, represented by a computation graph G = (N , E), which is a directed acyclic graph with a single root node, and each node n \u2208 N takes values in Rd (n) out and is a function of its children in the graph, with learnable parameters W (n):\nn : x 7\u2192 \u03c6(n) ( W (n), ( n\u2032(x) ) n\u2032:(n,n\u2032)\u2208E ) . (1)\nThe function g we want to learn is the root of G. The training data ((xi, yi))mi=1 \u2208 (X \u00d7 Y)m is an i.i.d. sample of D, and we assume X \u2282 RD is compact. A function ` : RY \u00d7 Y \u2192 R measures the loss of g on an example (x, y); in a single-label classification setting for instance, a common choice for ` is the log-loss:\n` ( g(x,W ), y ) = \u2212gy(x,W ) + log (\u2211 y\u0304\u2208Y egy\u0304(x,W ) ) . (2)\nThe arguments that we develop below depend only on the Lipschitz constant of the loss, with respect to the norm of interest. Formally, we assume that given a p-norm of interest \u2016.\u2016p, there is a constant \u03bbp such that\n\u2200z, z\u2032 \u2208 RY ,\u2200y\u0304 \u2208 Y, |`(z, y\u0304)\u2212`(z\u2032, y\u0304)| \u2264 \u03bbp\u2016z\u2212z\u2032\u2016p .\nFor the log-loss of (2), we have \u03bb2 \u2264 \u221a\n2 and \u03bb\u221e \u2264 2. In the next subsection, we define adversarial examples and the generalization performance of the classifier. Then, we make the relationship between robustness to adversarial examples and the lipschitz constant of the networks."}, {"heading": "3.1. Adversarial examples", "text": "Given an input (train or test) example (x, y), an adversarial example is a perturbation of the input pattern x\u0303 = x + \u03b4x where \u03b4x is small enough so that x\u0303 is nearly undistinguishable from x (at least from the point of view of a human annotator), but has the network predict an incorrect label. Given the network parameters and structure g(.,W ) and a p-norm, the adversarial example is formally defined as\nx\u0303 = argmax x\u0303:\u2016x\u0303\u2212x\u2016p\u2264\n` ( g(x\u0303,W ), y ) , (3)\nwhere represents the strength of the adversary. Since the optimization problem above is non-convex, Shaham et al. (2015) propose to take the first order taylor expansion of x 7\u2192 `(g(x,W ), y) to compute \u03b4x by solving\nx\u0303 = argmax x\u0303:\u2016x\u0303\u2212x\u2016p\u2264\n( \u2207x`(g(x,W ), y) )T (x\u0303\u2212 x) . (4)\nIf p = \u221e, then x\u0303 = x + sign(\u2207x`(g(x,W ), y)). This is the fast gradient sign method. For the case p = 2, we obtain x\u0303 = x + \u2207x`(g(x,W ), y). A more involved method is the iterative fast gradient sign method, in which several gradient steps of (4) are performed with a smaller stepsize to obtain a local minimum of (3)."}, {"heading": "3.2. Generalization with adversarial examples", "text": "In the context of adversarial examples, there are two different generalization errors of interest:\nL(W ) = E (x,y)\u223cD\n[ `(g(x,W ), y) ] ,\nLadv(W,p, ) = E (x,y)\u223cD\n[ max\nx\u0303:\u2016x\u0303\u2212x\u2016p\u2264 `(g(x\u0303,W ), y)\n] .\nBy definition, L(W ) \u2264 Ladv(W,p, ) for every p and >0. Reciprocally, denoting by \u03bbp and \u039bp the Lipschitz constant (with respect to \u2016.\u2016p) of ` and g respectively, we have:\nLadv(W,p, ) \u2264 L(W ) + E\n(x,y)\u223cD\n[ max\nx\u0303:\u2016x\u0303\u2212x\u2016p\u2264 |`(g(x\u0303,W ), y)\u2212 `(g(x,W ), y)| ] \u2264 L(W ) + \u03bbp\u039bp .\nThis suggests that the sensitivity to adversarial examples can be controlled by the Lipschitz constant of the network. In the robustness framework of (Xu & Mannor, 2012), the Lipschitz constant also controls the difference between the average loss on the training set and the generalization performance. More precisely, let us denote by Cp(X , \u03b3) the covering number of X using \u03b3-balls for \u2016.\u2016p. Using M = supx,W,y `(g(x,W ), y), Theorem 3 of (Xu & Mannor, 2012) implies that for every \u03b4 \u2208 (0, 1), with probability 1\u2212 \u03b4 over the i.i.d. sample ((xi, yi)mi=1, we have:\nL(W ) \u2264 1 m m\u2211 i=1 `(g(xi,W ), yi)\n+ \u03bbp\u039bp\u03b3 +M\n\u221a 2Y Cp(X , \u03b32 ) ln(2)\u2212 2 ln(\u03b4)\nm .\nSince covering numbers of a p-norm ball in RD increases exponentially with RD, the bound above suggests that it is critical to control the Lipschitz constant of g, for both good generalization and robustness to adversarial examples."}, {"heading": "3.3. Lipschitz constant of neural networks", "text": "From the network structure we consider (1), for every node n \u2208 N , we have (see below for the definition of \u039b(n,n \u2032) p ):\n\u2016n(x)\u2212 n(x\u0303)\u2016p \u2264 \u2211\nn\u2032:(n,n\u2032)\u2208E\n\u039b(n,n \u2032) p \u2016n\u2032(x)\u2212 n\u2032(x\u0303)\u2016p ,\nfor any \u039b(n,n \u2032)\np that is greater than the worst case variation of n with respect to a change in its input n\u2032(x). In particular we can take for \u039b(n,n \u2032) p any value greater than the\nsupremum over x0 \u2208 X of the Lipschitz constant for \u2016.\u2016p of the function (1n\u2032\u2032 = n\u2032 is 1 if n\u2032\u2032 = n\u2032 and 0 otherwise):\nx 7\u2192 \u03c6(n) ( W (n), ( n\u2032\u2032(x0+1n \u2032\u2032 = n\u2032(x\u2212x0)) ) n\u2032\u2032:(n,n\u2032\u2032)\u2208E ) .\nThe Lipschitz constant of n, denoted by \u039b(n)p satisfies:\n\u039b(n)p \u2264 \u2211\nn\u2032:(n,n\u2032)\u2208E\n\u039b(n,n \u2032) p \u039b (n\u2032) p (5)\nThus, the Lipschitz constant of the network g can grow exponentially with its depth. We now give the Lipschitz constants of standard layers as a function of their parameters:\nLinear layers: For layer n(x) = W (n)n\u2032(x) where n\u2032 is the unique child of n in the graph, the Lipschitz constant for \u2016.\u2016p is, by definition, the matrix norm of W (n) induced by \u2016.\u2016p, which is usually denoted \u2016W (n)\u2016p and defined by\n\u2016W (n)\u2016p = sup z:\u2016z\u2016p=1 \u2016W (n)z\u2016p .\nThen \u039b(n)2 = \u2016W (n)\u20162\u039b (n\u2032) 2 , where \u2016W (n)\u20162, called the spectral norm of W (n), is the maximum singular value of W (n). We also have \u039b(n)\u221e = \u2016W (n)\u2016\u221e\u039b(n \u2032) \u221e , where\n\u2016W (n)\u2016\u221e = maxi \u2211 j |W (n) ij | is the maximum 1-norm of the rows. W (n).\nConvolutional layers: To simplify notation, let us consider convolutions on 1D inputs without striding, and we take the width of the convolution to be 2k + 1 for k \u2208 N. To write convolutional layers in the same way as linear layers, we first define an unfolding operator U , which prepares the input z, denoted by U(z). If the input has length T with din inputs channels, the unfolding operator maps z For a convolution of the unfolding of z considered as a T \u00d7 (2k + 1)din matrix, its j-th column is:\nUj(z) = [zj\u2212k; ...; zj+k] ,\nwhere \u201c;\u201d is the concatenation along the vertical axis (each zi is seen as a column din-dimensional vector), and zi = 0 if i is out of bounds (0-padding). A convolutional layer with dout output channels is then defined as\nn(x) = W (n) \u2217 n\u2032(x) = W (n)U(n\u2032(x)) ,\nwhere W (n) is a dout \u00d7 (2k + 1)din matrix. We thus have \u039b\n(n) 2 \u2264 \u2016W\u20162\u2016U(n\u2032(x))\u20162. Since U is a linear operator that essentially repeats its input (2k + 1) times, we have \u2016U(n\u2032(x)) \u2212 U(n\u2032(x\u0303))\u201622 \u2264 (2k + 1)\u2016n\u2032(x) \u2212 n\u2032(x\u0303)\u201622, so that \u039b(n)2 \u2264 \u221a 2k + 1\u2016W\u20162\u039b(n \u2032) 2 . Also, \u2016U(n\u2032(x)) \u2212 U(n\u2032(x\u0303))\u2016\u221e = \u2016n\u2032(x) \u2212 n\u2032(x\u0303)\u2016\u221e, and so for a convolutional layer, \u039b(n)\u221e \u2264 \u2016W (n)\u2016\u221e\u039b(n \u2032) \u221e .\nAggregation layers/transfer functions: Layers that perform the sum of their inputs, as in Residual Netowrks (He et al., 2016), fall in the case where the values \u039b(n,n \u2032) p in (5) come into play. For a node n that sums its inputs, we have \u039b (n,n\u2032) p = 1, and thus \u039b (n) p \u2264 \u2211 n\u2032:(n,n\u2032)\u2208E \u039b (n\u2032) p . If n is a tranfer function layer (e.g., an element-wise application of ReLU) we can check that \u039b(n)p \u2264 \u039b(n \u2032) p , where n\u2032 is the input node, as soon as the Lipschitz constant of the transfer function (as a function R\u2192 R) is \u2264 1."}, {"heading": "4. Parseval networks", "text": "Parseval regularization, which we introduce in this section, is a regularization scheme to make deep neural networks robust, by constraining the Lipschitz constant (5) of each hidden layer to be smaller than one, assuming the Lipschitz constant of children nodes is smaller than one. That way, we avoid the exponential growth of the Lipschitz constant, and a usual regularization scheme (i.e., weight decay) at the last layer then controls the overall Lipschitz constant of the network. To enforce these constraints in practice, Parseval networks use two ideas: maintaining orthonormal rows in linear/convolutional layers, and performing convex combinations in aggregation layers. Below, we first explain the rationale of these constraints and then describe our approach to efficiently enforce the constraints during training."}, {"heading": "4.1. Parseval Regularization", "text": "Orthonormality of weight matrices: For linear layers, we need to maintain the spectral norm of the weight matrix at 1. Computing the largest singular value of weight matrices is not practical in an SGD setting unless the rows of the matrix are kept orthogonal. For a weight matrix W \u2208 Rdout\u00d7din with dout \u2264 din, Parseval regularization maintains WTW \u2248 Idout\u00d7dout , where I refers to the identity matrix. W is then approximately a Parseval tight frame (Kovac\u030cevic\u0301 & Chebira, 2008), hence the name of Parseval networks. For convolutional layers, the matrix W \u2208 Rdout\u00d7(2k+1)din is constrained to be a Parseval tight frame (with the notations of the previous section), and the output is rescaled by a factor (2k + 1)\u22121/2. This maintains all singular values of W to (2k+ 1)\u22121/2, so that \u039b\n(n) 2 \u2264 \u039b (n\u2032) 2 where n\n\u2032 is the input node. More generally, keeping the rows of weight matrices orthogonal makes it possible to control both the spectral norm and the \u2016.\u2016\u221e of a weight matrix through the norm of its individual rows. Robustness for \u2016.\u2016\u221e is achieved by rescaling the rows so that their 1-norm is smaller than 1. For now, we only experimented with constraints on the 2-norm of the rows, so we aim for robustness in the sense of \u2016.\u20162.\nRemark 1 (Orthogonality is required). Without orthogonality, constraints on the 2-norm of the rows of weight ma-\ntrices are not sufficient to control the spectral norm. Parseval networks are thus fundamentally different from weight normalization (Salimans & Kingma, 2016).\nAggregation Layers: In parseval networks, aggregation layers do not make the sum of their inputs, but rather take a convex combination of them:\nn(x) = \u2211\nn\u2032:(n,n\u2032)\u2208E\n\u03b1(n,n \u2032)n\u2032(x)\nwith \u2211 n\u2032:(n,n\u2032)\u2208E \u03b1 (n,n\u2032) = 1 and \u03b1(n,n \u2032) \u2265 0. The parameters \u03b1(n,n \u2032) are learnt, but using (5), these constraint guarantee that \u039b(n)p \u2264 1 as soon as the children satisfy the inequality for the same p-norm."}, {"heading": "4.2. Parseval Training", "text": "Orthonormality constraints: The first significant difference between Parseval networks and its vanilla counterpart is the orthogonality constraint on the weight matrices. This requirement calls for an optimization algorithm on the manifold of orthogonal matrices, namely the Stiefel manifold. Optimization on matrix manifolds is a well-studied topic (see (Absil et al., 2009) for a comprehensive survey). The simplest first-order geometry approaches consist in optimizing the unconstrained function of interest by moving in the direction of steepest descent (given by the gradient of the function) while at the same time staying on the manifold. To guarantee that we remain in the manifold after every parameter update, we need to define a retraction operator. There exist several pullback operators for embedded submanifolds such as the Stiefel manifold based for example on Cayley transforms (Absil et al., 2009). However, when learning the parameters of neural networks, these methods are computationally prohibitive. To overcome this difficulty, we use an approximate operator derived from the following layer-wise regularizer of weight matrices to ensure their parseval tightness (Kovac\u030cevic\u0301 & Chebira, 2008):\nR\u03b2(Wk) = \u03b2\n2 \u2016W>k Wk \u2212 I\u201622.\nOptimizing R\u03b2(Wk) to convergence after every gradient descent step (w.r.t the main objective) guarantees us to stay on the desired manifold but this is an expensive procedure. Moreover, it may result in parameters that are far from the ones obtained after the main gradient update. We use two approximations to make the algorithm more efficient: First, we only do one step of descent on the function R\u03b1(Wk). The gradient of this regularization term is\u2207WkR\u03b2(Wk) = \u03b2(WkW > k \u2212 I)Wk. Consequently, after every main update we perform the following secondary update:\nWk \u2190 (1 + \u03b2)Wk \u2212 \u03b2WkW>k Wk.\nAlgorithm 1 Parseval Training \u0398 = {Wk,\u03b1k}Kk=1, e\u2190 0 while e \u2264 E do\nSample a minibatch {(xi, yi)}Bi=1. for k \u2208 {1, . . . ,K} do\nCompute the gradient: GWk \u2190 \u2207Wk`(\u0398, {(xi, yi)}), G\u03b1k \u2190 \u2207\u03b1k`(\u0398, {(xi, yi)}). Update the parameters: Wk \u2190Wk \u2212 \u00b7GWk \u03b1k \u2190 \u03b1k \u2212 \u00b7G\u03b1k . if hidden layer then\nSample a subset S of rows of Wk. Projection: WS \u2190 (1 + \u03b2)WS \u2212 \u03b2WSW>S WS . \u03b1k \u2190 argmin\u03b3\u2208\u2206K\u22121\u2016\u03b1K \u2212 \u03b3\u201622\ne\u2190 e+ 1.\nOptionally, instead of updating the whole matrix, one can randomly select a subset S of rows and perform the update from Eq. (4.2) on the submatrix composed of rows indexed by S. This sampling based approach reduces the overall complexity to O(|S|2d). Provided the rows are carefully sampled, the procedure is an accurate Monte Carlo approximation of the regularizer loss function (Drineas et al., 2006). The optimal sampling probabilities, also called statistical leverages are approximately equal if we start from an orthogonal matrix and (approximately) stay on the manifold throughout the optimization since they are proportional to the eigenvalues of W (Mahoney et al., 2011). Therefore, we can sample a subset of columns uniformly at random when applying this projection step.\nWhile the full update does not result in an increased overhead for convolutional layers, the picture can be very different for large fully connected layers making the sampling approach computationally more appealing for such layers. We show in the experiments that the weight matrices resulting from this procedure are (quasi)-orthogonal. Also, note that quasi-orthogonalization procedures similar to the one described here have been successfully used previously in the context of learning overcomplete representations with independent component analysis (Hyv\u00e4rinen & Oja, 2000).\nConvexity constraints in aggregation layers: In Parseval networks, aggregation layers output a convex combination of their inputs instead of e.g., their sum as in Residual networks (He et al., 2016). For an aggregation node n of the network, let us denote by \u03b1 = (\u03b1(n,n\n\u2032))n\u2032:(n,n\u2032)\u2208E the K-size vector of coefficients used for the convex combination output by the layer. To ensure that the Lipschitz constant at the node n is such that \u039b(n)p \u2264 1, the constraints of 4.1 call for a euclidean projection of \u03b1 onto the positive simplex after a gradient update:\n\u03b1\u2217 = argmin \u03b3\u2208\u2206K\u22121 \u2016\u03b1\u2212 \u03b3\u201622 ,\nwhere \u2206K\u22121 = {\u03b3 \u2208 RK |1>\u03b3 = 1,\u03b3 \u2265 0}. This is a well studied problem (Michelot, 1986; Pardalos & Kovoor, 1990; Duchi et al., 2008; Condat, 2016). Its solution is of the form: \u03b1\u2217i = max(0, \u03b1i \u2212 \u03c4(\u03b1)), with \u03c4 : RK \u2192 R the unique function satisfying \u2211 i(xi \u2212 \u03c4(\u03b1)) = 1 for every x \u2208 RK . Therefore, the solution essentially boils down to a soft thresholding operation. If we denote \u03b11 \u2265 \u03b12 \u2265 . . . \u03b1K the sorted coefficients and k(\u03b1) = max{k \u2208 (1, . . . ,K)|1+k\u03b1k > \u2211 j\u2264k \u03b1j}, the optimal thresholding is given by (Duchi et al., 2008):\n\u03c4(\u03b1) = ( \u2211 j\u2264k(\u03b1) \u03b1j)\u2212 1 k(\u03b1)\nConsequently, the complexity of the projection is O(K log(K)) since it is only dominated by the sorting of the coefficients and is typically cheap because aggregation nodes will only have few children in practice (e.g. 2). If the number of children is large, there exist efficient linear time algorithms for finding the optimal thresholding \u03c4(\u03b1) (Michelot, 1986; Pardalos & Kovoor, 1990; Condat, 2016). In this work, we use the method detailed above (Duchi et al., 2008) to perform the projection of the coefficient \u03b1 after every gradient update step."}, {"heading": "5. Experimental evaluation", "text": "We evaluate the effectiveness of Parseval networks on well-established image classification benchmark datasets namely MNIST, CIFAR-10, CIFAR-100 (Krizhevsky, 2009) and Street View House Numbers (SVHN) (Netzer et al.). We train both fully connected networks and wide residual networks. The details of the datasets, the models, and the training routines are summarized below."}, {"heading": "5.1. Datasets", "text": "CIFAR. Each of the CIFAR datasets is composed of 60K natural scene color images of size 32 \u00d7 32 split between 50K training images and 10K test images. CIFAR-10 and CIFAR-100 have respectively 10 and 100 classes. For these two datasets, we adopt the following standard preprocessing and data augmentation scheme (Lin et al., 2013; He et al., 2016; Huang et al., 2016a; Zagoruyko & Komodakis, 2016): Each training image is first zero-padded with 4 pixels on each side. The resulting image is randomly cropped to produce a new 32 \u00d7 32 image which is subsequently horizontally flipped with probability 0.5. We also normalize every image with the mean and standard deviation of its channels. Following the same practice as (Huang et al., 2016a), we initially use 5K images from the training as a validation set. Next, we train de novo the best model on the full set of 50K images and report the results on the test set. SVHN The Street View House Number dataset is a set of 32\u00d7 32 color digit images officially split into 73257 training images and 26032 test images. Following common practice (Zagoruyko & Komodakis, 2016; He et al., 2016; Huang et al., 2016a;b), we randomly sample 10000 images from the available extra set of about 600K images as a validation set and combine the rest of the pictures with the official training set. We divide the pixel values by 255 as a preprocessing step and report the test set performance of the best performing model on the validation set."}, {"heading": "5.2. Models and Implementation details", "text": "ConvNet Models. For the CIFAR and SVHN datasets, we trained wide residual networks (Zagoruyko & Komodakis, 2016) as they perform on par with standard resnets (He et al., 2016) while being faster to train thanks to a reduced depth. We used wide resnets of depth 28 and width 10 for both CIFAR-10 and CIFAR-100. For SVHN we used wide resnet of depth 16 and width 4. For each architecture, we compare Parseval networks with the vanilla model trained with standard regularization both in the adversarial and the non-adversarial training settings.\nConvNet Training. We train the networks with stochastic gradient descent using a momentum of 0.9. On CIFAR datasets, the initial learning rate is set to 0.1 and scaled by a factor of 0.2 after epochs 60, 120 and 160, for a total number of 200 epochs. We used mini-batches of size 128. For SVHN, we trained the models with mini-batches of size 128 for 160 epochs starting with a learning rate of 0.01 and decreasing it by a factor of 0.1 at epochs 80 and 120. For all the vanilla models, we applied by default weight decay regularization (with parameter \u03bb = 0.0005) together with batch normalization and dropout since this combination resulted in better accuracy and increased robustness in preliminary experiments. The dropout rate use\nis 0.3 for CIFAR and 0.4 for SVHN. For Parseval regularized models, we choose the value of the retraction parameter to be \u03b2 = 0.0003 for CIFAR datasets and \u03b2 = 0.0001 for SVHN based on the performance on the validation set. In all cases, We also adversarially trained each of the models on CIFAR-10 and CIFAR-100 following the guidelines in (Goodfellow et al., 2015; Shaham et al., 2015; Kurakin et al., 2016). In particular, we replace 50% of the examples of every minibatch by their adversarially perturbed version generated using the one-step method to avoid label leaking (Kurakin et al., 2016). For each mini-batch, the magnitude of the adversarial perturbation is obtained by sampling from a truncated Gaussian centered at 0 with standard deviation 2.\nFully Connected Model. We also train feedforward networks composed of 4 fully connected hidden layers of size 2048 and a classification layer. The input to these networks are images unrolled into a C \u00d7 1024 dimensional vector where C is the number of channels. We used these models on MNIST and CIFAR-10 mainly to demonstrate that the proposed approach is also useful on non-convolutional networks. We compare a Parseval networks to vanilla models with and without weight decay regularization. For adversarially trained models, we follow the guidelines previously described for the convolutional networks.\nFully Connected Training. We train the models with SGD and divide the learning rate by two every 10 epochs. We use mini-batches of size 100 and train the model for 50 epochs. We chose the hyperparameters on the validation set and retrain the model on the union of the training and validation sets. The hyperparameters are \u03b2, the size of the row subset S, the learning rate and its decrease rate. Using a subset S of 30% of all the rows of each of weight matrix for the retraction step worked well in practice."}, {"heading": "5.3. Results", "text": ""}, {"heading": "5.3.1. (QUASI)-ORTHOGONALITY.", "text": "We first validate that Parseval training (Algorithm 1) indeed yields (near)-orthonormal weight matrices. To do so, we analyze the spectrum of the weight matrices of the different models by plotting the histograms of their singular values, and compare these histograms for Parseval networks to networks trained using standard SGD with and without weight decay (SGD-wd and SGD).\nThe histograms representing the distribution of singular values at layers 1 and 4 for the fully connected network (using S = 30%) trained on the dataset CIFAR-10 are shown in Fig. 2 (the figures for convolutional networks are similar). The singular values obtained with our method are tightly concentrated around 1. This experiment confirms that the weight matrices produced by the proposed opti-\nmization procedure are (almost) orthonormal. The distribution of the singular values of the weight matrices obtained with SGD has a lot more variance, with nearly as many small values as large ones. Adding weight decay to standard SGD leads to a sparse spectrum for the weight matrices, especially in the higher layers of the network suggesting a low-rank structure. This observation has motivated recent work on compressing deep neural networks (Denton et al., 2014)."}, {"heading": "5.3.2. ROBUSTNESS TO ADVERSARIAL NOISE.", "text": "We evaluate the robustness of the models to adversarial noise by generating adversarial examples from the test set, for various magnitudes of the noise vector. Following common practice (Kurakin et al., 2016), we use the fast gradient sign method to generate the adversarial examples (using \u2016.\u2016\u221e, see Section 3.1). Since these adversarial examples transfer from one network to the other, the fast gradient sign method allows to benchmark the network for reasonable settings where the opponent does not know the network. We report the accuracy of each model as a function of the magnitude of the noise. To make the results easier to interpret, we compute the corresponding Signal to Noise Ratio (SNR). For an input x and perturbation \u03b4x, the SNR is defined as SNR(x, \u03b4x) = 20 log10 \u2016x\u20162 \u2016\u03b4x\u20162 . We show some adversarial examples in Fig. 1.\nFully Connected Nets. Figure 3 depicts a comparison of Parseval and vanilla networks with and without adversarial training at various noise levels. On both MNIST and CIFAR-10, Parseval networks consistently outperforms weight decay regularization. In addition, it is as robust as\nadversarial training (SGD-wd-da) on CIFAR-10. Combining Parseval Networks and adversarial training results in the most robust method on MNIST.\nResNets. Table 1 summarizes the results of our experiments with wide residual Parseval and vanilla networks on CIFAR-10, CIFAR-100 and SVHN. In the table, we denote Parseval(OC) the Parseval network with orthogonality constraint and without using a convex combination in aggregation layers. Parseval indicates the configuration where both of the orthogonality and convexity constraints are used. We first observe that Parseval networks outperform vanilla ones on all datasets on the clean examples and match the state of the art performances on CIFAR-10 (96.28%) and SVHN (98.44%). On CIFAR-100, when we use Parseval wide Resnet of depth 40 instead of 28, we achieve an accuracy of 81.76%. In comparison, the best performance achieved by a vanilla wide resnet (Zagoruyko & Komodakis, 2016) and a pre-activation resnet (He et al., 2016) are respectively 81.12% and 77.29%. Therefore, our proposal is a useful regularizer for legitimate examples. Also note that in most cases, Parseval networks combining both the orthogonality constraint and the convexity constraint is superior to use the orthogonality constraint solely.\nThe results presented in the table validate our most important claim: Parseval networks significantly improve the robustness of vanilla models to adversarial examples. When no adversarial training is used, the gap in accuracy be-\ntween the two methods is significant (particularly in the high noise scenario). For an SNR value of 40, the best Parseval network achieves 55.41% accuracy while the best vanilla model is at 44.62%. When the models are adversarially trained, Parseval networks remain superior to vanilla models in most cases. Interestingly, adversarial training only slightly improves the robustness of Parseval networks in low noise setting (e.g. SNR values of 45-50) and sometimes even deteriorates it (e.g. on CIFAR-10). In contrast, combining adversarial training and Parseval networks is an effective approach in the high noise setting. This result suggests that thanks to the particular form of regularizer (controlling the Lipschitz constant of the network), Parseval networks achieves robustness to adversarial examples located in the immediate vicinity of each data point. Therefore, adversarial training only helps for adversarial examples found further away from the legitimate patterns. This observation holds consistently across all our datasets.\nBetter use of capacity Given the distribution of singular values observed in Figure 2, we want to analyze the intrinsic dimensionality of the representation learned by the different networks at every layer. To that end, we use the local covariance dimension (Dasgupta & Freund, 2008) which can be measured from the covariance matrix of the data. For each layer k of the fully connected network, we compute the activation\u2019s empirical covariance matrix 1 n \u2211n i=1 \u03c6k(x)\u03c6k(x)\n> and obtain its sorted eigenvalues \u03c31 \u2265 \u00b7 \u00b7 \u00b7 \u2265 \u03c3d. For each method and each layer, we select the smallest integer p such that \u2211p i=1 \u03c3i \u2265 0.99 \u2211d i=1 \u03c3i. This gives us the number of dimensions that we need to explain 99% of the covariance. We can also compute the same quantity for the examples of each class, by only considering in the empirical estimation of the covariance of the examples xi such that yi = c. Table 2 report these numbers for all examples and the per-class average on CIFAR-10.\nTable 2 shows that the local covariance dimension of all the data is consistently higher for Parseval networks than all the other approaches at any layer of the network. SGDwd-da contracts all the data in very low dimensional spaces at the upper levels of the network by using only 0.4% of the total dimension (layer 3 and 4) while Parseval networks use about 81% and 56% at of the whole dimension respectively\nin the same layers. This is intriguing given that SGD-wd-da also increases the robustness of the network, apparently not in the same way as Parseval networks. For the average local covariance dimension of the classes, SGD-wd-da contracts each class into the same dimensionality as it contracts all the data at the upper layers of the network. For Parseval, the data of each class is contracted in about 30% and 19% of the overall dimension. These results suggest that Parseval contracts the data of each class in a lower dimensional manifold (compared to the intrinsic dimensionality of the whole data) hence making classification easier.\nfaster convergence Parseval networks converge significantly faster than vanilla networks trained with batch normalization and dropout as depicted by figure 4. Thanks to the orthogonalization step following each gradient update, the weight matrices are well conditioned at each step during the optimization. We hypothesize this is the main explanation of this phenomenon. For convolutional networks (resnets), the faster convergence is not obtained at the expense of larger wall-time since the cost of the projection step is negligible compared to the total cost of the forward pass on modern GPU architecture thanks to the small size of the filters."}, {"heading": "6. Conclusion", "text": "We introduced Parseval networks, a new approach for learning neural networks that are intrinsically robust to adversarial noise. We proposed an algorithm that allows us to optimize the model efficiently. Empirical results on three classification datasets with fully connected and wide residual networks illustrate the performance of our approach. As a byproduct of the regularization we propose, the model trains faster and makes a better use of its capacity. Further investigation of this phenomenon is left to future work."}, {"heading": "Acknowledgements", "text": "The authors would like to thank M.A. Ranzato, Y. Tian, A. Bordes and F. Perronnin for their valuable feedback on this work."}], "year": 2017, "references": [{"title": "Optimization algorithms on matrix manifolds", "authors": ["Absil", "P-A", "Mahony", "Robert", "Sepulchre", "Rodolphe"], "year": 2009}, {"title": "Deep speech 2: End-to-end speech recognition in english and mandarin", "authors": ["Amodei", "Dario", "Anubhai", "Rishita", "Battenberg", "Eric", "Case", "Carl", "Casper", "Jared", "Catanzaro", "Bryan", "Chen", "Jingdong", "Chrzanowski", "Mike", "Coates", "Adam", "Diamos", "Greg"], "venue": "arXiv preprint arXiv:1512.02595,", "year": 2015}, {"title": "Fast projection onto the simplex and the\\ pmb {l} _\\ mathbf", "authors": ["Condat", "Laurent"], "venue": "ball. Mathematical Programming,", "year": 2016}, {"title": "Random projection trees and low dimensional manifolds", "authors": ["Dasgupta", "Sanjoy", "Freund", "Yoav"], "venue": "In Proceedings of the fortieth annual ACM symposium on Theory of computing,", "year": 2008}, {"title": "Exploiting linear structure within convolutional networks for efficient evaluation", "authors": ["Denton", "Emily L", "Zaremba", "Wojciech", "Bruna", "Joan", "LeCun", "Yann", "Fergus", "Rob"], "venue": "In Adv. NIPS,", "year": 2014}, {"title": "Fast monte carlo algorithms for matrices i: Approximating matrix multiplication", "authors": ["Drineas", "Petros", "Kannan", "Ravi", "Mahoney", "Michael W"], "venue": "SIAM Journal on Computing,", "year": 2006}, {"title": "Improving generalization performance using double backpropagation", "authors": ["Drucker", "Harris", "Le Cun", "Yann"], "venue": "IEEE Transactions on Neural Networks,", "year": 1992}, {"title": "Efficient projections onto the l 1-ball for learning in high dimensions", "authors": ["Duchi", "John", "Shalev-Shwartz", "Shai", "Singer", "Yoram", "Chandra", "Tushar"], "venue": "In Proceedings of the 25th international conference on Machine learning,", "year": 2008}, {"title": "Analysis of classifiers\u2019 robustness to adversarial perturbations", "authors": ["Fawzi", "Alhussein", "Omar", "Frossard", "Pascal"], "venue": "arXiv preprint arXiv:1502.02590,", "year": 2015}, {"title": "Robustness of classifiers: from adversarial to random noise", "authors": ["Fawzi", "Alhussein", "Moosavi-Dezfooli", "Seyed-Mohsen", "Frossard", "Pascal"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2016}, {"title": "Explaining and harnessing adversarial examples", "authors": ["Goodfellow", "Ian J", "Shlens", "Jonathon", "Szegedy", "Christian"], "venue": "In Proc. ICLR,", "year": 2015}, {"title": "Towards deep neural network architectures robust to adversarial examples", "authors": ["Gu", "Shixiang", "Rigazio", "Luca"], "venue": "In ICLR workshop,", "year": 2015}, {"title": "Deep residual learning for image recognition", "authors": ["He", "Kaiming", "Zhang", "Xiangyu", "Ren", "Shaoqing", "Sun", "Jian"], "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,", "year": 2016}, {"title": "Densely connected convolutional networks", "authors": ["Huang", "Gao", "Liu", "Zhuang", "Weinberger", "Kilian Q", "van der Maaten", "Laurens"], "venue": "arXiv preprint arXiv:1608.06993,", "year": 2016}, {"title": "Deep networks with stochastic depth", "authors": ["Huang", "Gao", "Sun", "Yu", "Liu", "Zhuang", "Sedra", "Daniel", "Weinberger", "Kilian Q"], "venue": "In European Conference on Computer Vision,", "year": 2016}, {"title": "Independent component analysis: algorithms and applications", "authors": ["Hyv\u00e4rinen", "Aapo", "Oja", "Erkki"], "venue": "Neural networks,", "year": 2000}, {"title": "An introduction to frames", "authors": ["Kova\u010devi\u0107", "Jelena", "Chebira", "Amina"], "venue": "Foundations and Trends in Signal Processing,", "year": 2008}, {"title": "Learning multiple layers of features from tiny images", "authors": ["Krizhevsky", "Alex"], "year": 2009}, {"title": "Adversarial machine learning at scale", "authors": ["Kurakin", "Alexey", "Goodfellow", "Ian", "Bengio", "Samy"], "venue": "arXiv preprint arXiv:1611.01236,", "year": 2016}, {"title": "Delving into transferable adversarial examples and black-box attacks", "authors": ["Liu", "Yanpei", "Chen", "Xinyun", "Chang", "Song", "Dawn"], "venue": "CoRR, abs/1611.02770,", "year": 2016}, {"title": "A finite algorithm for finding the projection of a point onto the canonical simplex of? n", "authors": ["Michelot", "Christian"], "venue": "Journal of Optimization Theory and Applications,", "year": 1986}, {"title": "Distributional smoothing with virtual adversarial training", "authors": ["Miyato", "Takeru", "Maeda", "Shin-ichi", "Koyama", "Masanori", "Nakae", "Ken", "Ishii", "Shin"], "venue": "In Proc. ICLR,", "year": 2015}, {"title": "Deepfool: a simple and accurate method to fool deep neural networks", "authors": ["Moosavi-Dezfooli", "Seyed-Mohsen", "Fawzi", "Alhussein", "Frossard", "Pascal"], "venue": "arXiv preprint arXiv:1511.04599,", "year": 2015}, {"title": "Deep neural networks are easily fooled: High confidence predictions for unrecognizable images", "authors": ["Nguyen", "Anh", "Yosinski", "Jason", "Clune", "Jeff"], "venue": "In Proc. CVPR,", "year": 2015}, {"title": "Practical black-box attacks against deep learning systems using adversarial examples", "authors": ["Papernot", "Nicolas", "McDaniel", "Patrick", "Goodfellow", "Ian", "Jha", "Somesh", "Z Berkay Celik", "Swami", "Ananthram"], "venue": "arXiv preprint arXiv:1602.02697,", "year": 2016}, {"title": "Distillation as a defense to adversarial perturbations against deep neural networks", "authors": ["Papernot", "Nicolas", "McDaniel", "Patrick", "Wu", "Xi", "Jha", "Somesh", "Swami", "Ananthram"], "venue": "In Security and Privacy (SP),", "year": 2016}, {"title": "An algorithm for a singly constrained class of quadratic programs subject to upper and lower bounds", "authors": ["Pardalos", "Panos M", "Kovoor", "Naina"], "venue": "Mathematical Programming,", "year": 1990}, {"title": "Weight normalization: A simple reparameterization to accelerate training of deep neural networks", "authors": ["Salimans", "Tim", "Kingma", "Diederik P"], "venue": "In Advances in Neural Information Processing Systems,", "year": 2016}, {"title": "Understanding adversarial training: Increasing local stability of neural nets through robust optimization", "authors": ["Shaham", "Uri", "Yamada", "Yutaro", "Negahban", "Sahand"], "venue": "arXiv preprint arXiv:1511.05432,", "year": 2015}, {"title": "Intriguing properties of neural networks", "authors": ["Szegedy", "Christian", "Zaremba", "Wojciech", "Sutskever", "Ilya", "Bruna", "Joan", "Erhan", "Dumitru", "Goodfellow", "Ian", "Fergus", "Rob"], "venue": "In Proc. ICLR,", "year": 2014}, {"title": "Robustness and generalization", "authors": ["Xu", "Huan", "Mannor", "Shie"], "venue": "Machine learning,", "year": 2012}, {"title": "Wide residual networks", "authors": ["Zagoruyko", "Sergey", "Komodakis", "Nikos"], "venue": "arXiv preprint arXiv:1605.07146,", "year": 2016}], "id": "SP:38a9427a7599e9fc97e95f57ebe368b4de92c0cb", "authors": [{"name": "Moustapha Cisse", "affiliations": []}, {"name": "Piotr Bojanowski", "affiliations": []}, {"name": "Edouard Grave", "affiliations": []}, {"name": "Yann Dauphin", "affiliations": []}, {"name": "Nicolas Usunier", "affiliations": []}], "abstractText": "We introduce Parseval networks, a form of deep neural networks in which the Lipschitz constant of linear, convolutional and aggregation layers is constrained to be smaller than 1. Parseval networks are empirically and theoretically motivated by an analysis of the robustness of the predictions made by deep neural networks when their input is subject to an adversarial perturbation. The most important feature of Parseval networks is to maintain weight matrices of linear and convolutional layers to be (approximately) Parseval tight frames, which are extensions of orthogonal matrices to non-square matrices. We describe how these constraints can be maintained efficiently during SGD. We show that Parseval networks match the state-of-the-art in terms of accuracy on CIFAR-10/100 and Street View House Numbers (SVHN), while being more robust than their vanilla counterpart against adversarial examples. Incidentally, Parseval networks also tend to train faster and make a better usage of the full capacity of the networks.", "title": "Parseval Networks: Improving Robustness to Adversarial Examples"}