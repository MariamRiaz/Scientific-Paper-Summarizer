{"sections": [{"heading": "1. Introduction", "text": "Shape constraints like monotonicity and convexity arise naturally in many real-world regression and classification tasks. For example, holding all other variables fixed, a practitioner might assume that the price of a house is a decreasing function of neighborhood crime rate, that an individual\u2019s utility function is concave in income level, or that phenotypes such as height or the likelihood of contracting a disease are monotonic in certain genetic effects.\nParametric models like linear regression implicity impose monotonicity constraints at the cost of strong assumptions on the true underlying function. On the other hand, nonparametric techniques like kernel regression impose weak assumptions, but do not guarantee monotonicity or convexity in their predictions. Shape-constrained nonparametric regression methods attempt to offer the best of both worlds, allowing practitioners to dispense with parametric assumptions while retaining many of their appealing properties.\nHowever, classical approaches to nonparametric regression under shape constraints suffer from the curse of dimensionality (Han & Wellner, 2016; Han et al., 2017). Some methods have been developed to mitigate this issue under assumptions like additivity, where the true function f is assumed to have the form f(x) = \u2211 j fj(xj) + c, where a subset of the component fj\u2019s are shapeconstrained (Chen & Samworth, 2016; Pya & Wood, 2015; Xu et al., 2016). But in many real-world settings, the lack of interaction terms among the predictors can be too restrictive.\nApproaches from the machine learning community like random forests, gradient boosted trees, and deep learning methods have been shown to exhibit outstanding empirical performance on highdimensional tasks. But these methods do not guarantee monotonicity or convexity.\n\u2217Department of Statistics, The University of Chicago \u2020Department of Statistics, University of Illinois at Urbana-Champaign \u2021Department of Statistics and Data Science, Yale University\nar X\niv :1\n80 5.\n06 43\n9v 1\n[ st\nat .M\nL ]\n1 6\nM ay\n2 01\n8\nIn this paper, we propose two methods for high-dimensional shape-constrained regression and classification. These methods blend the performance of machine learning methods with the classical least-squares approach to nonparametric shape-constrained regression.\nIn Section (2.1), we describe black box reshaping, which takes any pre-trained prediction rule and reshapes it on a set of test inputs to enforce shape constraints. In the case of monotonicity constraints, we develop an efficient algorithm to compute the estimator. Section (2.2) presents a second method designed specifically to reshape random forests (Breiman, 2001). This approach reshapes each individual decision tree based on its split rules and estimated leaf values. Again, in the case of monotonicity constraints, we present another efficient reshaping algorithm. We apply our methods to four datasets in Section (3) and show that they enforce the pre-specified shape constraints without sacrificing accuracy."}, {"heading": "1.1. Related Work", "text": "In the context of monotonicity constraints, the black box reshaping method is related to the method of rearrangements (Chernozhukov et al., 2009, 2010). The rearrangement operation takes a pretrained prediction rule and sorts its predictions to enforce monotonicity. In higher dimensions, the rearranged estimator is the average of one-dimensional rearrangements. In contrast, this paper focuses on isotonization of prediction values, jointly reshaping multiple dimensions in tandem. It would be interesting to explore adaptive procedures that average rearranged and isotonized predictions in future work.\nMonotonic decision trees have previously been studied in the context of classification. Several methods require that the training data satisfy monotonicity constraints (Makino et al., 1996; Potharst & Feelders, 2002), a relatively strong assumption in the presence of noise. The methods we propose here do not place any restrictions on the training data.\nAnother class of methods augment the score function for each split to incorporate the degree of non-monotonicity introduced by that split (Ben-David, 1995; Gonz\u00e1lez et al., 2015). However, this approach does not guarantee monotonicity. Feelders & Pardoel (2003) apply pruning algorithms to non-monotonic trees as a post-processing step in order to enforce monotonicity. For a comprehensive survey of estimating monotonic functions, see Gupta et al. (2016) .\nA line of recent work has led to a method for learning deep monotonic models by alternating different types of monotone layers (You et al., 2017). Amos et al. (2017) propose a method for fitting neural networks whose predictions are convex with respect to a subset of predictors.\nOur methods differ from this work in several ways. First, our techniques can be used to enforce both monotonic and convex/concave relationships. Unlike pruning methods, neither approach presented here changes the structure of the original tree. Black box reshaping, described in Section (2.1), can be applied to any pre-trained prediction rule, giving practitioners the flexibility of picking the method of their choice. And both methods guarantee that the intended shape constraints are satisfied on test data."}, {"heading": "2. Prediction Rule Reshaping", "text": "In what follows, we say that a function f : Rd \u2192 R is monotone with respect to variables R \u2286 [d] = {1, . . . , d} if f(x) \u2264 f(y) when xi \u2264 yi for i \u2208 R, and xi = yi otherwise.\nSimilarly, a function f is convex in R if for all x, y \u2208 Rd and \u03b1 \u2208 [0, 1], f(\u03b1x + (1 \u2212 \u03b1)y) \u2264 \u03b1f(x) + (1\u2212 \u03b1)f(y) when xi = yi \u2200i /\u2208 R."}, {"heading": "2.1. Black Box Reshaping", "text": "Let f\u0302 : Rd \u2192 R denote an arbitrary prediction rule fit on a training set and assume we have a candidate set of shape constraints with respect to variablesR \u2286 [d]. For example, we might require that the function be monotone increasing in each variable v \u2208 R.\nLet F denote the class of functions that satisfy the desired shape constraints on each predictor variable v \u2208 R. We aim to find a function f \u2217 \u2208 F that is close to f\u0302 in the L2 norm:\nf \u2217 = arg min f\u2208F \u2016f \u2212 f\u0302\u20162 (2.1)\nwhere the L2 norm is with respect to the uniform measure on a compact set containing the data. We simplify this infinite-dimensional problem by only considering values of f\u0302 on certain fixed test points.\nSuppose we take a sequence t1, t2, . . . , tn of test points, each in Rd, that differ only in their v-th coordinate so that tik = t i\u2032\nk for all k 6= v. These points can be ordered by their v-th coordinate, allowing us to consider shape constraints on the vector (f(t1), f(t2), ..., f(tn)) \u2208 Rn. For instance, under a monotone-increasing constraint with respect to v, if t1v \u2264 t2v \u2264 \u00b7 \u00b7 \u00b7 \u2264 tnv , then we consider functions f such that (f(t1), f(t2), ..., f(tn)) is a monotone sequence.\nThere is now the question of choosing a test point t as well as a sequence of values t1v, ..., t n v to plug into its v-th coordinate. A natural choice is to use the observed data values as both test points and coordinate values.\nDenote Dn = {(x1, y1), . . . , (xn, yn)} as a set of observed values where yi is the response and xi \u2208 Rd are the predictors. From each xi, we construct a sequence of test points that can be ordered according to their v-th coordinate in the following way. Let xi,k,v denote the observed vector xi with its v-th coordinate replaced by the v-th coordinate of xk, so that\nxi,k,v = (xi1, x i 2, . . . , x i v\u22121, x k v , x i v+1, . . . , x i d). (2.2)\nThis process yields n points from xi that can be ordered by their v-th coordinate, xi,1,v, xi,2,v, . . . , xi,n,v. We then require (f(xi,1,v), f(xi,2,v), . . . , f(xi,n,v)) \u2208 Sv where Sv \u2282 Rd is the appropriate convex cone that enforces the shape constraint for variable v \u2208 R, for example the cone of monotone increasing or convex sequences.\nTo summarize, for each coordinate v \u2208 R and for each i \u2208 [n], we:\n1. Take the i-th observed data point xi as a test point. 2. Replace its v-th coordinate with the n observed v-th coordinates x1v, ...x n v to produce\nxi,1,v, xi,2,v, . . . , xi,n,v. 3. Enforce the appropriate shape constraint on the vector of evaluated function values,\n(f(xi,1,v), f(xi,2,v), . . . , f(xi,n,v)) \u2208 Sv.\nSee Figure (1) for an illustration. This leads to the following relaxation of (2.1):\nf \u2217 = arg min f\u2208Fn \u2016f \u2212 f\u0302\u20162 (2.3)\nwhere Fn is the class of functions f such that (f(xi,1,v), f(xi,2,v), . . . , f(xi,n,v)) \u2208 Sv \u2282 Rn for each v \u2208 R and each i \u2208 [n]. In other words, we have relaxed the shape constraints on the function f , requiring the constraints to hold relative to the selected test points. However, this optimization is still infinite dimensional.\nWe make the final transition to finite dimensions by changing the objective function to only consider values of f on the test points. Letting Fi,k,v denote the value of f evaluated on test point xi,k,v, we relax (2.3) to obtain the solution F \u2217 = (F \u2217i,k,v)v\u2208R,i\u2208[n],k\u2208[n] of the optimization:\narg min F\n\u2211 i,k,v (Fi,k,v \u2212 f\u0302(xi,k,v))2\nsubject to (Fi,1,v, ..., Fi,n,v) \u2208 (Sv)v\u2208R, \u2200 i \u2208 [n] (2.4)\nHowever, this leads to ill-defined predictions on the original data points x1, ..., xn, since for each\nv, xi,i,v = xi, but we may obtain different values F \u2217i,i,v for various v \u2208 R.\nWe avoid this issue by adding a consistency constraint (2.7) to obtain our final black box reshaping optimization (BBOPT):\narg min F\n\u2211 i,k,v (Fi,k,v \u2212 f\u0302(xi,k,v))2 (2.5)\nsubject to (Fi,1,v, ..., Fi,n,v) \u2208 (Sv)v\u2208R, \u2200 i \u2208 [n] (2.6) and Fi,i,v = Fi,i,w \u2200 v, w \u2208 R,\u2200 i \u2208 [n] (2.7)\nWe then take the reshaped predictions to be\nf \u2217(xi) = F \u2217i,i,v\nfor any v \u2208 R. Since the constraints depend on each xi independently, BBOPT decomposes into n optimization problems, one for each observed value. Note that the true response values yi are not used when reshaping. We could select optimal shape constraints on a held-out test set."}, {"heading": "2.1.1. Intersecting Isotonic Regression", "text": "In this section, we present an efficient algorithm for solving BBOPT for the case when each Sv imposes monotonicity constraints. Let R = |R| denote the number of monotonicity constraints.\nWhen reshaping with respect to only one predictor (R = 1), the consistency constraints (2.7) vanish, so the optimization decomposes into n isotonic regression problems. Each problem is efficiently solved in \u0398(n) time with the pool adjacent violators algorithm (PAVA) (Ayer et al., 1955).\nFor R > 1 monotonicity constraints, BBOPT gives rise to n independent intersecting isotonic regression problems. The k-th problem corresponds to the k-th observed value xk; the \u201cintersection\" is implied by the consistency constraints (2.7). For each independent problem, our algorithm takes O(m logR) time, where m = n\u00d7R is the number of variables in each problem.\nWe first state the general problem. Assume v1, v2, . . . , vK are each real-valued vectors with dimensions d1, d2, . . . , dK , respectively. Let ij \u2208 {1, . . . , dj} denote an index in the j-th vector vj . The intersecting isotonic regression problem (IISO) is:\nminimize (v\u0302k)Kk=1 K\u2211 k=1 \u2016v\u0302k \u2212 vk\u20162 subject to v\u0302k1 \u2264 v\u0302k2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 v\u0302kdk , \u2200 k \u2208 [K] and v\u03021i1 = v\u0302 2 i2 = \u00b7 \u00b7 \u00b7 = v\u0302KiK\n(2.8)\nFirst consider the simpler constrained isotonic regression problem with a single sequence v \u2208 Rd,\nAlgorithm 1 IISO Algorithm 1. Apply PAVA to each of the 2K tails. 2. Combine and sort the left and right tails separately. 3. Find segment s\u2217 in between tail values where the derivative g\u2032(\u03b7) changes sign. 4. Compute c\u2217, the minimizer of g(c) in segment s\u2217.\nindex i \u2208 [d], and fixed value c \u2208 R\nminimize v\u0302 \u2016v\u0302 \u2212 v\u20162 subject to v\u03021 \u2264 v\u03022 \u2264 \u00b7 \u00b7 \u00b7 \u2264 v\u0302d and v\u0302i = c\n(2.9)\nLemma 2.1. The solution v\u2217 to (2.9) can be computed by using index i as a pivot and splitting v into its left and right tails, so that ` = (v1, v2, . . . , vi\u22121) and r = (vi+1, . . . , vd), then applying PAVA to obtain monotone tails \u0302\u0300and r\u0302. v\u2217 is obtained by setting elements of \u0302\u0300and r\u0302 to\n`\u2217k = min(\u0302\u0300k, c) r\u2217k = max(r\u0302k, c)\n(2.10)\nand concatenating the resulting tails so that v\u2217 = (`\u2217, c, r\u2217) \u2208 Rd.\nWe now explain the IISO Algorithm presented in Algorithm (1). First divide each vector vj into two tails, the left tail `j and the right tail rj , using the intersection index ij as a pivot,\nvj = (vj1, v j 2, . . . , v j (ij\u22121)\ufe38 \ufe37\ufe37 \ufe38\n`j\n, vjij , v j (ij+1) , vj(ij+2), . . . , v j dj\ufe38 \ufe37\ufe37 \ufe38\nrj\n).\nresulting in 2K tails {`1, . . . , `K , r1, . . . , rK}.\nStep 1 of Algorithm (1) performs an unconstrained isotonic regression on each tail using PAVA to obtain 2K monotone tails {\u0302\u03001, . . . , \u0302\u0300K , r\u03021, . . . , r\u0302K}. This can be done in \u0398(n) time, where n is the total number of elements across all vectors so that n = \u2211K i=1 di.\nGiven the monotone tails, we can write a closed-form expression for the IISO objective function in terms of the value at the point of intersection.\nLet c be the value of the vectors at the point of intersection so that c = v\u03021i1 = v\u0302 2 i2 = \u00b7 \u00b7 \u00b7 = v\u0302KiK . For a fixed c, we can solve IISO by applying Lemma (2.1) to each sequence separately. This yields the following expression for the squared error as a function of c:\ng(c) = K\u2211 k=1 (c\u2212 vkik) 2 + K\u2211 k=1 ik\u22121\u2211 i=1 (`ki \u2212min(\u0302\u0300ki , c))2 + K\u2211 l=1 dl\u2211 j=il+1 (rlj \u2212max(r\u0302lj, c))2 (2.11)\nwhich is piecewise quadratic with knots at each \u0302\u0300ki and r\u0302lj . Our goal is to find c? = minc g(c). Note that g(c) is convex and differentiable.\nWe proceed by computing the derivative of g at each knot, from smallest to largest, and finding the segment in which the sign of the derivative changes from negative to positive. The minimizer c\u2217 will live in this segment.\nStep 2 of Algorithm (1) merges the left and right sorted tails into two sorted lists. This can be done in O(n logK) time with a heap data structure. Step 3 computes the derivative of the objective function g at each knot, from smallest to largest, searching for the segment in which the derivative changes sign. Step 4 computes the minimizer of g in the corresponding segment. By updating the derivative incrementally and storing relevant side information, Steps 3 and 4 can be done in linear time.\nThe total time complexity is therefore O(n log(K))."}, {"heading": "2.2. Reshaping Random Forests", "text": "In this section, we describe a framework for reshaping a random forest to ensure monotonicity of its predictions in a subset of its predictor variables. A similar method can be applied to ensure convexity. For both regression and probability trees (Malley et al., 2012), the prediction of the forest is an average of the prediction of each tree; it is therefore sufficient to ensure monotonicity or convexity of the trees. For the rest of this section, we focus on reshaping individual trees to enforce monotonicity.\nOur method is a two-step procedure. The first step is to grow a tree in the usual way. The second step is to reshape the leaf values to enforce monotonicity. We hope to explore the implications of combining these steps in future work.\nLet T (x) be a regression tree and R \u2286 [d] a set of predictor variables to be reshaped. Let x \u2208 Rd be an input point and denote the k-th coordinate of x as xk. Assume v \u2208 R is a predictor variable to be reshaped. The following thought experiment, illustrated in Figure (2), will motivate\nour approach.\nImagine dropping x down T until it falls in its corresponding leaf, `1. Let p1 be the closest ancestor node to `1 that splits on v and assume it has split rule {xv \u2264 t1}. Holding all other coordinates constant, increasing xv until it is greater than t1 would create a new point that drops down to a different leaf `2 in the right subtree of p1.\nIf `1 and `2 both share another ancestor p2 farther up the tree with split rule {xv \u2264 t2}, increasing xv beyond t2 would yield another leaf `3. Assume these leaves have no other shared ancestors that split on v. Denoting the value of leaf ` as \u00b5`, in order to ensure monotonicity in v for this point x, we require \u00b5`1 \u2264 \u00b5`2 \u2264 \u00b5`3 .\nWe use this line of thinking to propose a framework for estimating monotonic random forests and describe two estimators that fall under this framework."}, {"heading": "2.2.1. Exact Estimator", "text": "Each leaf ` in a decision tree is a cell (or hyperrectangle) C` which is an intersection of intervals\nC` = d\u22c2 j=1 {x : xj \u2208 I`j}\nWhen we split on a shape-constrained variable v with split-value t, each cell in the left subtree\nis of the form Cl = C\u0304l \u2229 {x : xv \u2264 t} and each cell in the right subtree is of the form Cr = C\u0304r \u2229 {x : xv > t}.\nFor cells l in the left subtree and r in the right subtree, our goal is to constrain the corresponding leaf values \u00b5l \u2264 \u00b5r only when C\u0304l \u2229 C\u0304r 6= \u2205. See Figure (3) for an illustration. We must devise an algorithm to find the intersecting cells (l, r), and add each to a constraint set E. This can be done efficiently with an interval tree data structure.\nAssume there are n unique leaves appearing in E. The exact estimator is obtained by solving the following optimization:\nmin (\u00b5\u0302`) n `=1\nn\u2211 `=1 (\u00b5` \u2212 \u00b5\u0302`)2\nsubject to \u00b5\u0302i \u2264 \u00b5\u0302j \u2200 (i, j) \u2208 E (2.12)\nwhere \u00b5` is the original value of leaf `.\nThis is an instance of L2 isotonic regression on a directed acyclic graph where each leaf value \u00b5` is a node, and each constraint in E is an edge. With n vertices and m edges, the fastest known exact algorithm for this problem has time complexity \u0398(n4) (Spouge et al., 2003), and the fastest known \u03b4-approximate algorithm has complexity O(m1.5 log2 n log n\n\u03b4 ) (Kyng et al., 2015).\nWith a corresponding change to the constraints in Equation (2.12), this approach extends naturally to convex regression trees. It can also be applied directly to probability trees for binary classification by reshaping the estimated probabilities in each leaf."}, {"heading": "2.2.2. Over-constrained Estimator", "text": "In this section, we propose an alternative estimator that can be more efficient to compute, depending on the tree structure. In our experiments below, we find that computing this estimator is always faster.\nLet Ep denote the set of constraints that arise between leaf values under a shape-constrained split node p. By adding additional constraints to Ep, we can solve (2.12) exactly for each shapeconstrained split node in O(np log np) time, where np is the number of leaves under p.\nIn this setting, each shape-constrained split node gives rise to an independent optimization involving its leaves. Due to transitivity, we can solve these optimizations sequentially in reverse (bottom-up) level-order on the tree.\nLet np denote the number of leaves under node p. For each node p that is split on a shapeconstrained variable, the over-constrained estimator solves the following max-min problem:\nmin (\u00b5\u0302`) np `=1\nnp\u2211 `=1 (\u00b5` \u2212 \u00b5\u0302`)2\nsubject to max `\u2208left(p) \u00b5\u0302` \u2264 min r\u2208right(p) \u00b5\u0302r\n(2.13)\nwhere left(p) denotes all leaves in the left subtree of p and right(p) denotes all leaves in the right subtree.\nThis is equivalent to adding an edge (`, r) toE for every pair of leaves such that ` is in left(p) and r is in right(p). All such pairs do not necessarily exist in E for the exact estimator; see Figure (3). For each shape-constrained split, (2.13) is an instance of L2 isotonic regression on a complete directed bipartite graph.\nFor a given shape-constrained split node p, let ` = (`1, `2, . . . , `n1) be the values of the leaves in its left subtree, and r = (r1, r2, . . . , rn2) be the values of the leaves in its right subtree, indexed so that `1 \u2264 \u00b7 \u00b7 \u00b7 \u2264 `n1 and r1 \u2264 \u00b7 \u00b7 \u00b7 \u2264 rn2 . Then the max-min problem (2.13) is equivalent to:\nmin\u02dc\u0300,r\u0303 n1\u2211 i=1 (`i \u2212 \u02dc\u0300i)2 + n2\u2211 i=1 (ri \u2212 r\u0303i)2\nsubject to \u02dc\u03001 \u2264 \u02dc\u03002 \u2264 ... \u2264 \u02dc\u0300n1 \u2264 r\u03031 \u2264 \u00b7 \u00b7 \u00b7 \u2264 r\u0303n2 (2.14)\nThe solution to this optimization is of the form \u02dc\u0300i = min(c, `i) and r\u0303i = max(c, ri), for some constant c. Given the two sorted vectors ` and r, the optimization becomes:\nmin c n1\u2211 i=1 (`i \u2212min(c, `i))2 + n2\u2211 i=1 (ri \u2212max(c, ri))2\nThis objective is convex and differentiable in c. Similar to the black box reshaping method, we can compute the derivatives at the values of the data and find where it flips sign, then compute the minimizer in the corresponding segment. This takes O(n) time where n = n1 + n2, the number of leaves under the shape-constrained split. With sorting, the over-constrained estimator can be computed in O(n log n) time for each shape-constrained split node.\nWe apply this procedure sequentially on the leaves of every shape-constrained node in reverse level-order on the tree.\n3. Experiments\nWe apply the reshaping methods described above to two regression tasks and two binary classification tasks. We show that reshaping allows us to enforce shape constraints without compromising predictive accuracy. For convenience, we use the acronyms in Table (1) to refer to each method.\nThe BB method was implemented in R, and the OC and EX methods were implemented in R and C++, extending the R package ranger (Wright & Ziegler, 2017). The exact estimator from Section (2.2.1) is computed using the MOSEK C++ package (ApS, 2017).\nFor binary classification, we use the probability tree implementation found in ranger, enforcing monotonicity of the probability of a positive classification with respect to the chosen predictors. For the purposes of these experiments, black box reshaping is applied to a traditional random forest. The random forest was fit with the default settings found in ranger.\nWe apply 5-fold cross validation on all four tasks and present the results under the relevant performance metrics in Table (2)."}, {"heading": "3.1. Diabetes Dataset", "text": "The diabetes dataset (Efron et al., 2004) consists of ten physiological baseline variables, age, sex, body mass index, average blood pressure, and six blood serum measurements, for each of 442 patients. The response is a quantitative measure of disease progression measured one year after baseline.\nHolding all other variables constant, we might expect disease progression to be monotonically increasing in body mass index (Ganz et al., 2014). We estimate a random forest and apply our reshaping techniques, then make predictions for a random test subject as we vary the body mass index predictor variable. The results shown in Figure (4a) illustrate the effect of reshaping on the predictions.\nWe use mean squared error to measure accuracy. The results in Table (2) indicate that the prediction accuracy of all four estimators is approximately the same."}, {"heading": "3.2. Zillow Dataset", "text": "In this section, the regression task is to predict real estate sales prices using property information. The data were obtained from Zillow, an online real estate database company. For each of 206,820 properties, we are given the list price, number of bedrooms and bathrooms, square footage, build decade, sale year, major renovation year (if any), city, and metropolitan area. The response is the actual sale price of the home.\nWe reshape to enforce monotonicity of the sale price with respect to the list price. Due to the size of the constraint set, this problem becomes intractable for MOSEK; the results for the EX method are omitted. An interesting direction for future work is to investigate more efficient algorithms for this method.\nFollowing reported results from Zillow, we use mean absolute percent error (MAPE) as our measure of accuracy. For an estimate y\u0302 of the true value y, the APE is |y\u0302 \u2212 y|/y.\nThe results in Table (2) show that the performance across all estimators is indistinguishable."}, {"heading": "3.3. Adult Dataset", "text": "We apply the reshaping techniques to the binary classification task found in the Adult dataset Lichman (2013). The task is to predict whether an individual\u2019s income is less than or greater than $50,000. Following the experiments performed in Milani Fard et al. (2016) and You et al. (2017), we apply monotonic reshaping to four variables: capital gain, weekly hours of work, education\nlevel, and the gender wage gap.\nWe illustrate the effect of reshaping on the predictions in Figure (4b). The results in Table (2) show that we achieve similar test set accuracy before and after reshaping the random forest."}, {"heading": "3.4. Spambase Dataset", "text": "Finally, we apply reshaping to classify whether an email is spam or not. The Spambase dataset (Lichman, 2013) contains 4,601 emails each with 57 predictors. There are 48 word frequency predictors, 6 character frequency predictors, and 3 predictors related to the number of capital letters appearing in the email.\nThat data were collected by Hewlett-Packard labs and donated by George Forman. One of the predictors is the frequency of the word \u201cgeorge\", typically assumed to be an indicator of non-spam for this dataset. We reshape the predictions to enforce the probability of being classified as spam to be monotonically decreasing in the frequency of words \u201cgeorge\" and \u201chp\".\nThe results in Table (2) again show similar performance across all methods."}, {"heading": "4. Discussion", "text": "We presented two strategies for prediction rule reshaping. We developed efficient algorithms to compute the reshaped estimators, and illustrated their properties on four datasets. Both approaches can be viewed as frameworks for developing more sophisticated reshaping techniques.\nThere are several ways that this work can be extended. Extensions to the black box method include adaptively combining rearrangements and isotonization (Chernozhukov et al., 2009), and considering a weighted objective function to account for the distance between test points.\nIn general, the random forest reshaping method can be viewed as operating on pre-trained parameters of a specific model. Applying this line of thinking to gradient boosted trees, deep learning methods, and other machine learning techniques could yield useful variants of this approach.\nAnd finally, while practitioners might require certain shape-constraints on their predictions, many scientific applications also require inferential quantities, such as confidence intervals and confidence bands. Developing inferential procedures for reshaped predictions, similar to Chernozhukov et al. (2010) for rearrangements and Athey et al. (2018) for random forests, would yield interpretable predictions along with useful measures of uncertainty."}, {"heading": "5. Acknowledgments", "text": "Research supported in part by ONR grant N00014-12-1-0762, NSF grants DMS-1513594 and DMS-1654076, and an Alfred P. Sloan fellowship."}], "year": 2018, "references": [{"title": "Input convex neural networks", "authors": ["Amos", "Brandon", "Xu", "Lei", "Kolter", "J. Zico"], "venue": "In Proceedings of the 34th International Conference on Machine Learning,", "year": 2017}, {"title": "Generalized Random Forests", "authors": ["S. Athey", "J. Tibshirani", "S. Wager"], "venue": "Forthcoming in Annals of Statistics,", "year": 2018}, {"title": "An empirical distribution function for sampling with incomplete information", "authors": ["Ayer", "Miriam", "H.D. Brunk", "G.M. Ewing", "W.T. Reid", "Silverman", "Edward"], "venue": "Annals of Mathematical Statistics,", "year": 1955}, {"title": "Monotonicity maintenance in information-theoretic machine learning algorithms", "authors": ["Ben-David", "Arie"], "venue": "Mach. Learn.,", "year": 1995}, {"title": "Generalized additive and index models with shape constraints", "authors": ["Chen", "Yining", "Samworth", "Richard J"], "venue": "Journal of the Royal Statistical Society: Series B (Statistical Methodology),", "year": 2016}, {"title": "Improving point and interval estimators of monotone functions by rearrangement", "authors": ["V. Chernozhukov", "I. Fern\u00e1ndez-Val", "A. Galichon"], "year": 2009}, {"title": "Quantile and probability curves without", "authors": ["V. Chernozhukov", "I. Fern\u00e1ndez-Val", "A. Galichon"], "venue": "crossing. Econometrica,", "year": 2010}, {"title": "Least angle regression", "authors": ["Efron", "Bradley", "Hastie", "Trevor", "Johnstone", "Iain", "Tibshirani", "Robert"], "venue": "Annals of Statistics,", "year": 2004}, {"title": "Pruning for monotone classification trees", "authors": ["Feelders", "Ad", "Pardoel", "Martijn"], "venue": "Advances in Intelligent Data Analysis V,", "year": 2003}, {"title": "The association of body mass index with the risk of type 2 diabetes: a case\u2013control study nested in an electronic health records system in the united states", "authors": ["Ganz", "Michael L", "Wintfeld", "Neil", "Li", "Qian", "Alas", "Veronica", "Langer", "Jakob", "Hammer", "Mette"], "venue": "Diabetology & Metabolic Syndrome,", "year": 2014}, {"title": "Monotonic random forest with an ensemble pruning mechanism based on the degree of monotonicity", "authors": ["Gonz\u00e1lez", "Sergio", "Herrera", "Francisco", "Garc\u00eda", "Salvador"], "year": 2015}, {"title": "Monotonic calibrated interpolated look-up tables", "authors": ["Gupta", "Maya", "Cotter", "Andrew", "Pfeifer", "Jan", "Voevodski", "Konstantin", "Canini", "Kevin", "Mangylov", "Alexander", "Moczydlowski", "Wojciech", "van Esbroeck"], "venue": "Journal of Machine Learning Research,", "year": 2016}, {"title": "Multivariate convex regression: global risk bounds and adaptation", "authors": ["Han", "Qiyang", "Wellner", "Jon A"], "venue": "arXiv preprint arXiv:1601.06844,", "year": 2016}, {"title": "Isotonic regression in general dimensions", "authors": ["Han", "Qiyang", "Wang", "Tengyao", "Chatterjee", "Sabyasachi", "Samworth", "Richard J"], "venue": "arXiv preprint arXiv:1708.09468,", "year": 2017}, {"title": "Fast, provable algorithms for isotonic regression in all l_p-norms", "authors": ["Kyng", "Rasmus", "Rao", "Anup", "Sachdeva", "Sushant"], "venue": "Advances in Neural Information Processing Systems", "year": 2015}, {"title": "Data analysis by positive decision trees", "authors": ["Makino", "Kazuhisa", "Suda", "Takashi", "Yano", "Kojin", "Ibaraki", "Toshihide"], "venue": "In CODAS, pp", "year": 1996}, {"title": "Probability machines: consistent probability estimation using nonparametric learning machines", "authors": ["Malley", "James D", "Kruppa", "Jochen", "Dasgupta", "Abhijit", "Karen G", "Ziegler", "Andreas"], "venue": "Methods of Information in Medicine,", "year": 2012}, {"title": "Fast and flexible monotonic functions with ensembles of lattices", "authors": ["Milani Fard", "Mahdi", "Canini", "Kevin", "Cotter", "Andrew", "Pfeifer", "Jan", "Gupta", "Maya"], "venue": "Advances in Neural Information Processing Systems", "year": 2016}, {"title": "Classification trees for problems with monotonicity constraints", "authors": ["R. Potharst", "A.J. Feelders"], "venue": "SIGKDD Explor. Newsl.,", "year": 2002}, {"title": "Shape constrained additive models", "authors": ["Pya", "Natalya", "Wood", "Simon N"], "venue": "Statistics and Computing,", "year": 2015}, {"title": "Least squares isotonic regression in two dimensions", "authors": ["J. Spouge", "H. Wan", "W.J. Wilbur"], "venue": "Journal of Optimization Theory and Applications,", "year": 2003}, {"title": "ranger: A fast implementation of random forests for high dimensional data in C++ and R", "authors": ["Wright", "Marvin N", "Ziegler", "Andreas"], "venue": "Journal of Statistical Software,", "year": 2017}, {"title": "Faithful variable screening for high-dimensional convex regression", "authors": ["Xu", "Min", "Chen", "Minhua", "Lafferty", "John"], "venue": "Ann. Statist., 44(6):2624\u20132660,", "year": 2016}, {"title": "Deep lattice networks and partial monotonic functions", "authors": ["You", "Seungil", "Ding", "David", "Canini", "Kevin", "Pfeifer", "Jan", "Gupta", "Maya"], "venue": "In NIPS,", "year": 2017}], "id": "SP:a4fc921550a9a3a3d110b7ab4f82e56415a5d747", "authors": [{"name": "Matt Bonakdarpour", "affiliations": []}, {"name": "Sabyasachi Chatterjee", "affiliations": []}, {"name": "Rina Foygel Barber", "affiliations": []}, {"name": "John Lafferty", "affiliations": []}], "abstractText": "Two methods are proposed for high-dimensional shape-constrained regression and classification. These methods reshape pre-trained prediction rules to satisfy shape constraints like monotonicity and convexity. The first method can be applied to any pre-trained prediction rule, while the second method deals specifically with random forests. In both cases, efficient algorithms are developed for computing the estimators, and experiments are performed to demonstrate their performance on four datasets. We find that reshaping methods enforce shape constraints without compromising predictive accuracy.", "title": "Prediction Rule Reshaping"}