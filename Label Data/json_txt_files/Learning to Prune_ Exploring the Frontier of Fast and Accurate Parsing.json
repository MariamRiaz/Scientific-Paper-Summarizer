{"sections": [{"heading": "1 Introduction", "text": "Decades of research have been dedicated to heuristics for speeding up inference in natural language processing tasks, such as constituency parsing (Pauls and Klein, 2009; Caraballo and Charniak, 1998) and machine translation (Petrov et al., 2008; Xu et al., 2013). Such research is necessary because of a trend toward richer models, which improve accuracy at the cost of slower inference. For example, state-of-theart constituency parsers use grammars with millions of rules, while dependency parsers routinely use millions of features. Without heuristics, these parsers take minutes to process a single sentence.\nTo speed up inference, we will learn a pruning policy. During inference, the pruning policy is invoked to decide whether to keep or prune various parts of the search space, based on features of the input and (potentially) the state of the inference process.\nOur approach searches for a policy with maximum end-to-end performance (reward) on training data, where the reward is a linear combination of problemspecific measures of accuracy and runtime, namely reward = accuracy\u2212\u03bb \u00b7 runtime. The parameter \u03bb \u2265 0\nspecifies the relative importance of runtime and accuracy. By adjusting \u03bb, we obtain policies with different speed-accuracy tradeoffs.\nFor learning, we use Locally Optimal Learning to Search (LOLS) (Chang et al., 2015b), an algorithm for learning sequential decision-making policies, which accounts for the end-to-end performance of the entire decision sequence jointly. Unfortunately, executing LOLS naively in our setting is prohibitive because it would run inference from scratch millions of times under different policies, training examples, and variations of the decision sequence. Thus, this paper presents efficient algorithms for repeated inference, which are applicable to a wide variety of NLP tasks, including parsing, machine translation and sequence tagging. These algorithms, based on change propagation and dynamic programming, dramatically reduce time spent evaluating similar decision sequences by leveraging problem structure and sharing work among evaluations.\nWe evaluate our approach by learning pruning heuristics for constituency parsing. In this setting, our approach is the first to account for end-to-end performance of the pruning policy, without making independence assumptions about the reward function, as in prior work (Bodenstab et al., 2011). In the larger context of learning-to-search for structured prediction, our work is unusual in that it learns to control a dynamic programming algorithm (i.e., graphbased parsing) rather than a greedy algorithm (e.g., transition-based parsing). Our experiments show that accounting for end-to-end performance in training leads to better policies along the entire Pareto frontier of accuracy and runtime."}, {"heading": "2 Weighted CKY with pruning", "text": "A simple yet effective approach to speeding up parsing was proposed by Bodenstab et al. (2011), who trained a pruning policy \u03c0 to classify whether or not spans of the input sentence w1 \u00b7 \u00b7 \u00b7wn form plausible\n263\nTransactions of the Association for Computational Linguistics, vol. 5, pp. 263\u2013278, 2017. Action Editor: Marco Kuhlmann. Submission batch: 5/2016; Revision batch: 9/2016; Published 8/2017.\nc\u00a92017 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license.\nconstituents based on features of the input sentence. These predictions enable a parsing algorithm, such as CKY, to skip expensive steps during its execution: unlikely constituents are pruned. Only plausible constituents are kept, and the parser assembles the highest-scoring parse from the available constituents.\nAlg. 1 provides pseudocode for weighted CKY with pruning. Weighted CKY aims to find the highestscoring derivation (parse tree) of a given sentence, where a given grammar specifies a non-negative score for each derivation rule and a derivation\u2019s score is the product of the scores of the rules it uses.1 CKY uses a dynamic programming strategy to fill in a three-dimensional array \u03b2, known as the chart. The score \u03b2ikx is the score of the highest-scoring subderivation with fringe wi+1 . . . wk and root x. This value is computed by looping over the possible ways to assemble such a subderivation from smaller subderivations with scores \u03b2ijy and \u03b2jkz (lines 17\u201322). Additionally, we track a witness (backpointer) for each \u03b2ikx, so that we can easily reconstruct the corresponding subderivation at line 23. The chart is initialized with lexical grammar rules (lines 3\u20139), which derive words from grammar symbols.\nThe key difference between pruned and unpruned CKY is an additional \u201cif\u201d statement (line 14), which queries the pruning policy \u03c0 to decide whether to compute the several values \u03b2ikx associated with a span (i, k). Note that width-1 and width-n spans are always kept because all valid parses require them."}, {"heading": "3 End-to-end training", "text": "Bodenstab et al. (2011) train their pruning policy as a supervised classifier of spans. They derive direct supervision as follows: try to keep a span if it appears in the gold-standard parse, and prune it otherwise. They found that using an asymmetric weighting scheme helped find the right balance between false positives and false negatives. Intuitively, failing to prune is only a slight slowdown, whereas pruning a good item can ruin the accuracy of the parse.\n1As is common practice, we assume the grammar has been binarized. We focus on pre-trained grammars, leaving coadaptation of the grammar and pruning policy to future work. As indicated at lines 6 and 19, a rule\u2019s score may be made to depend on the context in which that rule is applied (Finkel et al., 2008), although the pre-trained grammars in our present experiments are ordinary PCFGs for which this is not the case.\nAlgorithm 1 PARSE: Weighted CKY with pruning 1: Input: grammar G, sentence w, policy \u03c0\nOutput: completed chart \u03b2, derivation d 2: . Initialize chart 3: \u03b2 := 0 4: for k := 1 to n : 5: for x such that (x\u2192 wk) \u2208 rules(G) : 6: s := G(x\u2192 wk | w, k) 7: if s > \u03b2k\u22121,k,x : 8: \u03b2k\u22121,k,x := s 9: witness(k\u22121, k, x) := (k\u22121, k, wk)\n10: for width := 2 to n : 11: for i := 0 to n\u2212 width : 12: k := i+ width . Current span is (i, k) 13: . Policy determines whether to fill in this span 14: if \u03c0(w, i, k) = prune : 15: continue 16: . Fill in span by considering each split point j 17: for j := i+ 1 to k \u2212 1 : 18: for (x\u2192 y z) \u2208 rules(G) : 19: s := \u03b2ijy \u00b7\u03b2jkz \u00b7G(x\u2192 y z | w, i, j, k) 20: if s > \u03b2ikx : 21: \u03b2ikx := s 22: witness(i, k, x) := (j, y, z) 23: d\u0302 := follow backpointers from (0, n,ROOT) 24: return (\u03b2, d\u0302)\nOur end-to-end training approach improves upon asymmetric weighting by jointly evaluating the sequence of pruning decisions, measuring its effect on the test-time evaluation metric by actually running pruned CKY (Alg. 1). To estimate the value of a pruning policy \u03c0, we call PARSE(G,w(i), \u03c0) on each training sentence w(i), and apply the reward function, r = accuracy\u2212\u03bb \u00b7 runtime. The empirical value of a policy is its average reward on the training set:\nR(\u03c0) = 1 m\nm\u2211\ni=1\nE [ r(PARSE(G,w(i), \u03c0)) ] (1)\nThe expectation in the definition may be dropped if PARSE, \u03c0, and r are all deterministic, as in our setting.2 Our definition of r depends on the user parameter \u03bb \u2265 0, which specifies the amount of accuracy the user would sacrifice to save one unit of\n2Parsers may break ties randomly or use Monte Carlo methods. The reward function r can be nondeterministic when it involves wallclock time or human judgments.\nruntime. Training under a range of values for \u03bb gives rise to policies covering a number of operating points along the Pareto frontier of accuracy and runtime.\nEnd-to-end training gives us a principled way to decide what to prune. Rather than artificially labeling each pruning decision as inherently good or bad, we evaluate its effect in the context of the particular sentence and the other pruning decisions. Actions that prune a gold constituent are not equally bad\u2014some cause cascading errors, while others are \u201cworked around\u201d in the sense that the grammar still selects a mostly-gold parse. Similarly, actions that prune a non-gold constituent are not equally good\u2014some provide more overall speedup (e.g., pruning narrow constituents prevents wider ones from being built), and some even improve accuracy by suppressing an incorrect but high-scoring parse.\nMore generally, the gold vs. non-gold distinction is not even available in NLP tasks where one is pruning potential elements of a latent structure, such as an alignment (Xu et al., 2013) or a finer-grained parse (Matsuzaki et al., 2005). Yet our approach can still be used in such settings, by evaluating the reward on the downstream task that the latent structure serves.\nPast work on optimizing end-to-end performance is discussed in \u00a78. One might try to scale these techniques to learning to prune, but in this work we take a different approach. Given a policy, we can easily find small ways to improve it on specific sentences by varying individual pruning actions (e.g., if \u03c0 currently prunes a span then try keeping it instead). Given a batch of improved action sequences (trajectories), the remaining step is to search for a policy which produces the improved trajectories. Conveniently, this can be reduced to a classification problem, much like the asymmetric weighting approach, except that the supervised labels and misclassification costs are not fixed across iterations, but rather are derived from interaction with the environment (i.e., PARSE and the reward function). This idea is formalized as a learning algorithm called Locally Optimal Learning to Search (Chang et al., 2015b), described in \u00a74.\nThe counterfactual interventions we require\u2014 evaluating how reward would change if we changed one action\u2014can be computed more efficiently using our novel algorithms (\u00a75) than by the default strategy of running the parser repeatedly from scratch. The key is to reuse work among evaluations, which is\npossible because LOLS only makes tiny changes."}, {"heading": "4 Learning algorithm", "text": "Pruned inference is a sequential decision process. The process begins in an initial state s0. In pruned CKY, s0 specifies the state of Alg. 1 at line 10, after the chart has been initialized from some selected sentence. Next, the policy is invoked to choose action a0 = \u03c0(s0)\u2014in our case at line 14\u2014which affects what the parser does next. Eventually the parser reaches some state s1 from which it calls the policy to choose action a1 = \u03c0(s1), and so on. When the policy is invoked at state st, it selects action at based on features extracted from the current state st\u2014a snapshot of the input sentence, grammar and parse chart at time t.3 We call the state-action sequence s0 a0 s1 a1 \u00b7 \u00b7 \u00b7 sT a trajectory, where T is the trajectory length. At the final state, the reward function is evaluated, r(sT ).\nThe LOLS algorithm for learning a policy is given in Alg. 2,4 with a graphical illustration in Fig. 1. At a high level, LOLS alternates between evaluating and improving the current policy \u03c0i.\nThe evaluation phase first samples a trajectory from \u03c0i, called a roll-in: s0 a0 s1 a1 \u00b7 \u00b7 \u00b7 sT \u223c ROLL-IN(\u03c0i). In our setting, s0 is derived from a randomly sampled training sentence, but the rest of the trajectory is then deterministically computed by \u03c0i given s0. Then we revisit each state s in the roll-in (line 7), and try each available action a\u0304\u2208A(s) (line 9), executing \u03c0i thereafter\u2014a rollout\u2014to measure the resulting reward r\u0302[a\u0304] (line 10). Our parser is deterministic, so a single rollout is an unbiased, 0-variance estimate of the expected reward. This process is repeated many times, yielding a large list Q\u0302i of pairs \u3008s, r\u0302\u3009, where s is a state that was encountered in some roll-in and r\u0302 maps the possible actions A(s) in that state to their measured rewards.\nThe improvement phase now trains a new policy \u03c0i+1 to try to choose high-reward actions, seeking a policy that will \u201con average\u201d get high rewards r[\u03c0i+1(s)]. Good generalization is important: the policy must select high-reward actions even in states s that are not represented in Q\u0302i, in case they are\n3Our experiments do not make use of the current state of the chart. We discuss this decision in \u00a78.\n4Alg. 2 is simpler than in Chang et al. (2015b) because it omits oracle rollouts, which we do not use in our experiments.\nAlgorithm 2 LOLS algorithm for learning to prune. 1: \u03c01 := INITIALIZEPOLICY(. . . ) 2: for i := 1 to number of iterations : 3: . Evaluate: Collect dataset for \u03c0i 4: Q\u0302i := \u2205 5: for j := 1 to minibatch size : 6: s0 a0 s1 a1 \u00b7 \u00b7 \u00b7 sT \u223c ROLL-IN(\u03c0i) . Sample 7: for t := 0 to T\u22121 : 8: . Intervene: Evaluate each action at st 9: for a\u0304t \u2208 A(st) : . Possible actions\n10: r\u0302t[a\u0304t] \u223c ROLLOUT(\u03c0i, st, a\u0304t) 11: Q\u0302i.append(\u3008st, r\u0302t \u3009) 12: . Improve: Train with dataset aggregation\n13: \u03c0i+1 \u2190 TRAIN (\u22c3i k=1 Q\u0302k )\n14: . Finalize: Pick the best policy over all iterations 15: return argmaxi\u2032 R(\u03c0i\u2032) encountered when running the new policy \u03c0i+1 (or when parsing test sentences). Thus, beyond just regularizing the training objective, we apply dataset aggregation (Ross et al., 2011): we take the training set to include not just Q\u0302i but also the examples from previous iterations (line 13). This also ensures that the sequence of policies \u03c01, \u03c02, . . .will be \u201cstable\u201d (Ross and Bagnell, 2011) and will eventually converge.\nSo line 13 seeks to find a good classifier \u03c0i+1 using a training set: a possible classifier \u03c0 would receive from each training example \u3008s, r\u0302\u3009 a reward of r\u0302[\u03c0(s)]. In our case, where A(s) = {keep, prune}, this cost-sensitive classification problem is equivalent to training an ordinary binary classifier, after converting each training example \u3008s, r\u0302\u3009 to \u3008s, argmaxa r\u0302[a]\u3009 and giving this example a weight of |r\u0302t,keep\u2212 r\u0302t,prune|. Our specific classifier is described in \u00a76.\nIn summary, the evaluation phase of LOLS collects training data for a cost-sensitive classifier, where the\ninputs (states), outputs (actions), and costs are obtained by interacting with the environment. LOLS concocts a training set and repeatedly revises it, similar to the well-known Expectation-Maximization algorithm. This enables end-to-end training of systems with discrete decisions and nondecomposable reward functions. LOLS gives us a principled framework for deriving (nonstationary) \u201csupervision\u201d even in tricky cases such as latent-variable inference (mentioned in \u00a73). LOLS has strong theoretical guarantees, though in pathological cases, it may take exponential time to converge (Chang et al., 2015b).\nThe inner loop of the evaluation phase performs roll-ins, interventions and rollouts. Roll-ins ensure that the policy is (eventually) trained under the distribution of states it tends to encounter at test time. Interventions and rollouts force \u03c0i to explore the effect of currently disfavored actions."}, {"heading": "5 Efficient rollouts", "text": "Unlike most applications of LOLS and related algorithms, such as SEARN (Daum\u00e9 III, 2006) and DAGGER (Ross et al., 2011), executing the policy is a major bottleneck in training. Because our dynamic programming parser explores many possibilities (unlike a greedy, transition-based decoder) its trajectories are quite long. This not only slows down each rollout: it means we must do more rollouts.\nIn our case, the trajectory has length T = n\u00b7(n+1)\n2 \u2212 1\u2212 n for a sentence of length n, where T is also the number of pruning decisions: one for each span other than the root and width-1 spans. LOLS must then perform T rollouts on this example. This means that to evaluate policy \u03c0i, we must parse each sentence in the minibatch hundreds of times (e.g., 189 for n=20, 434 for n=30, and 779 for n=40).\nWe can regard each policy \u03c0 as defining a pruning\nmask m, an array that maps each of the T spans (i, k) to a decision mik (1 = keep, 0 = prune). Each rollout tries flipping a different bit in this mask.\nWe could spend less time on each sentence by sampling only some of its T rollouts (see \u00a76). Regardless, the rollouts we do on a given sentence are related: in this section we show how to get further speedups by sharing work among them. In \u00a75.2, we leverage the fact that rollouts will be similar to one another (differing by a single pruning decision). In \u00a75.3, we show that the reward of all T rollouts can be computed simultaneously by dynamic programming under some assumptions about the structure of the reward function (described later). We found these algorithms to be crucial to training in a \u201creasonable\u201d amount of time (see the empirical comparison in \u00a77.2)."}, {"heading": "5.1 Background: Parsing as hypergraphs", "text": "It is convenient to present our efficient rollout algorithms in terms of the hypergraph structure of Alg. 1 (Klein and Manning, 2001; Huang, 2008; Li and Eisner, 2009; Eisner and Blatz, 2007). A hypergraph describes the information flow among related quantities in a dynamic programming algorithm. Many computational tricks apply generically to hypergraphs.\nA hypergraph edge e (or hyperedge) is a \u201cgeneralized arrow\u201d e.head \u227a e.Tail with one output and a list of inputs. We regard each quantity \u03b2ikx,mik, or G(. . .) in Alg. 1 as the value of a corresponding hypergraph vertex \u03b2\u0307ikx, m\u0307ik, or G\u0307(. . .). Thus, value(v\u0307) = v for any vertex v\u0307. Each m\u0307ik\u2019s value is computed by the policy \u03c0 or chosen by a rollout intervention. Each G\u0307\u2019s value is given by the grammar.\nValues of \u03b2\u0307ikx, by contrast, are computed at line 19 if k \u2212 i > 1. To record the dependence of \u03b2ikx on other quantities, our hypergraph includes the hyperedge \u03b2\u0307ikx \u227a (\u03b2\u0307ijy, \u03b2\u0307jkz, m\u0307ik, g\u0307) for each 0 \u2264 i < j < k \u2264 n and (x\u2192 y z) \u2208 rules(G), where g\u0307 denotes the vertex G\u0307(x\u2192 y z | w, i, j, k).\nIf k \u2212 i = 1, then values of \u03b2ikx are instead computed at line 6, which does not access any other \u03b2 values or the pruning mask. Thus our hypergraph includes the hyperedge vikx \u227a(g\u0307) whenever i = k\u22121, 0 \u2264 i < k \u2264 n, and (x\u2192 wk) \u2208 rules(G), with g\u0307 = G\u0307(x\u2192 wk | w, k).\nWith this setup, the value \u03b2ikx is the maximum score of any derivation of vertex \u03b2\u0307ikx (a tree rooted at \u03b2\u0307ikx, representing a subderivation), where the score\nof a derivation is the product of its leaf values. Alg. 1 computes it by considering hyperedges \u03b2\u0307ikx \u227a T and the previously computed values of the vertices in the tail T . For a vertex v\u0307, we write In(v\u0307) and Out(v\u0307) for its sets of incoming and outgoing hyperedges. Our algorithms follow these hyperedges implicitly, without the overhead of materializing or storing them."}, {"heading": "5.2 Change propagation (CP)", "text": "Change propagation is an efficient method for incrementally re-evaluating a computation under a change to its inputs (Acar and Ley-Wild, 2008; Filardo and Eisner, 2012). In our setting, each roll-in at Alg. 2 line 6 evaluates the reward r(PARSE(G, xi, \u03c0)) from (1), which involves computing an entire parse chart via Alg. 1. The inner loop at line 10 performs T interventions per roll-in, which ask how reward would have changed if one bit in the pruning maskm had been different. Rather than reparsing from scratch (T times) to determine this, we can simply adjust the initial roll-in computation (T times).\nCP is efficient when only a small fraction of the computation needs to be adjusted. In principle, flipping a single pruning bit can change up to 50% of the chart, so one might expect the bookkeeping overhead of CP to outweigh the gains. In practice, however, 90% of the interventions change < 10% of the \u03b2 values in the chart. The reason is that \u03b2ikx is a maximum over many quantities, only one of which \u201cwins.\u201d Changing a given \u03b2ijy rarely affects this maximum, and so changes are unlikely to propagate from vertex \u03b2\u0307ijy to \u03b2\u0307ikx. Since changes are not very contagious, the \u201cepidemic of changes\u201d does not spread far.\nAlg. 3 provides pseudocode for updating the highest-scoring derivation found by Alg. 1. We remark that the RECOMPUTE is called only when we flip a bit from keep to prune, which removes hyperedges and potentially decreases vertex values. The reverse flip only adds hyperedges, which increases vertex values via a running max (lines 12\u201314).\nAfter determining the effect of flipping a bit, we must restore the original chart before trying a different bit (the next rollout). The simplest approach is to call Alg. 3 again to flip the bit back.5\n5Our implementation uses a slightly faster method which accumulates an \u201cundo list\u201d of changes that it makes to the chart to quickly revert the modified chart to the original roll-in state.\nAlgorithm 3 Change propagation algorithm 1: Global: Alg. 1\u2019s vertex values/witnesses (roll-in) 2: procedure CHANGE(v\u0307, v) 3: . Change the value of a leaf vertex v\u0307 to v 4: value(v\u0307) := v ; witness(v\u0307) = LEAF 5: Q := \u2205; Q.push(v\u0307) . Work queue (\u201cagenda\u201d) 6: while Q 6= \u2205 : . Propagate until convergence 7: u\u0307 := Q.pop() . Narrower constituents first 8: if witness(u\u0307) = NULL : . Value is unknown 9: RECOMPUTE(u\u0307) . Get value & witness\n10: for e \u2208 Out(u\u0307) : . Propagate new value of u\u0307 11: s\u0307 := e.head; s := \u220f u\u0307\u2032\u2208e.Tail value(u\u0307\n\u2032) 12: if s > value(s\u0307) : . Increase value 13: value(s\u0307) := s; witness(s\u0307) := e 14: Q.push(s\u0307) 15: else if witness(s\u0307) = e and s < value(s\u0307): 16: witness(s\u0307) := NULL .Value may decrease 17: Q.push(s\u0307) . so, recompute upon pop 18: procedure RECOMPUTE(s\u0307) 19: for e \u2208 In(s\u0307) : . Max over incoming hyperedges 20: s := \u220f u\u0307\u2208e.Tail value(u\u0307) 21: if s > value(s\u0307) : 22: value(s\u0307) = s; witness(s\u0307) = e"}, {"heading": "5.3 Dynamic programming (DP)", "text": "The naive rollout algorithm runs the parser T times\u2014 once for each variation of the pruning mask. The reader may be reminded of the finite difference approximation to the gradient of a function, which also measures the effects from perturbing each input value individually. In fact, for certain reward functions, the naive algorithm can be precisely regarded as computing a gradient\u2014and thus we can use a more efficient algorithm, back-propagation, which finds the entire gradient vector of reward as fast (in the big-O sense) as computing the reward once. The overall algorithm is O(|E| + T ) where |E| is the total number of hyperedges, whereas the naive algorithm is O(|E\u2032|\u00b7T ) where |E\u2032| \u2264 |E| is the maximum number of hyperedges actually visited on any rollout.\nWhat accuracy measure must we use? Let r(d) denote the recall of a derivation d\u2014the fraction of gold constituents that appear as vertices in the derivation. A simple accuracy metric would be 1-best recall, the recall r(d\u0302) of the highest-scoring derivation d\u0302 that was not pruned. In this section, we relax that to ex-\npected recall,6 r\u0304= \u2211\nd p(d)r(d). Here we interpret the pruned hypergraph\u2019s values as an unnormalized probability distribution over derivations, where the probability p(d) = p\u0303(d)/Z of a derivation is proportional to its score p\u0303(d) = \u220f u\u0307\u2208leaves(d) value(u\u0307).\nThough r\u0304 is not quite our evaluation metric, it captures more information about the parse forest, and so may offer some regularizing effect when used in a training criterion (see \u00a77.1). In any case, r\u0304 is close to r(d\u0302) when probability mass is concentrated on a few derivations, which is common with heavy pruning.\nWe can re-express r\u0304 as r\u0303/Z, where\nr\u0303 = \u2211\nd\np\u0303(d)r(d) Z = \u2211\nd\np\u0303(d) (2)\nThese can be efficiently computed by dynamic programming (DP), specifically by a variant of the inside algorithm (Li and Eisner, 2009). Since p\u0303(d) is a product of rule weights and pruning mask bits at d\u2019s leaves (\u00a75.1), each appearing at most once, both r\u0303 and Z vary linearly in any one of these inputs provided that all other inputs are held constant. Thus, the exact effect on r\u0303 or Z of changing an input mik can be found from the partial derivatives with respect to it. In particular, if we increased mik by \u2206 \u2208 {\u22121, 1} (to flip this bit), the new value of r\u0304 would be exactly\nr\u0303 + \u2206 \u00b7 \u2202r\u0303/\u2202mik Z + \u2206 \u00b7 \u2202Z/\u2202mik\n(3)\nIt remains to compute these partial derivatives. All partials can be jointly computed by back-propagation, which equivalent to another dynamic program known as the outside algorithm (Eisner, 2016).\nThe inside algorithm only needs to visit the |E\u2032| unpruned edges, but the outside algorithm must also visit some pruned edges, to determine the effect of \u201cunpruning\u201d them (changing their mik input from 0 to 1) by finding \u2202r\u0303/\u2202mik and \u2202Z/\u2202mik. On the other hand, these partials are 0 when some other input to the hyperedge is 0. This case is common when the hypergraph is heavily pruned (|E\u2032| |E|), and means that back-propagation need not descend further through that hyperedge.\n6In theory, we could anneal from expected to 1-best recall (Smith and Eisner, 2006). We experimented extensively with annealing but found it to be too numerically unstable for our purposes, even with high-precision arithmetic libraries.\nNote that the DP method computes only the accuracies of rollouts\u2014not the runtimes. In this paper, we will combine DP with a very simple runtime measure that is trivial to roll out (see \u00a77). An alternative would be to use CP to roll out the runtimes. This is very efficient: to measure just runtime, CP only needs to update the record of which constituents or edges are built, and not their scores, so the changes are easier to compute than in \u00a75.2, and peter out more quickly.\n6 Parser details7\nSetup: We use the standard English parsing setup: the Penn Treebank (Marcus et al., 1993) with the standard train/dev/test split, and standard tree normalization.8 For efficiency during training, we restrict the length of sentences to \u2264 40. We do not restrict the length of test sentences. We experiment with two grammars: coarse, the \u201cno frills\u201d left-binarized treebank grammar, and fine, a variant of the Berkeley split-merge level-6 grammar (Petrov et al., 2006) as provided by Dunlop (2014, ch. 5). The parsing algorithms used during training are described in \u00a75. Our test-time parsing algorithm uses the left-child loop implementation of CKY (Dunlop et al., 2010). All algorithms allow unary rules (though not chains). We evaluate accuracy at test time with the F1 score from the official EVALB script (Sekine and Collins, 1997).\nTraining: Note that we never retrain the grammar weights\u2014we train only the pruning policy. To TRAIN our classifiers (Alg. 2 line 13), we use L2-regularized logistic regression, trained with L-BFGS optimization. We always rescale the example weights in the training set to sum to 1 (otherwise as LOLS proceeds, dataset aggregation overwhelms the regularizer). For the baseline (defined in next section), we determine the regularization coefficient by sweeping {2\u221211, 2\u221212, 2\u221213, 2\u221214, 2\u221215} and picking the best value (2\u221213) based on the dev frontier. We re-used this regularization parameter for LOLS. The number of LOLS iterations is determined by a 6-day training-time limit9 (meaning some jobs run many\n7Code for experiments is available at http://github. com/timvieira/learning-to-prune.\n8Data train/dev/test split (by section) 2\u201321 / 22 / 23. Normalization operations: Remove function tags, traces, spurious unary edges (X \u2192 X), and empty subtrees left by other operations. Relabel ADVP and PRT|ADVP tags to PRT.\n9On the 7th day, LOLS rested and performance was good.\nfewer iterations than others). For LOLS minibatch size we use 10K on the coarse grammar and 5K on the fine grammar. At line 15 of Alg. 2, we return the policy that maximized reward on development data, using the reward function from training.\nFeatures: We use similar features to Bodenstab et al. (2011), but we have removed features that depend on part-of-speech tags. We use the following 16 feature templates for span (i, k) with 1 < k\u2212i < N : bias, sentence length, boundary words, conjunctions of boundary words, conjunctions of word shapes, span shape, width bucket. Shape features map a word or phrase into a string of character classes (uppercase, lowercase, numeric, spaces); we truncate substrings of identical classes to length two; punctuation chars are never modified in any way. Width buckets use the following partition: 2, 3, 4, 5, [6, 10], [11, 20], [21,\u221e). We use feature hashing (Weinberger et al., 2009) with MurmurHash3 (Appleby, 2008) and project to 222 features. Conjunctions are taken at positions (i\u22121, i), (k, k+1), (i\u22121, k+1) and (i, k). We use special begin and end symbols when a template accesses positions beyond the sentence boundary.\nHall et al. (2014) give examples motivating our feature templates and show experimentally that they are effective in multiple languages. Boundary words are strong surface cues for phrase boundaries. Span shape features are also useful as they (minimally) check for matched parentheses and quotation marks."}, {"heading": "7 Experimental design and results", "text": "Reward functions and surrogates: Each user has a personal reward function. In this paper, we choose to specify our true reward as accuracy \u2212 \u03bb \u00b7 runtime, where accuracy is given by labeled F1 percentage and runtime by mega-pushes (mpush), millions of calls per sentence to lines 6 and 19 of Alg. 1, which is in practice proportional to seconds per sentence (correlation > 0.95) and is more replicable. We evaluate accordingly (on test data)\u2014but during LOLS training we approximate these metrics. We compare:\n\u2022 rCP (fast): Use change propagation (\u00a75.2) to compute accuracy on a sentence as F1 of just that sentence, and to approximate runtime as ||\u03b2||0,\nthe number of constituents that were built.10\n\u2022 rDP (faster): Use dynamic programming (\u00a75.3) to approximate accuracy on a sentence as expected recall.11 This time we approximate runtime more crudely as ||m||0, the number of nonzeros in the pruning mask for the sentence (i.e., the number of spans whose constituents the policy would be willing to keep if they were built).\nWe use these surrogates because they admit efficient rollout algorithms. Less important, they preserve the training objective (1) as an average over sentences. (Our true F1 metric on a corpus cannot be computed in this way, though it could reasonably be estimated by averaging over minibatches of sentences in (1).)\nControlled experimental design: Our baseline system is an adaptation of Bodenstab et al. (2011) to learning-to-prune, as described in \u00a73 and \u00a76. Our goal is to determine whether such systems can be improved by LOLS training. We repeat the following design for both reward surrogates (rCP and rDP) and for both grammars (coarse and fine).\n\u00ac We start by training a number of baseline models by sweeping the asymmetric weighting parameter. For the coarse grammar we train 8 such models, and for the fine grammar 12.\n For each baseline policy, we estimate a value of \u03bb for which that policy is optimal (among baseline policies) according to surrogate reward.12\n10When using rCP, we speed up LOLS by doing\u2264 2n rollouts per sentence of length n. We sample these uniformly without replacement from the T possible rollouts (\u00a75), and compensate by upweighting the resulting training examples by T/(2n).\n11Considering all nodes in the binarized tree, except for the root, width-1 constituents, and children of unary rules.\n12We estimate \u03bb by first fitting a parametric model yi = h(xi) , ymax \u00b7 sigmoid(a \u00b7 log(xi + c) + b) to the baseline runtime-accuracy measurements on dev data (shown in green in Fig. 2) by minimizing mean squared error. We then use the fitted curve\u2019s slope h\u2032 to estimate each \u03bbi = h\u2032(xi), where xi is the runtime of baseline i. The resulting choice of reward function y\u2212\u03bbi \u00b7x increases along the green arrow in Fig. 2, and is indeed maximized (subject to y \u2264 h(x), and in the region where h is concave) at x = xi. As a sanity check, notice since \u03bbi is a derivative of the function y = h(x), its units are in units of y (accuracy) per unit of x (runtime), as appropriate for use in the expression y \u2212 \u03bbi \u00b7 x. Indeed, this procedure will construct the same reward function regardless of the units we use to express x. Our specific parametric model h is a sigmoidal curve, with\n\u00ae For each baseline policy, we run LOLS with the same surrogate reward function (defined by \u03bb) for which that baseline policy was optimal. We initialize LOLS by setting \u03c00 to the baseline policy. Furthermore, we include the baseline policy\u2019s weighted training set Q\u03020 in the \u22c3 at line 13.\nFig. 2 shows that LOLS learns to improve on the baseline, as evaluated on development data.\n\u00af But do these surrogate reward improvements also improve our true reward? For each baseline policy, we use dev data to estimate a value of \u03bb for which that policy is optimal according to our true reward function. We use blind test data to compare the baseline policy to its corresponding LOLS policy on this true reward function, testing significance with a paired permutation test. The improvements hold up, as shown in Fig. 3.\nThe rationale behind this design is that a user who actually wishes to maximize accuracy\u2212\u03bb\u00b7runtime, for some specific \u03bb, could reasonably start by choosing the best baseline policy for this reward function, and then try to improve that baseline by running LOLS with the same reward function. Our experiments show this procedure works for a range of \u03bb values.\nIn the real world, a user\u2019s true objective might instead be some nonlinear function of runtime and accuracy. For example, when accuracy is \u201cgood enough,\u201d it may be more important to improve runtime, and vice-versa. LOLS could be used with such a nonlinear reward function as well. In fact, a user does not even have to quantify their global preferences by writing down such a function. Rather, they could select manually among the baseline policies, choosing one with an attractive speed-accuracy tradeoff, and then specify \u03bb to indicate a local direction of desired improvement (like the green arrows in Fig. 2), modifying this direction periodically as LOLS runs."}, {"heading": "7.1 Discussion", "text": "As previous work has shown, learning to prune gives us excellent parsers with less than < 2% overhead\naccuracy \u2192 ymax asymptotically as runtime \u2192 \u221e. It obtains an excellent fit by placing accuracy and runtime on the loglogit scale\u2014that is, log(xi + c) and logit(yi/ymax) transforms are used to convert our bounded random variables xi and yi to unbounded ones\u2014and then assuming they are linearly related.\nfor deciding what to prune (i.e., pruning feature extraction and span classification). Even the baseline pruner has access to features unavailable to the grammar, and so it learns to override the grammar, improving an unpruned coarse parser\u2019s accuracy from 61.1 to as high as 70.1% F1 on test data (i.e., beneficial search error). It is also 8.1x faster!13 LOLS simply does a better job at figuring out where to prune, raising accuracy 2.1 points to 72.2 (while maintaining a 7.4x speedup). Where pruning is more aggressive,\n13We measure runtime as best of 10 runs (recommended by Dunlop (2014)). All parser timing experiments were performed on a Linux laptop with the following specs: Intel\u00ae Core\u2122 i5-2540M 2.60GHz CPU, 8GB memory, 32K/256K/3072K L1/L2/L3 cache. Code is written in the Cython language.\nLOLS has even more impact on accuracy.\nEven on the fine grammar, where there is less room to improve accuracy, the most accurate LOLS system improves an unpruned parser by +0.16% F1 with a 8.6x speedup. For comparison, the most accurate baseline drops \u22120.03% F1 with a 9.7x speedup.\nWith the fine grammar, we do not see much improvement over the baseline in the accuracy > 85 regions. This is because the supervision specified by asymmetric weighting is similar to what LOLS surmises via rollouts. However, in lower-accuracy regions we see that LOLS can significantly improve reward over its baseline policy. This is because the baseline supervision does not teach which plausible\nconstituents are \u201csafest\u201d to prune, nor can it learn strategies such as \u201cskip all long sentences.\u201d We discuss why LOLS does not help as much in the high accuracy regions further in \u00a77.3.\nIn a few cases in Fig. 2, LOLS finds no policy that improves surrogate reward on dev data. In these cases, surrogate reward does improve slightly on training data (not shown), but early stopping just keeps the initial (baseline) policy since it is just as good on dev data. Adding a bit of additional random exploration might help break out of this initialization.\nInterestingly, the rDP LOLS policies find higheraccuracy policies than the corresponding rCP policies, despite a greater mismatch in surrogate accuracy definitions. We suspect that rDP\u2019s approach of trying to improve expected accuracy may provide a useful regularizing effect, which smooths out the reward signal and provides a useful bias (\u00a75.3).\nThe most pronounced qualitative difference due to LOLS training is substantially lower rates of parse failure in the mid- to high- \u03bb-range on both grammars\n(not shown). Since LOLS does end-to-end training, it can advise the learner that a certain pruning decision catastrophically results in no parse being found."}, {"heading": "7.2 Training speed and convergence", "text": "Part of the contribution of this paper is faster algorithms for performing LOLS rollouts during training (\u00a75). Compared to the naive strategy of running the parser from scratch T times, rCP achieves speedups of 4.9\u20136.6x on the coarse grammar and 1.9\u20132.4x on the fine grammar. rDP is even faster, 10.4\u201311.9x on coarse and 10.5\u201313.8x on fine. Most of the speedup comes from longer sentences, which take up most of the runtime for all methods. Our new algorithms enable us to train on fairly long sentences (\u2264 40). We note that our implementations of rCP and rDP are not as highly optimized as our test-time parser, so there may be room for improvement.\nOrthogonal to the cost per rollout is the number of training iterations. LOLS may take many steps to converge if trajectories are long (i.e., T is large)\nbecause each iteration of LOLS training attempts to improve the current policy by a single action. In our setting, T is quite large (discussed extensively in \u00a75), but we are able to circumvent slow convergence by initializing the policy (via the baseline method). This means that LOLS can focus on fine-tuning a policy which is already quite good. In fact, in 4 cases, LOLS did not improve from its initial policy.\nWe find that when \u03bb is large\u2014the cases where we get meaningful improvements because the initial policy is far from locally optimal\u2014LOLS steadily and smoothly improves the surrogate reward on both training and development data. Because these are fast parsers, LOLS was able to run on the order of 10 (fine grammar) or 100 (coarse grammar) epochs within our 6-day limit; usually it was still improving when we terminated it. By contrast, for the slower and more accurate small-\u03bb parsers (which completed fewer training epochs), LOLS still improves surrogate reward on training data, but without systematically improving on development data\u2014often the reward on development fluctuates, and early stopping simply picks the best of this small set of \u201crandom\u201d variants."}, {"heading": "7.3 Understanding the LOLS training signal", "text": "In \u00a73, we argued that LOLS gives a more appropriate training signal for pruning than the baseline method of consulting the gold parse, because it uses rollouts to measure the full effect of each pruning decision in the context of the other decisions made by the policy.\nTo better understand the results of our previous experiments, we analyze how often a rollout does determine that the baseline supervision for a span is suboptimal, and how suboptimal it is in those cases.\nWe specifically consider LOLS rollouts that evaluate the rCP surrogate (because rDP is a cruder approximation to true reward). These rollouts Q\u0302i tell us what actions LOLS is trying to improve in its current policy \u03c0i for a given \u03bb, although there is no guarantee that the learner in \u00a74 will succeed at classifying Q\u0302i correctly (due to limited features, regularization, and the effects of dataset aggregation).\nWe define regret of the baseline oracle. Let best(s) , argmaxaROLLOUT(\u03c0, s, a) and regret(s) , (ROLLOUT(\u03c0, s, best(s) \u2212 ROLLOUT(\u03c0, s, gold(s)))). Note that regret(s)\u22650 for all s, and let diff(s) be the event that regret(s) > 0 strictly. We are interested in analyzing the expected regret over all gold and\nnon-gold spans, which we break down as\nE[regret] = p(diff) (4) \u00b7 ( p(gold | diff) \u00b7 E[regret | gold, diff] + p(\u00ac gold | diff) \u00b7 E[regret | \u00ac gold, diff] )\nwhere expectations are taken over s \u223c ROLL-IN(\u03c0). Empirical analysis of regret: To show where the benefit of the LOLS oracle comes from, Fig. 4 graphs the various quantities that enter into the definition (4) of baseline regret, for different \u03c0, \u03bb, and grammar. The LOLS oracle evolves along with the policy \u03c0, since it identifies the best action given \u03c0. We thus evaluate the oracle baseline against two LOLS oracles: the one used at the start of LOLS training (derived from the initial policy \u03c01 that was trained on baseline supervision), and the one obtained at the end (derived from the LOLS-trained policy \u03c0\u2217 selected by early stopping). These comparisons are shown by solid and dashed lines respectively.\nClass imbalance (black curves): In all graphs, the aggregate curves primarily reflect the non-gold spans, since only 8% of spans are gold.\nGold spans (gold curves): The top graphs show that a substantial fraction of the gold spans should be pruned (whereas the baseline tries to keep them all), although the middle row shows that the benefit of pruning them is small. In most of these cases, pruning a gold span improves speed but leaves accuracy unchanged\u2014because that gold span was missed anyway by the highest-scoring parse. Such cases become both more frequent and more beneficial as \u03bb increases and we prune more heavily. In a minority of cases, however, pruning a gold span also improves accuracy (through beneficial search error).\nNon-gold spans (purple curves): Conversely, the top graphs show that a few non-gold spans should be kept (whereas the baseline tries to prune them all), and the middle row shows a large benefit from keeping them. They are needed to recover from catastrophic errors and get a mostly-correct parse.\nCoarse vs. fine (left vs. right): The two grammars differ mainly for small \u03bb, and this difference comes especially from the top row. With a fine grammar and small \u03bb, the baseline parses are more accurate, so LOLS has less room for improvement: fewer\ngold spans go unused, and fewer non-gold spans are needed for recovery.\nEffect of \u03bb: Aggressive pruning (large \u03bb) reduces accuracy, so its effect on the top row is similar to that of using a coarse grammar. Aggressive pruning also has an effect on the middle row: there is more benefit to be derived from pruning unused gold spans (surprisingly), and especially from keeping those non-gold spans that are helpful (presumably they enable recovery from more severe parse errors). These effects are considerably sharper with rDP reward (not shown here), which more smoothly evaluates the entire weighted pruned parse forest rather than trying to coordinate actions to ensure a good single 1-best tree; the baseline oracle is excellent at choosing the action that gets the better forest when the forest is mostly present (small \u03bb) but not when it is mostly pruned (large \u03bb).\nEffect on retraining the policy: The black lines in the bottom graphs show the overall regret (on training data) if we were to perfectly follow the baseline oracle rather than the LOLS oracle. In practice, retraining the policy to match the oracle will not match it perfectly in either case. Thus the baseline method has a further disadvantage: when it trains a policy, its training objective weights all gold or all non-gold examples equally, whereas LOLS invests greater effort in matching the oracle on those states where doing so would give greater downstream reward."}, {"heading": "8 Related work", "text": "Our experiments have focused on using LOLS to improve a reasonable baseline. Fig. 5 shows that our resulting parser fits reasonably among state-of-the-art constituency parsers trained and tested on the Penn Treebank. These parsers include a variety of techniques that improve speed or accuracy. Many are quite orthogonal to our work here\u2014e.g., the SpMV method (which is necessary for Bodenstab\u2019s parser to beat ours) is a set of cache-efficient optimizations (Dunlop, 2014) that could be added to our parser (just as it was added to Bodenstab\u2019s), while Hall et al. (2014) and Fern\u00e1ndez-Gonz\u00e1lez and Martins (2015) replace the grammar with faster scoring models that have more conditional independence. Overall, other fast parsers could also be trained using LOLS, so that\nthey quickly find parses that are accurate, or at least helpful to the accuracy of some downstream task.\nPruning methods14 can use classifiers not only to select spans but also to prune at other granularities (Roark and Hollingshead, 2008; Bodenstab et al., 2011). Prioritization methods do not prune substructures, but instead delay their processing until they are needed\u2014if ever (Caraballo and Charniak, 1998).\nThis paper focuses on learning pruning heuristics that have trainable parameters. In the same way, Stoyanov and Eisner (2012) learn to turn off unneeded factors in a graphical model, and Jiang et al. (2012) and Berant and Liang (2015) train prioritization heuristics (using policy gradient). In both of those 2012 papers, we explicitly sought to maximize accuracy \u2212 \u03bb \u00b7 runtime as we do here. Some previous \u201ccoarse-to-fine\u201d work does not optimize heuris-\n14We focus here on parsing, but pruning is generally useful in structured prediction. E.g., Xu et al. (2013) train a classifier to prune (latent) alignments in a machine translation system.\ntics directly but rather derives heuristics for pruning (Charniak et al., 2006; Petrov and Klein, 2007; Weiss and Taskar, 2010; Rush and Petrov, 2012) or prioritization (Klein and Manning, 2003; Pauls and Klein, 2009) from a coarser version of the model. Combining these automatic methods with LOLS would require first enriching their heuristics with trainable parameters, or parameterizing the coarse-to-fine hierarchy itself as in the \u201cfeature pruning\u201d work of He et al. (2013) and Strubell et al. (2015).\nDynamic features are ones that depend on previous actions. In our setting, a policy could in principle benefit from considering the full state of the chart at Alg. 1 line 14. While coarse-to-fine methods implicitly use certain dynamic features, training with dynamic features is a fairly new goal that is challenging to treat efficiently. It has usually been treated with some form of simple imitation learning, using a heuristic training signal much as in our baseline (Jiang, 2014; He et al., 2013). LOLS would be a more principled way to train such features, but for efficiency, our present paper restricts to static features that only access the state via \u03c0(w, i, k). This permits our fast CP and DP rollout algorithms. It also reduces the time and space cost of dataset aggregation.15\nLOLS attempts to do end-to-end training of a sequential decision-making system, without falling back on black-box optimization tools (Och, 2003; Chung and Galley, 2012) that ignore the sequential structure. In NLP, sequential decisions are more commonly trained with step-by-step supervision\n15LOLS repeatedly evaluates actions given (w, i, k). We consolidate the resulting training examples by summing their reward vectors r\u0302, so the aggregated dataset does not grow over time.\n(Kuhlmann et al., 2011), using methods such as local classification (Punyakanok and Roth, 2001) or beam search with early update (Collins and Roark, 2004). LOLS tackles the harder setting where the only training signal is a joint assessment of the entire sequence of actions. It is an alternative to policy gradient, which does not scale well to our long trajectories because of high variance in the estimated gradient and because random exploration around (even good) pruning policies most often results in no parse at all. LOLS uses controlled comparisons, resulting in more precise \u201ccredit assignment\u201d and tighter exploration.\nWe would be remiss not to note that current transition-based parsers\u2014for constituency parsing (Zhu et al., 2013; Crabb\u00e9, 2015) as well as dependency parsing (Chen and Manning, 2014)\u2014are both incredibly fast and surprisingly accurate. This may appear to undermine the motivation for our work, or at least for its application to fast parsing.16 However, transition-based parsers do not produce marginal probabilities of substructures, which can be useful features for downstream tasks. Indeed, the transitionbased approach is essentially greedy and so it may fail on tasks with more ambiguity than parsing. Current transition-based parsers also require step-by-step supervision, whereas our method can also be used to train in the presence of incomplete supervision, latent structure, or indirect feedback. Our method could also be used immediately to speed up dynamic programming methods for MT, synchronous parsing, parsing with non-context-free grammar formalisms, and other structured prediction problems for which transition systems have not (yet) been designed."}, {"heading": "9 Conclusions", "text": "We presented an approach to learning pruning policies that optimizes end-to-end performance on a userspecified speed-accuracy tradeoff. We developed two novel algorithms for efficiently measuring how varying policy actions affects reward. In the case of parsing, given a performance criterion and a good baseline policy for that criterion, the learner consistently manages to find a higher-reward policy. We hope this work inspires a new generation of fast and accurate structured prediction models with tunable runtimes.\n16Of course, LOLS can also train transition-based parsers (Chang et al., 2015a), or even vary their beam width dynamically."}, {"heading": "Acknowledgments", "text": "This material is based in part on research sponsored by the National Science Foundation under Grant No. 0964681 and DARPA under agreement number FA8750-13-2-0017 (DEFT program). We\u2019d like to thank Nathaniel Wesley Filardo, Adam Teichert, Matt Gormley and Hal Daum\u00e9 III for helpful discussions. Finally, we thank TACL action editor Marco Kuhlmann and the anonymous reviewers and copy editor for suggestions that improved this paper."}], "year": 2017, "references": [{"title": "Self-adjusting computation with Delta ML", "authors": ["Umut A. Acar", "Ruy Ley-Wild."], "venue": "Pieter Koopman and Doaitse Swierstra, editors, Advanced Functional Programming, pages 1\u201338.", "year": 2008}, {"title": "Murmurhash3", "authors": ["Austin Appleby."], "venue": "https://sites. google.com/site/murmurhash.", "year": 2008}, {"title": "Imitation learning of agenda-based semantic parsers", "authors": ["Jonathan Berant", "Percy Liang."], "venue": "Transactions of the Association for Computational Linguistics, 3:545\u2013 558.", "year": 2015}, {"title": "Beam-width prediction for efficient CYK parsing", "authors": ["Nathan Bodenstab", "Aaron Dunlop", "Keith Hall", "Brian Roark."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2011}, {"title": "Prioritization and Pruning: Efficient Inference with Weighted ContextFree Grammars", "authors": ["Nathan Matthew Bodenstab."], "venue": "Ph.D. thesis, Oregon Health and Science University.", "year": 2012}, {"title": "New figures of merit for best-first probabilistic chart parsing", "authors": ["Sharon A. Caraballo", "Eugene Charniak."], "venue": "Computational Linguistics, 24(2):275\u2013298.", "year": 1998}, {"title": "Learning to search for dependencies", "authors": ["Kai-Wei Chang", "He He", "Hal Daum\u00e9 III", "John Langford."], "venue": "Computing Research Repository, arXiv:1503.05615.", "year": 2015}, {"title": "Learning to search better than your teacher", "authors": ["Kai-Wei Chang", "Akshay Krishnamurthy", "Alekh Agarwal", "Hal Daum\u00e9 III", "John Langford."], "venue": "Proceedings of the International Conference on Machine Learning.", "year": 2015}, {"title": "Multilevel coarse-to-fine PCFG parsing", "authors": ["Eugene Charniak", "Mark Johnson", "Micha Elsner", "Joseph Austerweil", "David Ellis", "Isaac Haxton", "Catherine Hill", "R. Shrivaths", "Jeremy Moore", "Michael Pozar", "Theresa Vu."], "venue": "Proceedings of the Conference of the North", "year": 2006}, {"title": "A fast and accurate dependency parser using neural networks", "authors": ["Danqi Chen", "Christopher D. Manning."], "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing.", "year": 2014}, {"title": "Direct error rate minimization for statistical machine translation", "authors": ["Tagyoung Chung", "Michel Galley."], "venue": "Proceedings of the Workshop on Statistical Machine Translation.", "year": 2012}, {"title": "Incremental parsing with the perceptron algorithm", "authors": ["Michael Collins", "Brian Roark."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2004}, {"title": "Multilingual discriminative lexicalized phrase structure parsing", "authors": ["Benoit Crabb\u00e9."], "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing.", "year": 2015}, {"title": "Practical Structured Learning Techniques for Natural Language Processing", "authors": ["Harold Charles Daum\u00e9 III."], "venue": "Ph.D. thesis, University of Southern California.", "year": 2006}, {"title": "Reducing the grammar constant: An analysis of CYK parsing efficiency", "authors": ["Aaron Dunlop", "Nathan Bodenstab", "Brian Roark."], "venue": "Technical report, CSLU-2010-02, OHSU.", "year": 2010}, {"title": "Efficient Latent-Variable Grammars: Learning and Inference", "authors": ["Aaron Joseph Dunlop."], "venue": "Ph.D. thesis, Oregon Health and Science University.", "year": 2014}, {"title": "Recurrent neural network grammars", "authors": ["Chris Dyer", "Adhiguna Kuncoro", "Miguel Ballesteros", "Noah A. Smith."], "venue": "Computing Research Repository, arxiv:1602.07776.", "year": 2016}, {"title": "Recurrent neural network grammars", "authors": ["Chris Dyer", "Adhiguna Kuncoro", "Miguel Ballesteros", "Noah A. Smith."], "venue": "Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics.", "year": 2016}, {"title": "Program transformations for optimization of parsing algorithms and other weighted logic programs", "authors": ["Jason Eisner", "John Blatz."], "venue": "Proceedings of the Conference on Formal Grammar. CSLI Publications.", "year": 2007}, {"title": "Inside-outside and forward-backward algorithms are just backprop", "authors": ["Jason Eisner."], "venue": "Proceedings of the EMNLP Workshop on Structured Prediction for NLP.", "year": 2016}, {"title": "Parsing as reduction", "authors": ["Daniel Fern\u00e1ndez-Gonz\u00e1lez", "Andr\u00e9 F.T. Martins."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2015}, {"title": "A flexible solver for finite arithmetic circuits", "authors": ["Nathaniel Wesley Filardo", "Jason Eisner."], "venue": "Technical Communications of the International Conference on Logic Programming, volume 17 of Leibniz International Proceedings in Informatics (LIPIcs).", "year": 2012}, {"title": "Efficient, feature-based, conditional random field parsing", "authors": ["Jenny Rose Finkel", "Alex Kleeman", "Christopher D. Manning."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2008}, {"title": "Less grammar, more features", "authors": ["David Hall", "Greg Durrett", "Dan Klein."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics. 276", "year": 2014}, {"title": "Dynamic feature selection for dependency parsing", "authors": ["He He", "Hal Daum\u00e9 III", "Jason Eisner."], "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing.", "year": 2013}, {"title": "Advanced dynamic programming in semiring and hypergraph frameworks", "authors": ["Liang Huang."], "venue": "Material accompanying tutorials at COLING\u201908 and NAACL\u201909.", "year": 2008}, {"title": "Learned prioritization for trading off accuracy and speed", "authors": ["Jiarong Jiang", "Adam Teichert", "Hal Daum\u00e9 III", "Jason Eisner."], "venue": "Advances in Neural Information Processing Systems.", "year": 2012}, {"title": "Efficient Non-deterministic Search in Structured Prediction: A Case Study in Syntactic Parsing", "authors": ["Jiarong Jiang."], "venue": "Ph.D. thesis, University of Maryland.", "year": 2014}, {"title": "Parsing and hypergraphs", "authors": ["Dan Klein", "Christopher D. Manning."], "venue": "International Workshop on Parsing Technologies.", "year": 2001}, {"title": "A* parsing: Fast exact Viterbi parse selection", "authors": ["Dan Klein", "Christopher D. Manning."], "venue": "Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics and Human Language Technology.", "year": 2003}, {"title": "Dynamic programming algorithms for transition-based dependency parsers", "authors": ["Marco Kuhlmann", "Carlos G\u00f3mez-Rodr\u00edguez", "Giorgio Satta."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2011}, {"title": "First- and second-order expectation semirings with applications to minimumrisk training on translation forests", "authors": ["Zhifei Li", "Jason Eisner."], "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing.", "year": 2009}, {"title": "Building a large annotated corpus of English: The Penn treebank", "authors": ["Mitchell P. Marcus", "Mary Ann Marcinkiewicz", "Beatrice Santorini."], "venue": "Computational Linguistics, 19(2).", "year": 1993}, {"title": "Probabilistic CFG with latent annotations", "authors": ["Takuya Matsuzaki", "Yusuke Miyao", "Jun\u2019ichi Tsujii"], "venue": "In Proceedings of the Conference of the Association for Computational Linguistics", "year": 2005}, {"title": "Minimum error rate training in statistical machine translation", "authors": ["Franz Josef Och."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2003}, {"title": "Hierarchical search for parsing", "authors": ["Adam Pauls", "Dan Klein."], "venue": "Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics and Human Language Technology.", "year": 2009}, {"title": "Improved inference for unlexicalized parsing", "authors": ["Slav Petrov", "Dan Klein."], "venue": "Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics and Human Language Technology.", "year": 2007}, {"title": "Learning accurate, compact, and interpretable tree annotation", "authors": ["Slav Petrov", "Leon Barrett", "Romain Thibaux", "Dan Klein."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2006}, {"title": "Coarseto-fine syntactic machine translation using language projections", "authors": ["Slav Petrov", "Aria Haghighi", "Dan Klein."], "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing.", "year": 2008}, {"title": "The use of classifiers in sequential inference", "authors": ["Vasin Punyakanok", "Dan Roth."], "venue": "Advances in Neural Information Processing Systems.", "year": 2001}, {"title": "Classifying chart cells for quadratic complexity context-free inference", "authors": ["Brian Roark", "Kristy Hollingshead."], "venue": "Proceedings of the International Conference on Computational Linguistics.", "year": 2008}, {"title": "Stability conditions for online learnability", "authors": ["St\u00e9phane Ross", "J. Andrew Bagnell."], "venue": "Computing Research Repository, arXiv:1108.3154.", "year": 2011}, {"title": "A reduction of imitation learning and structured prediction to no-regret online learning", "authors": ["St\u00e9phane Ross", "Geoff J. Gordon", "J. Andrew Bagnell."], "venue": "Proceedings of the Workshop on Artificial Intelligence and Statistics.", "year": 2011}, {"title": "Vine pruning for efficient multi-pass dependency parsing", "authors": ["Alexander M. Rush", "Slav Petrov."], "venue": "Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics.", "year": 2012}, {"title": "Evalb bracket scoring program", "authors": ["Satoshi Sekine", "Michael Collins."], "venue": "http://nlp.cs.nyu.edu/evalb.", "year": 1997}, {"title": "Minimum risk annealing for training log-linear models", "authors": ["David A. Smith", "Jason Eisner."], "venue": "Proceedings of the International Conference on Computational Linguistics.", "year": 2006}, {"title": "Fast and accurate prediction via evidence-specific MRF structure", "authors": ["Veselin Stoyanov", "Jason Eisner."], "venue": "ICML Workshop on Inferning: Interactions between Inference and Learning, Edinburgh, June. 6 pages.", "year": 2012}, {"title": "Learning dynamic feature selection for fast sequential prediction", "authors": ["Emma Strubell", "Luke Vilnis", "Kate Silverstein", "Andrew McCallum."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2015}, {"title": "Feature hashing for large scale multitask learning", "authors": ["Kilian Weinberger", "Anirban Dasgupta", "John Langford", "Alex Smola", "Josh Attenberg."], "venue": "Proceedings of the International Conference on Machine Learning.", "year": 2009}, {"title": "Structured prediction cascades", "authors": ["David Weiss", "Ben Taskar."], "venue": "Proceedings of the Workshop on Artificial Intelligence and Statistics.", "year": 2010}, {"title": "Learning to prune: Context-sensitive pruning for syntactic MT", "authors": ["Wenduan Xu", "Yue Zhang", "Philip Williams", "Philipp Koehn."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics.", "year": 2013}, {"title": "Fast and accurate shift-reduce constituent parsing", "authors": ["Muhua Zhu", "Yue Zhang", "Wenliang Chen", "Min Zhang", "Jingbo Zhu."], "venue": "Proceedings of the Conference of the Association for Computational Linguistics. 278", "year": 2013}], "id": "SP:ce23d7db83eda85717c342609df97f273c909bae", "authors": [{"name": "Tim Vieira", "affiliations": []}, {"name": "Jason Eisner", "affiliations": []}], "abstractText": "Pruning hypotheses during dynamic programming is commonly used to speed up inference in settings such as parsing. Unlike prior work, we train a pruning policy under an objective that measures end-to-end performance: we search for a fast and accurate policy. This poses a difficult machine learning problem, which we tackle with the LOLS algorithm. LOLS training must continually compute the effects of changing pruning decisions: we show how to make this efficient in the constituency parsing setting, via dynamic programming and change propagation algorithms. We find that optimizing end-to-end performance in this way leads to a better Pareto frontier\u2014i.e., parsers which are more accurate for a given runtime.", "title": "Learning to Prune: Exploring the Frontier of Fast and Accurate Parsing"}